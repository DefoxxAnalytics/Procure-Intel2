<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Procurement Analytics Dashboard with Seasonality Intelligence & Tail Spend Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* Theme Variables */
        :root {
            /* Light theme (default) */
            --bg-primary: #f5f7fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #fafbfc;
            --bg-hover: #f7fafc;
            --bg-gradient-start: transparent;
            --bg-gradient-end: transparent;
            
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-tertiary: #2d3748;
            --text-heading: #1a202c;
            --text-white: #ffffff;
            
            --border-primary: #e0e0e0;
            --border-secondary: #cbd5e0;
            --border-hover: #4a5568;
            --border-light: #f0f0f0;
            --border-focus: rgba(74, 85, 104, 0.1);
            
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 5px 15px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.2);
            --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.3);
            
            --accent-primary: #4a5568;
            --accent-secondary: #2d3748;
            --accent-gradient-start: #6366f1;
            --accent-gradient-end: #8b5cf6;
            
            --status-success-bg: #d4edda;
            --status-success-text: #155724;
            --status-success-border: #c3e6cb;
            
            --status-error-bg: #f8d7da;
            --status-error-text: #721c24;
            --status-error-border: #f5c6cb;
            
            --status-warning-bg: #fff3cd;
            --status-warning-text: #856404;
            --status-warning-border: #ffeaa7;
            
            --logo-filter: none;
            --upload-area-bg: rgba(0, 0, 0, 0.02);
            --modal-bg: rgba(0, 0, 0, 0.5);
            --debug-bg: #f8f9fa;
            --debug-border: #dee2e6;
            
            --gradient-overlay: none;
        }
        
        /* Dark theme */
        [data-theme="dark"] {
            --bg-primary: #0f0f0f;
            --bg-secondary: rgba(255, 255, 255, 0.03);
            --bg-tertiary: rgba(255, 255, 255, 0.02);
            --bg-hover: rgba(255, 255, 255, 0.04);
            --bg-gradient-start: rgba(120, 119, 198, 0.1);
            --bg-gradient-end: rgba(255, 119, 198, 0.05);
            
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-tertiary: #ffffff;
            --text-heading: #ffffff;
            --text-white: #ffffff;
            
            --border-primary: rgba(255, 255, 255, 0.2);
            --border-secondary: rgba(255, 255, 255, 0.2);
            --border-hover: rgba(99, 102, 241, 0.5);
            --border-light: rgba(255, 255, 255, 0.1);
            --border-focus: rgba(99, 102, 241, 0.3);
            
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 5px 15px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.3);
            
            --accent-primary: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            --accent-secondary: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            --accent-gradient-start: #6366f1;
            --accent-gradient-end: #8b5cf6;
            
            --status-success-bg: rgba(52, 211, 153, 0.1);
            --status-success-text: #34d399;
            --status-success-border: rgba(52, 211, 153, 0.3);
            
            --status-error-bg: rgba(248, 113, 113, 0.1);
            --status-error-text: #f87171;
            --status-error-border: rgba(248, 113, 113, 0.3);
            
            --status-warning-bg: rgba(251, 191, 36, 0.1);
            --status-warning-text: #fbbf24;
            --status-warning-border: rgba(251, 191, 36, 0.3);
            
            --logo-filter: brightness(0) invert(1);
            --upload-area-bg: rgba(255, 255, 255, 0.02);
            --modal-bg: rgba(0, 0, 0, 0.8);
            --debug-bg: rgba(255, 255, 255, 0.05);
            --debug-border: rgba(255, 255, 255, 0.1);
            
            --gradient-overlay: radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1), transparent 50%),
                              radial-gradient(circle at 80% 80%, rgba(255, 119, 198, 0.05), transparent 50%),
                              radial-gradient(circle at 40% 20%, rgba(119, 198, 255, 0.05), transparent 50%);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            position: relative;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* Global heading styles */
        h1, h2, h3, h4, h5, h6 {
            color: var(--text-primary);
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gradient-overlay);
            z-index: -1;
            transition: opacity 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: var(--text-heading);
            margin-bottom: 30px;
            padding: 30px 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        /* Theme Toggle Button */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-primary);
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            font-size: 14px;
            color: var(--text-primary);
            z-index: 10;
        }
        
        /* Intro Theme Toggle */
        .intro-theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            font-size: 14px;
            color: #333333;
            z-index: 10;
        }
        
        .intro-theme-toggle:hover {
            background: rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        [data-theme="dark"] .intro-theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
        }
        
        [data-theme="dark"] .intro-theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--border-hover);
        }
        
        .theme-icon {
            font-size: 18px;
            transition: transform 0.3s ease;
        }
        
        .theme-toggle:hover .theme-icon {
            transform: rotate(180deg);
        }
        
        /* Dark theme header shimmer effect */
        [data-theme="dark"] .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.03), transparent);
            transform: rotate(45deg);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
            color: var(--text-tertiary);
            position: relative;
            z-index: 1;
            transition: color 0.3s ease;
        }
        
        [data-theme="dark"] .header h1 {
            font-size: 3rem;
            font-weight: 300;
            letter-spacing: -1px;
        }

        .header-logo {
            max-height: 80px;
            width: auto;
            margin-bottom: 20px;
            opacity: 0.9;
            transition: all 0.3s ease;
            filter: var(--logo-filter);
        }

        .header-logo:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .upload-section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-lg);
            transition: all 0.5s ease;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
        }
        
        [data-theme="dark"] .upload-section {
            border-radius: 24px;
            padding: 40px;
        }

        .upload-section.hidden {
            display: none;
        }

        .upload-area {
            border: 2px dashed var(--border-secondary);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }
        
        [data-theme="dark"] .upload-area {
            border-radius: 16px;
            padding: 60px 40px;
        }
        
        .upload-area::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.5s ease;
            opacity: 0;
        }
        
        [data-theme="dark"] .upload-area::before {
            opacity: 1;
        }

        .upload-area:hover {
            border-color: var(--border-hover);
            background: var(--bg-hover);
            transform: translateY(-2px);
        }
        
        .upload-area:hover::before {
            transform: translate(-50%, -50%) scale(2);
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: var(--accent-secondary);
            color: var(--text-white);
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        
        [data-theme="dark"] .upload-btn {
            padding: 14px 32px;
            border-radius: 12px;
            font-weight: 500;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }
        
        .upload-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .upload-btn:hover::before {
            left: 100%;
        }

        .upload-btn:hover {
            background: #1a202c;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .progress-fill {
            height: 100%;
            background: #4a5568;
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            width: 0%;
        }

        .dashboard {
            display: none;
        }

        .nav-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
            overflow-x: auto;
            flex-wrap: nowrap;
            border: 1px solid var(--border-light);
        }

        .nav-tab {
            flex: 1;
            padding: 12px 15px;
            text-align: center;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            font-weight: 600;
            color: var(--text-secondary);
            min-width: 100px;
            font-size: 13px;

            /* Allow wrapping: */
            white-space: normal;
            word-wrap: break-word;
            /* Optionally constrain how wide each tab can grow so it actually wraps: */
            max-width: 180px;
            /* tweak this to taste */
        }


        .nav-tab:hover {
            background: var(--bg-hover);
            color: var(--text-tertiary);
        }

        .nav-tab.active {
            background: var(--accent-secondary);
            color: var(--text-white);
            box-shadow: var(--shadow-sm);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
            border: 1px solid var(--border-light);
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--text-tertiary);
            margin-bottom: 5px;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .chart-container {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--border-light);
        }
        
        .chart-container h3 {
            color: var(--text-primary);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }

        .table-container {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
            overflow-x: auto;
            border: 1px solid var(--border-light);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
            color: var(--text-primary);
        }

        th {
            background: var(--accent-secondary);
            color: var(--text-white);
            font-weight: 600;
        }
        
        [data-theme="dark"] th {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
        }

        tr:hover {
            background: var(--bg-hover);
            cursor: pointer;
        }
        
        [data-theme="dark"] tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .filters {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--border-light);
        }

        .filter-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            flex: 1;
            min-width: 150px;
        }

        .filter-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .filter-input {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .filter-input:focus {
            outline: none;
            border-color: #4a5568;
            box-shadow: 0 0 0 3px rgba(74, 85, 104, 0.1);
        }
        
        /* Dark mode styles for filter inputs and dropdowns */
        [data-theme="dark"] .filter-input {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .filter-input:focus {
            border-color: var(--accent-gradient-start);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        
        /* Style select dropdown options in dark mode */
        [data-theme="dark"] .filter-input option {
            background: #1a1a1a;
            color: #ffffff;
        }
        
        [data-theme="dark"] select.filter-input {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ffffff' d='M10.293 3.293L6 7.586 1.707 3.293A1 1 0 00.293 4.707l5 5a1 1 0 001.414 0l5-5a1 1 0 10-1.414-1.414z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px;
        }

        .filter-btn {
            background: var(--accent-primary);
            color: var(--text-white);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .debug-panel {
            background: var(--debug-bg);
            border: 1px solid var(--debug-border);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            color: var(--text-primary);
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 600;
        }

        .status-message.success {
            background: var(--status-success-bg);
            color: var(--status-success-text);
            border: 1px solid var(--status-success-border);
        }

        .status-message.error {
            background: var(--status-error-bg);
            color: var(--status-error-text);
            border: 1px solid var(--status-error-border);
        }

        .status-message.warning {
            background: var(--status-warning-bg);
            color: var(--status-warning-text);
            border: 1px solid var(--status-warning-border);
        }

        /* Enhanced Category Analysis Styles */
        .category-insights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .insight-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .insight-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .insight-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .insight-detail {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Pareto Analysis Styles */
        .pareto-insights {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        [data-theme="dark"] .pareto-insights {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%);
            border: 2px solid rgba(255, 193, 7, 0.3);
        }

        .pareto-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #856404;
            margin-bottom: 15px;
            text-align: center;
        }
        
        [data-theme="dark"] .pareto-title {
            color: #ffc107;
        }

        .pareto-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .pareto-metric {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
        }
        
        [data-theme="dark"] .pareto-metric {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 193, 7, 0.2);
        }

        .pareto-metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #d68910;
        }

        .pareto-metric-label {
            font-size: 0.9rem;
            color: #856404;
        }

        .pareto-interpretation {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .interpretation-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 10px;
        }

        .interpretation-text {
            color: #666;
            line-height: 1.5;
        }

        /* Subcategory Analysis Styles */
        .subcategory-summary {
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            border: 2px solid #28a745;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .subcategory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .subcategory-item {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        [data-theme="dark"] .subcategory-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(40, 167, 69, 0.2);
        }

        .subcategory-category {
            font-weight: bold;
            color: #155724;
            margin-bottom: 10px;
        }
        
        [data-theme="dark"] .subcategory-category {
            color: #28a745;
        }

        .subcategory-count {
            font-size: 1.5rem;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 5px;
        }
        
        [data-theme="dark"] .subcategory-count {
            color: #34d399;
        }

        .subcategory-detail {
            font-size: 0.8rem;
            color: #666;
        }
        
        [data-theme="dark"] .subcategory-detail {
            color: var(--text-secondary);
        }

        /* Enhanced SpendBand Analysis Styles */
        .spendband-insights {
            background: linear-gradient(135deg, #e8f4fd 0%, #d1ecf1 100%);
            border: 2px solid #17a2b8;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        [data-theme="dark"] .spendband-insights {
            background: linear-gradient(135deg, rgba(23, 162, 184, 0.1) 0%, rgba(23, 162, 184, 0.05) 100%);
            border: 2px solid rgba(23, 162, 184, 0.3);
        }

        .spendband-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .spendband-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .spendband-metric {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }

        .spendband-metric-value {
            font-size: 1.6rem;
            font-weight: bold;
            color: #17a2b8;
            margin-bottom: 5px;
        }

        .spendband-metric-label {
            font-size: 0.9rem;
            color: #0c5460;
            font-weight: 600;
        }

        .spendband-metric-detail {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .spendband-interpretation {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }

        .spendband-interpretation-title {
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .spendband-interpretation-text {
            color: #495057;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .spendband-recommendations {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 4px solid #17a2b8;
        }

        .spendband-recommendations-title {
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .spendband-recommendation-item {
            margin-bottom: 8px;
            padding-left: 15px;
            position: relative;
            color: #495057;
            font-size: 0.95rem;
        }

        .spendband-recommendation-item:before {
            content: "â†’";
            position: absolute;
            left: 0;
            color: #17a2b8;
            font-weight: bold;
        }

        .risk-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .risk-high {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .risk-medium {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .risk-low {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: block;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            margin: 2% auto;
            padding: 30px;
            border-radius: 15px;
            width: 95%;
            max-width: 1000px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            color: var(--text-primary);
            border: 1px solid var(--border-light);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
        }

        .clickable-row {
            transition: all 0.3s ease;
        }

        .clickable-row:hover {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%) !important;
            transform: translateX(5px);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.2);
        }
        
        /* Comprehensive Dark Mode Styles */
        [data-theme="dark"] .clickable-row:hover {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(99, 102, 241, 0.05) 100%) !important;
        }
        
        [data-theme="dark"] .spendband-title {
            color: #17a2b8;
        }
        
        [data-theme="dark"] .spendband-metric {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(23, 162, 184, 0.2);
        }
        
        [data-theme="dark"] .spendband-metric-value {
            color: #1cc6dd;
        }
        
        [data-theme="dark"] .spendband-metric-label {
            color: #17a2b8;
        }
        
        [data-theme="dark"] .spendband-interpretation {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(23, 162, 184, 0.2);
        }
        
        [data-theme="dark"] .spendband-interpretation-title,
        [data-theme="dark"] .spendband-recommendations-title {
            color: #17a2b8;
        }
        
        [data-theme="dark"] .spendband-interpretation-text,
        [data-theme="dark"] .spendband-recommendation-item {
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .spendband-recommendations {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
            border-left-color: #17a2b8;
        }
        
        [data-theme="dark"] .risk-high {
            background: rgba(220, 53, 69, 0.1);
            color: #f87171;
            border: 1px solid rgba(220, 53, 69, 0.3);
        }
        
        [data-theme="dark"] .risk-medium {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }
        
        [data-theme="dark"] .risk-low {
            background: rgba(40, 167, 69, 0.1);
            color: #34d399;
            border: 1px solid rgba(40, 167, 69, 0.3);
        }
        
        [data-theme="dark"] .seasonality-intelligence {
            background: linear-gradient(135deg, rgba(23, 162, 184, 0.1) 0%, rgba(23, 162, 184, 0.05) 100%);
            border: 2px solid rgba(23, 162, 184, 0.3);
        }
        
        [data-theme="dark"] .seasonality-title {
            color: #17a2b8;
        }
        
        [data-theme="dark"] .close-btn {
            color: #ccc;
        }
        
        [data-theme="dark"] .close-btn:hover {
            color: #fff;
        }
        
        /* Form control styles for dark mode */
        [data-theme="dark"] .form-control {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .form-control:focus {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--accent-gradient-start);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .form-control option {
            background: #1a1a1a;
            color: #ffffff;
        }
        
        /* Ensure all select elements in dark mode have proper styling */
        [data-theme="dark"] select {
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }
        
        [data-theme="dark"] select option {
            background-color: #1a1a1a;
            color: #ffffff;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .nav-tab {
                margin-bottom: 5px;
            }

            .filter-row {
                flex-direction: column;
            }

            .filter-group {
                min-width: 100%;
            }

            .category-insights,
            .pareto-metrics,
            .subcategory-grid,
            .spendband-metrics {
                grid-template-columns: 1fr;
            }
        }

        /* Seasonality Analysis Styles */
        .seasonality-intelligence {
            background: linear-gradient(135deg, #e8f4fd 0%, #d1ecf1 100%);
            border: 2px solid #17a2b8;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .seasonality-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .seasonality-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .seasonality-metric {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }

        .seasonality-metric-value {
            font-size: 1.6rem;
            font-weight: bold;
            color: #17a2b8;
            margin-bottom: 5px;
        }

        .seasonality-metric-label {
            font-size: 0.9rem;
            color: #0c5460;
            font-weight: 600;
        }

        .seasonality-metric-detail {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .seasonality-insights {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }

        .seasonality-insights-title {
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .seasonality-insights-text {
            color: #495057;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .opportunity-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .opportunity-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #17a2b8;
            transition: all 0.3s ease;
        }

        .opportunity-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .opportunity-title {
            font-weight: bold;
            color: #0c5460;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .opportunity-description {
            color: #495057;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .opportunity-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .opportunity-metric {
            text-align: center;
            padding: 8px;
            background: rgba(23, 162, 184, 0.1);
            border-radius: 8px;
        }

        .opportunity-metric-value {
            font-weight: bold;
            color: #17a2b8;
            font-size: 1.1rem;
        }

        .opportunity-metric-label {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .opportunity-recommendation {
            background: rgba(40, 167, 69, 0.1);
            border-left: 3px solid #28a745;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #155724;
        }

        .seasonality-chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .seasonality-ready {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            border: 2px dashed #17a2b8;
        }

        .seasonality-ready h3 {
            color: #0c5460;
            margin-bottom: 15px;
        }

        .seasonality-ready p {
            color: #6c757d;
            margin-bottom: 10px;
        }

        /* Tail Spend Analysis Styles */
        .tail-spend-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .tail-spend-title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tail-spend-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .tail-spend-metric {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .tail-spend-metric:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .tail-spend-metric-value {
            font-size: 28px;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 8px;
        }

        .tail-spend-metric-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .tail-segmentation-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .tail-segmentation-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tail-segment-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .tail-segment-card:hover {
            border-color: #667eea;
            transform: translateX(5px);
        }

        .tail-segment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .tail-segment-name {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .tail-segment-range {
            font-size: 14px;
            color: #6c757d;
            background: #f8f9fa;
            padding: 4px 12px;
            border-radius: 20px;
        }

        .tail-segment-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .tail-segment-stat {
            text-align: center;
        }

        .tail-segment-stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #667eea;
        }

        .tail-segment-stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }

        .savings-opportunities-container {
            background: #2d3748;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            color: white;
        }

        .savings-opportunities-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .savings-strategy-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .savings-strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .savings-strategy-name {
            font-size: 18px;
            font-weight: 600;
        }

        .savings-strategy-amount {
            font-size: 20px;
            font-weight: 700;
            color: #90EE90;
        }

        .savings-strategy-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .savings-strategy-detail {
            text-align: center;
        }

        .savings-strategy-detail-value {
            font-size: 16px;
            font-weight: 600;
        }

        .savings-strategy-detail-label {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
        }

        .pareto-analysis-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .pareto-chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
        }

        .vendor-risk-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .risk-score-high {
            color: #dc3545;
            font-weight: 600;
        }

        .risk-score-medium {
            color: #ffc107;
            font-weight: 600;
        }

        .risk-score-low {
            color: #28a745;
            font-weight: 600;
        }

        .implementation-timeline {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .timeline-phases {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .timeline-phase {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
        }

        .timeline-phase-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .timeline-phase-content {
            color: #6c757d;
            line-height: 1.6;
            font-size: 14px;
        }

        .timeline-phase-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 15px;
        }

        .timeline-phase-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .timeline-phase-description {
            font-size: 14px;
            color: #6c757d;
        }

        .timeline-phase-savings {
            font-weight: 600;
            color: #28a745;
            margin-left: auto;
        }

        /* Segment Definitions Styles */
        .segment-definitions {
            background: #4a5568;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            color: white;
        }

        .definition-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .definition-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .definition-icon {
            font-size: 20px;
        }

        .definition-text {
            font-size: 14px;
            line-height: 1.4;
        }

        /* Professional Footer Styles */
        .dashboard-footer {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            margin-top: 50px;
            padding: 30px 0 20px 0;
            border-top: 3px solid #667eea;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.1);
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            align-items: center;
        }

        .footer-left {
            text-align: left;
        }

        .footer-center {
            text-align: center;
        }

        .footer-right {
            text-align: right;
        }

        .footer-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .footer-icon {
            font-size: 24px;
        }

        .footer-brand {
            font-size: 18px;
            font-weight: 700;
            color: #ecf0f1;
        }

        .footer-tagline {
            font-size: 14px;
            color: #bdc3c7;
            font-style: italic;
        }

        .footer-version {
            font-size: 16px;
            font-weight: 600;
            color: #3498db;
            margin-bottom: 5px;
        }

        .footer-date {
            font-size: 14px;
            color: #95a5a6;
            margin-bottom: 5px;
        }

        .footer-powered {
            font-size: 14px;
            color: #ecf0f1;
            font-weight: 500;
        }

        .footer-stamp {
            display: inline-block;
        }

        .stamp-border {
            border: 3px solid #e74c3c;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: rotate(-15deg);
            background: rgba(231, 76, 60, 0.1);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.3);
        }

        .stamp-content {
            text-align: center;
            line-height: 1.1;
        }

        .stamp-text {
            font-size: 11px;
            font-weight: 900;
            color: #e74c3c;
            letter-spacing: 1px;
        }

        .stamp-subtext {
            font-size: 10px;
            font-weight: 700;
            color: #e74c3c;
            letter-spacing: 0.5px;
        }

        .stamp-year {
            font-size: 12px;
            font-weight: 900;
            color: #e74c3c;
            margin-top: 2px;
        }

        .footer-bottom {
            border-top: 1px solid #34495e;
            margin-top: 25px;
            padding-top: 15px;
            text-align: center;
        }

        .footer-copyright {
            font-size: 12px;
            color: #95a5a6;
            line-height: 1.5;
        }

        .footer-copyright a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer-copyright a:hover {
            color: #5dade2;
            text-decoration: underline;
        }

        /* Responsive Footer */
        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 20px;
                text-align: center;
            }

            .footer-left,
            .footer-right {
                text-align: center;
            }

            .footer-logo {
                justify-content: center;
            }

            .stamp-border {
                width: 70px;
                height: 70px;
            }

            .stamp-text {
                font-size: 10px;
            }

            .stamp-subtext {
                font-size: 9px;
            }

            .stamp-year {
                font-size: 11px;
            }
        }

        /* Vendor Consolidation Styles */
        .vendor-consolidation-section {
            margin-top: 30px;
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 1px solid #dee2e6;
        }

        .consolidation-header {
            margin-bottom: 25px;
        }

        .consolidation-header h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 24px;
            font-weight: 700;
        }

        .consolidation-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .consolidation-metric {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
        }

        .consolidation-metric .metric-value {
            display: block;
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .consolidation-metric .metric-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .consolidation-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid #e9ecef;
        }

        .consolidation-tab-btn {
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            color: #6c757d;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .consolidation-tab-btn:hover {
            color: #495057;
            background: rgba(102, 126, 234, 0.1);
        }

        .consolidation-tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .consolidation-tab-content {
            display: none;
        }

        .consolidation-tab-content.active {
            display: block;
        }

        .opportunities-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .opportunity-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #28a745;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .opportunity-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .opportunity-card.high {
            border-left-color: #dc3545;
        }

        .opportunity-card.medium {
            border-left-color: #ffc107;
        }

        .opportunity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .opportunity-header h4 {
            color: #2c3e50;
            margin: 0;
            font-size: 18px;
            font-weight: 700;
        }

        .strategic-value {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .strategic-value.high {
            background: #dc3545;
            color: white;
        }

        .strategic-value.medium {
            background: #ffc107;
            color: #212529;
        }

        .opportunity-metrics {
            margin-bottom: 15px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .metric-row .metric-label {
            color: #6c757d;
            font-weight: 500;
        }

        .metric-row .metric-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .metric-row .metric-value.savings {
            color: #28a745;
            font-weight: 700;
        }

        .category-breakdown {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .recommendation {
            font-size: 14px;
            color: #495057;
            line-height: 1.4;
        }

        .category-opportunities {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .category-opportunity-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-top: 4px solid #667eea;
        }

        .category-opportunity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-opportunity-header h4 {
            color: #2c3e50;
            margin: 0;
            font-size: 16px;
            font-weight: 700;
        }

        .savings-badge {
            background: #28a745;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }

        .metric-item {
            text-align: center;
        }

        .metric-item .metric-value {
            display: block;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .metric-item .metric-label {
            font-size: 12px;
            color: #6c757d;
            font-weight: 500;
        }

        .recommendation-text {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            color: #1565c0;
            border-left: 3px solid #2196f3;
        }

        .geographic-opportunities {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .geographic-opportunity-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #ff9800;
        }

        .geographic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .geographic-header h4 {
            color: #2c3e50;
            margin: 0;
            font-size: 16px;
            font-weight: 700;
        }

        .savings-potential {
            background: #ff9800;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .geographic-metrics {
            margin-bottom: 15px;
        }

        .metric-pair {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .metric-pair .metric-label {
            color: #6c757d;
            font-weight: 500;
        }

        .metric-pair .metric-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .geographic-recommendation {
            background: #fff3e0;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            color: #ef6c00;
            border-left: 3px solid #ff9800;
        }

        .no-opportunities {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
            background: white;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        /* Section Definition Styles */
        .section-definition {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 4px solid #2196f3;
        }

        .section-definition h4 {
            color: #1565c0;
            margin: 0 0 10px 0;
            font-size: 18px;
            font-weight: 700;
        }

        .section-definition p {
            color: #424242;
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Responsive design for consolidation components */
        @media (max-width: 768px) {
            .opportunities-grid {
                grid-template-columns: 1fr;
            }

            .category-opportunities {
                grid-template-columns: 1fr;
            }

            .geographic-opportunities {
                grid-template-columns: 1fr;
            }

            .consolidation-tabs {
                flex-direction: column;
            }

            .consolidation-tab-btn {
                text-align: left;
                border-bottom: none;
                border-left: 3px solid transparent;
            }

            .consolidation-tab-btn.active {
                border-left-color: #667eea;
                border-bottom-color: transparent;
            }
        }

        /* Predictive Analytics Styles */
        .predictive-container {
            padding: 20px;
        }

        .forecast-summary-container,
        .forecast-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            border-top: 4px solid #667eea;
        }

        .forecast-summary-title,
        .forecast-section-title {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .forecast-summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .forecast-summary-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .forecast-summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .forecast-summary-card.primary {
            background: #2d3748;
            color: white;
            border-left: 4px solid #fff;
        }

        .forecast-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .forecast-card-header h4 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
        }

        .forecast-period {
            font-size: 12px;
            opacity: 0.8;
            font-weight: 500;
        }

        .forecast-value {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .forecast-summary-card.primary .forecast-value {
            color: white;
        }

        .forecast-change,
        .forecast-subtitle,
        .forecast-growth,
        .forecast-decline {
            font-size: 14px;
            font-weight: 500;
        }

        .forecast-category {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .forecast-growth {
            color: #28a745;
        }

        .forecast-decline {
            color: #dc3545;
        }

        .forecast-range {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .forecast-chart-container {
            height: 400px;
            margin-bottom: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .forecast-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .forecast-metric {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 3px solid #667eea;
        }

        .forecast-metric .metric-label {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .forecast-metric .metric-value {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
        }

        .forecast-metric .metric-value.growth {
            color: #28a745;
        }

        .forecast-metric .metric-value.confidence {
            color: #17a2b8;
        }

        .forecast-metric .metric-value.positive {
            color: #28a745;
        }

        .forecast-metric .metric-value.negative {
            color: #dc3545;
        }

        .category-forecasts-grid,
        .supplier-forecasts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }

        .category-forecast-card,
        .supplier-forecast-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-top: 4px solid #28a745;
            transition: transform 0.2s ease;
        }

        .category-forecast-card:hover,
        .supplier-forecast-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .category-forecast-header,
        .supplier-forecast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-forecast-header h4,
        .supplier-forecast-header h4 {
            margin: 0;
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
        }

        .confidence-badge {
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .risk-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .risk-badge.low {
            background: #d4edda;
            color: #155724;
        }

        .risk-badge.medium {
            background: #fff3cd;
            color: #856404;
        }

        .risk-badge.high {
            background: #f8d7da;
            color: #721c24;
        }

        .category-forecast-metrics,
        .supplier-forecast-metrics {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .forecast-metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .forecast-metric-row .metric-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .forecast-metric-row .metric-value {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .forecast-metric-row .metric-value.positive {
            color: #28a745;
        }

        .forecast-metric-row .metric-value.negative {
            color: #dc3545;
        }

        .scenario-analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .scenario-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .scenario-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .scenario-card.conservative {
            border-top: 4px solid #6c757d;
        }

        .scenario-card.baseline {
            border-top: 4px solid #17a2b8;
        }

        .scenario-card.optimistic {
            border-top: 4px solid #28a745;
        }

        .scenario-card.challenging {
            border-top: 4px solid #dc3545;
        }

        .scenario-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .scenario-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
        }

        .risk-indicator {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .risk-indicator.low {
            background: #d4edda;
            color: #155724;
        }

        .risk-indicator.medium {
            background: #fff3cd;
            color: #856404;
        }

        .risk-indicator.high {
            background: #f8d7da;
            color: #721c24;
        }

        .scenario-description {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .scenario-metrics {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .scenario-metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .scenario-metric-row.primary .metric-value {
            font-size: 18px;
            font-weight: 700;
        }

        .scenario-metric-row .metric-label {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .scenario-metric-row .metric-value {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .scenario-metric-row .metric-value.positive {
            color: #28a745;
        }

        .scenario-metric-row .metric-value.negative {
            color: #dc3545;
        }

        .accuracy-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .accuracy-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border-top: 4px solid #667eea;
            transition: transform 0.2s ease;
        }

        .accuracy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .accuracy-header h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .accuracy-value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .accuracy-value.quality-excellent {
            color: #28a745;
        }

        .accuracy-value.quality-good {
            color: #17a2b8;
        }

        .accuracy-value.quality-fair {
            color: #ffc107;
        }

        .accuracy-value.quality-poor {
            color: #dc3545;
        }

        .accuracy-subtitle {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .forecast-methodology {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #667eea;
        }

        .forecast-methodology h4 {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
        }

        .methodology-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .methodology-item {
            font-size: 14px;
            line-height: 1.4;
            color: #495057;
        }

        .no-forecast-data {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        /* Mobile Responsiveness for Predictive Analytics */
        @media (max-width: 768px) {

            .forecast-summary-grid,
            .category-forecasts-grid,
            .supplier-forecasts-grid,
            .scenario-analysis-grid,
            .accuracy-metrics-grid {
                grid-template-columns: 1fr;
            }

            .forecast-chart-container {
                height: 300px;
            }

            .forecast-value {
                font-size: 24px;
            }

            .scenario-header,
            .category-forecast-header,
            .supplier-forecast-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }

        /* Maverick Spend & Compliance Styles */
        .maverick-container {
            padding: 20px;
        }

        .compliance-overview-container,
        .compliance-score-container,
        .alert-categories-container,
        .recommendations-container,
        .risk-matrix-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .compliance-overview-title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            padding: 15px;
            background: #dc3545;
            color: white;
            border-radius: 8px;
        }

        .compliance-score-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .compliance-score-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .compliance-score-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .compliance-score-value {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .compliance-score-label {
            font-size: 14px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .compliance-level-excellent {
            color: #28a745;
            border-color: #28a745;
        }

        .compliance-level-good {
            color: #17a2b8;
            border-color: #17a2b8;
        }

        .compliance-level-fair {
            color: #ffc107;
            border-color: #ffc107;
        }

        .compliance-level-poor {
            color: #dc3545;
            border-color: #dc3545;
        }

        .alert-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 15px;
        }

        .alert-tab-btn {
            padding: 12px 20px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #495057;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .alert-tab-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .alert-tab-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .alert-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .alert-tab-content.active {
            display: block;
        }

        .alert-card {
            background: #fff;
            border-left: 4px solid #dc3545;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .alert-card:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .alert-card.risk-high {
            border-left-color: #dc3545;
        }

        .alert-card.risk-medium {
            border-left-color: #ffc107;
        }

        .alert-card.risk-low {
            border-left-color: #28a745;
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .alert-title {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
        }

        .alert-risk-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .risk-high {
            background: #dc3545;
            color: white;
        }

        .risk-medium {
            background: #ffc107;
            color: #212529;
        }

        .risk-low {
            background: #28a745;
            color: white;
        }

        .alert-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .alert-detail {
            text-align: center;
        }

        .alert-detail-value {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .alert-detail-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .alert-recommendation {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            border-left: 3px solid #007bff;
            font-style: italic;
            color: #495057;
        }

        .recommendation-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .recommendation-card:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .recommendation-title {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
        }

        .priority-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .priority-high {
            background: #dc3545;
            color: white;
        }

        .priority-medium {
            background: #ffc107;
            color: #212529;
        }

        .priority-low {
            background: #28a745;
            color: white;
        }

        .recommendation-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .recommendation-meta-item {
            text-align: center;
        }

        .recommendation-meta-value {
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .recommendation-meta-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .risk-matrix {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .risk-matrix-item {
            background: white;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
            text-align: center;
            transition: all 0.3s ease;
        }

        .risk-matrix-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .risk-matrix-supplier {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .risk-matrix-score {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .risk-matrix-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin-top: 15px;
        }

        .risk-matrix-category {
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: #495057;
        }

        /* Filter Customizer Modal */
        .filter-customizer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-bg);
            z-index: 9999;
        }
        
        .filter-customizer-content {
            position: relative;
            background: var(--bg-secondary);
            margin: 50px auto;
            padding: 30px;
            width: 90%;
            max-width: 600px;
            border-radius: 15px;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--border-light);
        }
        
        /* Filter Customizer Styles */
        .field-item {
            padding: 10px 15px;
            margin: 5px 0;
            background: var(--bg-tertiary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-primary);
        }

        .field-item:hover {
            background: var(--bg-hover);
            border-color: var(--border-primary);
        }

        .field-item.selected {
            background: var(--bg-hover);
            border-color: var(--accent-gradient-start);
        }

        .field-item .field-name {
            font-weight: 500;
            color: var(--text-tertiary);
        }

        .field-item .field-count {
            font-size: 0.85rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* Mobile Responsiveness for Maverick Spend */
        @media (max-width: 768px) {

            .compliance-score-grid,
            .alert-details,
            .recommendation-meta,
            .risk-matrix {
                grid-template-columns: 1fr;
            }

            .alert-tabs {
                flex-direction: column;
            }

            .alert-header,
            .recommendation-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .maverick-container {
                padding: 15px;
            }
        }

        /* Contract Optimization Intelligence Styles */
        .contracts-container {
            padding: 20px;
        }

        .contracts-overview-container {
            background: linear-gradient(135deg, #6f42c1 0%, #8e44ad 100%);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .contracts-overview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            z-index: 1;
        }

        .contracts-overview-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 20px;
            position: relative;
            z-index: 2;
        }

        .contracts-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #6f42c1;
        }

        .contracts-section-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #6f42c1;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f8f9fa;
        }

        .portfolio-overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            position: relative;
            z-index: 2;
        }

        .portfolio-metric-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .portfolio-metric-value {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .portfolio-metric-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .renewal-pipeline-grid {
            display: grid;
            gap: 15px;
        }

        .renewal-item {
            background: #f9faf8;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #6c757d;
            transition: all 0.3s ease;
        }

        .renewal-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .renewal-item.priority-high {
            border-left-color: #dc3545;
            background: #93a6e2;
        }

        .renewal-item.priority-medium {
            border-left-color: #ffc107;
            background: #fffbf0;
        }

        .renewal-item.priority-low {
            border-left-color: #28a745;
            background: #f8fff8;
        }

        .renewal-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 10px;
        }

        .renewal-supplier {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .renewal-priority {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .renewal-priority.high {
            background: #dc3545;
            color: white;
        }

        .renewal-priority.medium {
            background: #ffc107;
            color: #212529;
        }

        .renewal-priority.low {
            background: #28a745;
            color: white;
        }

        .renewal-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .renewal-detail {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .renewal-detail strong {
            color: #495057;
        }

        .performance-metrics-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .performance-score-card {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .performance-score-value {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .performance-score-label {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .performance-breakdown {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .performance-breakdown-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #495057;
        }

        .performance-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .performance-category:last-child {
            border-bottom: none;
        }

        .performance-category-name {
            font-weight: 500;
        }

        .performance-category-score {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .performance-category-score.excellent {
            background: #d4edda;
            color: #155724;
        }

        .performance-category-score.good {
            background: #d1ecf1;
            color: #0c5460;
        }

        .performance-category-score.fair {
            background: #fff3cd;
            color: #856404;
        }

        .performance-category-score.poor {
            background: #f8d7da;
            color: #721c24;
        }

        .volume-commitments-grid {
            display: grid;
            gap: 15px;
        }

        .volume-commitment-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #6c757d;
        }

        .volume-commitment-item.compliant {
            border-left-color: #28a745;
            background: #f8fff8;
        }

        .volume-commitment-item.under-performing {
            border-left-color: #ffc107;
            background: #fffbf0;
        }

        .volume-commitment-item.over-performing {
            border-left-color: #17a2b8;
            background: #f0f9ff;
        }

        .volume-commitment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .volume-commitment-supplier {
            font-weight: 600;
        }

        .volume-commitment-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .volume-commitment-status.compliant {
            background: #28a745;
            color: white;
        }

        .volume-commitment-status.under-performing {
            background: #ffc107;
            color: #212529;
        }

        .volume-commitment-status.over-performing {
            background: #17a2b8;
            color: white;
        }

        .optimization-opportunities-grid {
            display: grid;
            gap: 15px;
        }

        .optimization-opportunity {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #6f42c1;
            transition: all 0.3s ease;
        }

        .optimization-opportunity:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .optimization-opportunity.priority-high {
            border-left-color: #dc3545;
            background: #fff5f5;
        }

        .optimization-opportunity.priority-medium {
            border-left-color: #ffc107;
            background: #fffbf0;
        }

        .optimization-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .optimization-type {
            font-weight: 600;
            font-size: 1.1rem;
            color: #6f42c1;
        }

        .optimization-savings {
            font-weight: 700;
            font-size: 1.2rem;
            color: #28a745;
        }

        .optimization-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .optimization-detail {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .optimization-detail strong {
            color: #495057;
        }

        .risk-assessment-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .risk-score-card {
            background: linear-gradient(135deg, #dc3545 0%, #e74c3c 100%);
            color: white;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .risk-score-value {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .risk-score-label {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .risk-factors {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .risk-factors-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #495057;
        }

        .risk-factor {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .risk-factor:last-child {
            border-bottom: none;
        }

        .risk-factor-name {
            font-weight: 500;
        }

        .risk-factor-level {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .risk-factor-level.high {
            background: #dc3545;
            color: white;
        }

        .risk-factor-level.medium {
            background: #ffc107;
            color: #212529;
        }

        .risk-factor-level.low {
            background: #28a745;
            color: white;
        }

        .recommendations-grid {
            display: grid;
            gap: 15px;
        }

        .recommendation-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #6f42c1;
            transition: all 0.3s ease;
        }

        .recommendation-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .recommendation-card.priority-high {
            border-left-color: #dc3545;
            background: #fff5f5;
        }

        .recommendation-card.priority-medium {
            border-left-color: #ffc107;
            background: #fffbf0;
        }

        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .recommendation-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: #495057;
        }

        .recommendation-priority {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .recommendation-priority.high {
            background: #dc3545;
            color: white;
        }

        .recommendation-priority.medium {
            background: #ffc107;
            color: #212529;
        }

        .recommendation-priority.low {
            background: #28a745;
            color: white;
        }

        .recommendation-description {
            color: #6c757d;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .recommendation-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .recommendation-meta-item {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .recommendation-meta-item strong {
            color: #495057;
        }

        /* Mobile Responsiveness for Contract Optimization */
        @media (max-width: 768px) {

            .portfolio-overview-grid,
            .performance-metrics-grid,
            .risk-assessment-grid {
                grid-template-columns: 1fr;
            }

            .renewal-header,
            .volume-commitment-header,
            .optimization-header,
            .recommendation-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .contracts-container {
                padding: 15px;
            }

            .renewal-details,
            .optimization-details,
            .recommendation-meta {
                grid-template-columns: 1fr;
            }
        }

        /* AI Insights Panel Styles */
        .insights-panel {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-light);
        }
        
        /* View Toggle Button */
        .view-toggle-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .view-toggle-btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
            transform: translateY(-1px);
        }
        
        /* Insights Tabs */
        .insights-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid var(--border-light);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        
        .insight-tab-btn {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .insight-tab-btn:hover {
            color: var(--text-primary);
            background: var(--bg-hover);
        }
        
        .insight-tab-btn.active {
            color: var(--text-primary);
            border-bottom-color: var(--accent-gradient-start);
            background: var(--bg-tertiary);
        }
        
        .tab-count {
            background: var(--bg-hover);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 700;
        }
        
        .insight-tab-btn.active .tab-count {
            background: var(--accent-gradient-start);
            color: white;
        }
        
        /* Tab Content */
        .insight-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .insight-tab-content.active {
            display: block;
        }
        
        /* Insight Filters */
        .insight-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        /* Tab Header */
        .tab-header {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent-gradient-start);
        }
        
        .tab-header h3 {
            margin: 0 0 10px 0;
            color: var(--text-primary);
            font-size: 1.4rem;
        }
        
        .tab-header p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .insights-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .insights-header h2 {
            font-size: 1.5rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0;
        }

        .insights-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .refresh-btn {
            background: var(--accent-primary);
            color: var(--text-white);
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .refresh-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .insight-filter {
            padding: 8px 12px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .insight-filter:focus {
            outline: none;
            border-color: var(--border-hover);
        }
        
        /* Dark mode styles for insight filters */
        [data-theme="dark"] .insight-filter {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .insight-filter:focus {
            border-color: var(--accent-gradient-start);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        
        [data-theme="dark"] .insight-filter option {
            background: #1a1a1a;
            color: #ffffff;
        }

        .insights-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .summary-card {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border-light);
            transition: all 0.3s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .summary-card.high-priority {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        [data-theme="dark"] .summary-card.high-priority {
            background: rgba(220, 53, 69, 0.2);
        }

        .summary-card.savings {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        [data-theme="dark"] .summary-card.savings {
            background: rgba(40, 167, 69, 0.2);
        }

        .summary-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .summary-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Smart Search Styles */
        .nlq-container {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-light);
        }
        
        .nlq-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .nlq-icon {
            font-size: 1.5rem;
        }
        
        .nlq-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-heading);
        }
        
        .nlq-input-wrapper {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .nlq-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid var(--border-light);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .nlq-input:focus {
            outline: none;
            border-color: var(--accent-gradient-start);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        
        .nlq-button {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--accent-gradient-start) 0%, var(--accent-gradient-end) 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nlq-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3);
        }
        
        .nlq-suggestions {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }
        
        .nlq-suggestion-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-right: 4px;
        }
        
        .nlq-suggestion {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .nlq-suggestion:hover {
            background: var(--bg-hover);
            border-color: var(--accent-gradient-start);
            color: var(--accent-gradient-start);
        }
        
        /* AI Assistant Styles */
        .ai-assistant-container {
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
            border-radius: 16px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid var(--border-light);
            box-shadow: var(--shadow-sm);
        }
        
        .ai-assistant-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .ai-assistant-icon {
            font-size: 1.8rem;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .ai-assistant-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-heading);
            flex: 1;
        }
        
        .ai-config-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .ai-config-btn:hover {
            background: var(--bg-hover);
            transform: rotate(45deg);
        }
        
        .ai-assistant-input-wrapper {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: flex-end;
        }
        
        .ai-assistant-input {
            flex: 1;
            padding: 15px;
            border: 2px solid var(--border-light);
            border-radius: 12px;
            font-size: 1rem;
            background: var(--bg-secondary);
            color: var(--text-primary);
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
            transition: all 0.3s ease;
        }
        
        .ai-assistant-input:focus {
            outline: none;
            border-color: var(--accent-gradient-start);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
        }
        
        .ai-assistant-button {
            padding: 15px 30px;
            background: linear-gradient(135deg, var(--accent-gradient-start) 0%, var(--accent-gradient-end) 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            justify-content: center;
        }
        
        .ai-assistant-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }
        
        .ai-assistant-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .ai-assistant-suggestions {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .ai-suggestion-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        .ai-suggestion {
            padding: 8px 16px;
            background: var(--bg-secondary);
            border: 2px solid transparent;
            border-radius: 25px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .ai-suggestion:hover {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border-color: var(--accent-gradient-start);
            transform: translateY(-2px);
        }
        
        .ai-assistant-response {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid var(--border-light);
            animation: fadeIn 0.5s ease;
        }
        
        .ai-response-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .ai-response-content {
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 1rem;
        }
        
        .ai-response-content h3 {
            color: var(--text-heading);
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
        }
        
        .ai-response-content ul {
            margin: 10px 0;
            padding-left: 25px;
        }
        
        .ai-response-content li {
            margin: 8px 0;
        }
        
        .ai-response-content .highlight {
            background: rgba(99, 102, 241, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .ai-loading {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-secondary);
        }
        
        .ai-loading-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid var(--border-light);
            border-top-color: var(--accent-gradient-start);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Insight Cards */
        .insights-list {
            max-height: 600px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .insight-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid;
            transition: all 0.3s ease;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .insight-card.anomaly {
            border-left-color: #dc3545;
        }

        .insight-card.trend {
            border-left-color: #17a2b8;
        }

        .insight-card.savings {
            border-left-color: #28a745;
        }

        .insight-card.pattern {
            border-left-color: #6f42c1;
        }

        .insight-card:hover {
            transform: translateX(5px);
            box-shadow: var(--shadow-md);
        }

        .insight-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .insight-icon {
            font-size: 1.5rem;
        }

        .insight-title {
            flex: 1;
            font-size: 1.1rem;
            color: var(--text-primary);
            font-weight: 600;
        }

        .insight-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .insight-badge.high {
            background: #dc3545;
            color: white;
        }

        .insight-badge.medium {
            background: #ffc107;
            color: #212529;
        }

        .insight-badge.low {
            background: #28a745;
            color: white;
        }

        .insight-summary {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .insight-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .metric-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: capitalize;
        }

        .metric-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .insight-actions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-light);
        }

        .insight-actions h4 {
            font-size: 0.95rem;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .insight-actions ul {
            list-style: none;
            padding: 0;
        }

        .action-item {
            padding: 8px 0;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-priority {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .action-priority.immediate {
            background: #dc3545;
            color: white;
        }

        .action-priority.high {
            background: #fd7e14;
            color: white;
        }

        .action-priority.medium {
            background: #ffc107;
            color: #212529;
        }

        .action-owner {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        .insight-footer {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .insight-footer button {
            padding: 6px 16px;
            border: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .insight-footer button:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
        }

        .insights-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-light);
            flex-wrap: wrap;
            gap: 10px;
        }

        .export-insights-btn, .configure-btn {
            background: var(--accent-primary);
            color: var(--text-white);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .export-insights-btn:hover, .configure-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .no-insights {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .no-insights p {
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .insights-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            color: var(--text-secondary);
        }

        .insights-loading .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border-light);
            border-top-color: var(--accent-gradient-start);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Intro Section Styles */
        .intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            z-index: 10000;
            overflow-y: auto;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        .intro-overlay::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gradient-overlay);
            z-index: -1;
            pointer-events: none;
        }

        .intro-overlay.hidden {
            opacity: 0;
            transform: translateY(-100%);
            pointer-events: none;
        }

        .intro-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px 100px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .intro-header {
            text-align: center;
            margin-bottom: 60px;
            animation: fadeInUp 0.8s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .intro-logo {
            max-height: 100px;
            margin-bottom: 30px;
            opacity: 0.9;
            filter: var(--logo-filter);
        }

        .intro-title {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -2px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #2d3748, #4a5568);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        [data-theme="dark"] .intro-title {
            background: linear-gradient(135deg, #e2e8f0, #cbd5e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .intro-subtitle {
            font-size: 1.5rem;
            color: var(--text-secondary);
            font-weight: 300;
            margin-bottom: 30px;
        }

        .intro-badge {
            display: inline-block;
            background: linear-gradient(135deg, #4299e1, #667eea);
            color: white;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
        }

        .intro-content {
            display: grid;
            gap: 40px;
            animation: fadeInUp 0.8s ease 0.2s both;
        }

        .intro-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            padding: 40px;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
        }

        .intro-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        }

        .intro-section h2 {
            font-size: 2rem;
            margin-bottom: 25px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .intro-overview {
            font-size: 1.1rem;
            line-height: 1.8;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 25px;
            border-radius: 15px;
            border-left: 4px solid #4299e1;
        }

        .intro-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .intro-feature {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 15px;
            padding: 25px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .intro-feature::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #4299e1, #667eea);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .intro-feature:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .intro-feature:hover::before {
            transform: translateX(0);
        }

        .intro-feature-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #4299e1, #667eea);
            color: white;
            border-radius: 50%;
            font-weight: 600;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .intro-feature h4 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #2d3748;
        }

        .intro-feature ul {
            list-style: none;
            padding: 0;
        }

        .intro-feature li {
            padding: 5px 0;
            color: var(--text-secondary);
            padding-left: 20px;
            position: relative;
        }

        .intro-feature li::before {
            content: 'â†’';
            position: absolute;
            left: 0;
            color: #4299e1;
        }
        
        [data-theme="dark"] .intro-feature li::before {
            color: #63b3ed;
        }

        .intro-capabilities {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
        }

        .intro-capability {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 15px;
            padding: 25px;
            transition: all 0.3s ease;
        }

        .intro-capability:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .intro-capability h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .intro-capability ul {
            list-style: none;
            padding: 0;
        }

        .intro-capability li {
            padding: 6px 0;
            color: var(--text-secondary);
            padding-left: 25px;
            position: relative;
        }

        .intro-capability li::before {
            content: 'âœ“';
            position: absolute;
            left: 0;
            color: #48bb78;
            font-weight: bold;
        }
        
        [data-theme="dark"] .intro-capability li::before {
            color: #68d391;
        }

        .intro-tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .intro-tech-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            padding: 10px 20px;
            border-radius: 25px;
            color: var(--text-primary);
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .intro-tech-item:hover {
            background: var(--bg-hover);
            transform: scale(1.05);
        }

        .intro-cta {
            text-align: center;
            margin-top: 60px;
            margin-bottom: 40px;
            animation: fadeInUp 0.8s ease 0.4s both;
        }

        .intro-skip-btn {
            background: linear-gradient(135deg, #4299e1, #667eea);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 1.2rem;
            font-weight: 500;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(66, 153, 225, 0.3);
            margin: 0 10px;
        }

        .intro-skip-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 30px rgba(66, 153, 225, 0.4);
        }

        .intro-skip-btn.secondary {
            background: transparent;
            border: 2px solid var(--border-secondary);
            color: var(--text-secondary);
            box-shadow: none;
        }

        .intro-skip-btn.secondary:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
        }

        .intro-remember {
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .intro-remember input {
            margin-right: 8px;
            cursor: pointer;
        }

        .intro-remember label {
            cursor: pointer;
        }

        /* Animations for feature cards */
        .intro-feature:nth-child(1) {
            animation-delay: 0.1s;
        }

        .intro-feature:nth-child(2) {
            animation-delay: 0.2s;
        }

        .intro-feature:nth-child(3) {
            animation-delay: 0.3s;
        }

        .intro-feature:nth-child(4) {
            animation-delay: 0.4s;
        }

        .intro-feature:nth-child(5) {
            animation-delay: 0.5s;
        }

        .intro-feature:nth-child(6) {
            animation-delay: 0.6s;
        }

        .intro-feature:nth-child(7) {
            animation-delay: 0.7s;
        }

        .intro-feature:nth-child(8) {
            animation-delay: 0.8s;
        }

        .intro-feature:nth-child(9) {
            animation-delay: 0.9s;
        }

        .intro-feature {
            animation: fadeInUp 0.6s ease both;
        }

        /* What's New Button */
        .whats-new-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #4299e1, #667eea);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(66, 153, 225, 0.3);
            z-index: 10;
        }

        .whats-new-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.4);
        }

        /* Generate Report Button */
        .generate-report-btn {
            position: absolute;
            top: 20px;
            right: 180px; /* Positioned to the left of theme toggle */
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(40, 167, 69, 0.3);
            z-index: 10;
        }

        .generate-report-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #20c997, #28a745);
        }
        
        [data-theme="dark"] .generate-report-btn {
            background: linear-gradient(135deg, #20c997, #28a745);
            box-shadow: 0 2px 10px rgba(32, 201, 151, 0.4);
        }
        
        [data-theme="dark"] .generate-report-btn:hover {
            box-shadow: 0 4px 15px rgba(32, 201, 151, 0.6);
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .intro-title {
                font-size: 2.5rem;
            }

            .intro-subtitle {
                font-size: 1.2rem;
            }

            .intro-capabilities {
                grid-template-columns: 1fr;
            }

            .intro-section {
                padding: 25px;
            }

            .whats-new-btn {
                position: static;
                margin-bottom: 20px;
            }
            
            .generate-report-btn {
                position: static;
                margin-top: 10px;
                margin-bottom: 20px;
                display: block;
                width: 100%;
                max-width: 300px;
                margin-left: auto;
                margin-right: auto;
            }
        }
    </style>
</head>

<body>
    <!-- Intro Overlay -->
    <div class="intro-overlay" id="introOverlay">
        <button class="intro-theme-toggle" onclick="toggleTheme()" title="Toggle theme">
            <span class="theme-icon" id="introThemeIcon">ðŸŒ™</span>
            <span id="introThemeName">Dark</span>
        </button>
        <div class="intro-container">
            <div class="intro-header">
                <img src="vtx_logo_full_black_large.png" alt="VTX Logo" class="intro-logo">
                <h1 class="intro-title">VSTX Analytics Dashboard</h1>
                <p class="intro-subtitle">Enterprise Procurement Intelligence Platform</p>
                <div class="intro-badge">Welcome to the Future of Procurement Analytics</div>
            </div>

            <div class="intro-content">
                <!-- Strategic Overview -->
                <div class="intro-section">
                    <h2><span style="font-size: 1.5rem;">ðŸŽ¯</span> Strategic Overview</h2>
                    <div class="intro-overview">
                        The VSTX Analytics Dashboard represents a cutting-edge procurement analytics platform that
                        transforms raw spending data into actionable strategic insights. By leveraging advanced
                        analytics and machine learning algorithms, this comprehensive tool empowers procurement
                        professionals to identify cost-saving opportunities, mitigate risks, and drive data-driven
                        decision-making across the enterprise.
                    </div>
                </div>

                <!-- Core Analytics Modules -->
                <div class="intro-section">
                    <h2><span style="font-size: 1.5rem;">ðŸ’Ž</span> Core Analytics Modules</h2>
                    <div class="intro-features">
                        <div class="intro-feature">
                            <div class="intro-feature-number">1</div>
                            <h4>Executive Overview</h4>
                            <ul>
                                <li>Real-time KPI dashboards</li>
                                <li>Spend trend visualization</li>
                                <li>Category performance metrics</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">2</div>
                            <h4>Category Intelligence</h4>
                            <ul>
                                <li>Multi-level category analysis</li>
                                <li>Subcategory drill-down</li>
                                <li>Risk concentration assessment</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">3</div>
                            <h4>Supplier Analytics</h4>
                            <ul>
                                <li>Performance benchmarking</li>
                                <li>Spend distribution analysis</li>
                                <li>Supplier risk profiling</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">4</div>
                            <h4>Pareto Analysis</h4>
                            <ul>
                                <li>80/20 spend concentration</li>
                                <li>Strategic supplier identification</li>
                                <li>Optimization opportunities</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">5</div>
                            <h4>Spend Stratification</h4>
                            <ul>
                                <li>Volume-based segmentation</li>
                                <li>Sourcing strategy alignment</li>
                                <li>Opportunity identification</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">6</div>
                            <h4>Seasonality Intelligence</h4>
                            <ul>
                                <li>Pattern recognition</li>
                                <li>Demand forecasting</li>
                                <li>Budget optimization</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">7</div>
                            <h4>Tail Spend Analysis</h4>
                            <ul>
                                <li>Consolidation opportunities</li>
                                <li>15% average savings potential</li>
                                <li>Implementation roadmap</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">8</div>
                            <h4>Predictive Analytics</h4>
                            <ul>
                                <li>12-month spend forecasting</li>
                                <li>Scenario planning</li>
                                <li>Risk prediction</li>
                            </ul>
                        </div>

                        <div class="intro-feature">
                            <div class="intro-feature-number">9</div>
                            <h4>Compliance Monitoring</h4>
                            <ul>
                                <li>Contract adherence tracking</li>
                                <li>Maverick spend detection</li>
                                <li>Policy enforcement</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Platform Capabilities -->
                <div class="intro-section">
                    <h2><span style="font-size: 1.5rem;">âš¡</span> Platform Capabilities</h2>
                    <div class="intro-capabilities">
                        <div class="intro-capability">
                            <h3>ðŸ” Advanced Analytics</h3>
                            <ul>
                                <li>AI-powered risk assessment</li>
                                <li>Automated savings identification</li>
                                <li>Concentration risk analysis</li>
                                <li>Supplier dependency metrics</li>
                                <li>Seasonal trend detection</li>
                            </ul>
                        </div>

                        <div class="intro-capability">
                            <h3>ðŸ“Š Data Visualization</h3>
                            <ul>
                                <li>Interactive dashboards</li>
                                <li>Real-time data updates</li>
                                <li>Drill-down capabilities</li>
                                <li>Customizable reports</li>
                                <li>Mobile-responsive design</li>
                            </ul>
                        </div>

                        <div class="intro-capability">
                            <h3>ðŸŽ›ï¸ User Experience</h3>
                            <ul>
                                <li>Intuitive navigation</li>
                                <li>Advanced filtering options</li>
                                <li>Drag-and-drop file upload</li>
                                <li>Progress tracking</li>
                                <li>Export capabilities</li>
                            </ul>
                        </div>

                        <div class="intro-capability">
                            <h3>ðŸ” Enterprise Features</h3>
                            <ul>
                                <li>Client-side data processing</li>
                                <li>Data privacy compliance</li>
                                <li>Scalable architecture</li>
                                <li>Cross-platform compatibility</li>
                                <li>Debug and troubleshooting tools</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Call to Action -->
            <div class="intro-cta">
                <button class="intro-skip-btn" onclick="startDashboard()">Get Started</button>
                <button class="intro-skip-btn secondary" onclick="skipIntro()">Skip Introduction</button>
                <div class="intro-remember">
                    <label>
                        <input type="checkbox" id="rememberChoice" onchange="updatePreference()">
                        Don't show this again
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                <span class="theme-icon" id="themeIcon">ðŸŒ™</span>
                <span id="themeName">Dark</span>
            </button>
            <button class="whats-new-btn" onclick="showIntroAgain()">âœ¨ What's New</button>
            <button class="generate-report-btn" onclick="generatePDFReport()" title="Generate PDF Report" style="display: none;">
                ðŸ“„ Generate Report
            </button>
            <img src="vtx_logo_full_black_large.png" alt="VTX Logo" class="header-logo">
            <h1>VSTX Analytics Dashboard</h1>
            <p>Upload your procurement data to unlock powerful insights and analytics</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <h3>ðŸ“ Upload Your Data</h3>
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div style="font-size: 3rem; margin-bottom: 15px;">ðŸ“¤</div>
                <p style="font-size: 1.2rem; margin-bottom: 10px;">Drag and drop your file here or click to browse</p>
                <p style="color: #666;">Supports CSV and Excel files (.csv, .xlsx, .xls)</p>
                <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls">
                <button class="upload-btn" style="margin-top: 15px;">Choose File</button>
                <div id="fileName" style="margin-top: 10px; font-weight: 600;"></div>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div id="progressText" style="text-align: center; margin-top: 10px;"></div>
            </div>

            <div id="statusMessage"></div>

            <button class="upload-btn" id="processBtn" onclick="processFile()" style="display: none; margin-top: 15px;">
                Process Data
            </button>

            <div id="debugPanel" class="debug-panel"></div>
        </div>

        <!-- Dashboard -->
        <div class="dashboard" id="dashboard">
            <!-- Navigation Tabs -->
            <div class="nav-tabs">
                <div class="nav-tab active" onclick="showTab('overview')">Overview</div>
                <div class="nav-tab" onclick="showTab('categories')">Categories Analysis</div>
                <div class="nav-tab" onclick="showTab('suppliers')">Suppliers Analysis</div>
                <div class="nav-tab" onclick="showTab('pareto')">Pareto Analysis</div>
                <div class="nav-tab" onclick="showTab('stratification')"> Spend Stratification</div>
                <div class="nav-tab" onclick="showTab('seasonality')">Seasonality Intelligence</div>
                <div class="nav-tab" onclick="showTab('tailspend')">Tail Spend Analysis</div>
                <div class="nav-tab" onclick="showTab('aiInsights')">ðŸ¤– AI Insights</div>
                <div class="nav-tab" onclick="showTab('predictive')">Predictive Analytics (under review)</div>
                <div class="nav-tab" onclick="showTab('maverick')">Maverick Spend & Compliance (under review)</div>
                <div class="nav-tab" onclick="showTab('contracts')">Contract Optimization Intelligence (under review)
                </div>
            </div>

            <!-- Filters -->
            <div class="filters">
                <!-- Filter Customization Button -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 1.1rem;">Filters</h3>
                    <button class="filter-btn" onclick="showFilterCustomizer()"
                        style="background: #667eea; padding: 8px 16px; font-size: 14px;">
                        âš™ï¸ Customize Filters
                    </button>
                </div>
                <div class="filter-row" id="filterRow">
                    <!-- Dynamic filters will be populated here -->
                    <button class="filter-btn" onclick="clearFilters()">Clear All</button>
                </div>
            </div>

            <!-- Overview Tab -->
            <div id="overview" class="tab-content active">
                <div class="stats-grid" id="statsGrid">
                    <!-- Stats will be populated here -->
                </div>

                <div class="chart-container">
                    <h3>ðŸ“Š All Categories Overview</h3>
                    <div class="chart-wrapper">
                        <canvas id="overviewChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Enhanced Categories Tab -->
            <div id="categories" class="tab-content">
                <!-- Category Insights Summary -->
                <div class="category-insights" id="categoryInsights">
                    <!-- Insights will be populated here -->
                </div>

                <!-- Subcategory Summary -->
                <div class="subcategory-summary" id="subcategorySummary">
                    <h3 style="text-align: center; color: #155724; margin-bottom: 15px;">ðŸ“‹ Subcategory Analysis Summary
                    </h3>
                    <div class="subcategory-grid" id="subcategoryGrid">
                        <!-- Subcategory summary will be populated here -->
                    </div>
                </div>

                <div class="chart-container">
                    <h3>ðŸ“ˆ Category Breakdown</h3>
                    <div class="chart-wrapper">
                        <canvas id="categoryChart"></canvas>
                    </div>
                </div>

                <div class="table-container">
                    <h3>ðŸ“‹ Enhanced Category Analysis (Click row for subcategory details)</h3>
                    <table id="categoryTable">
                        <thead>
                            <tr>
                                <th>Category</th>
                                <th>Total Spend</th>
                                <th>% of Total</th>
                                <th>Subcategories</th>
                                <th>Top Subcategory</th>
                                <th>Concentration</th>
                                <th>Suppliers</th>
                                <th>Avg/Supplier</th>
                                <th>Risk Level</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="categoryTableBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Suppliers Tab -->
            <div id="suppliers" class="tab-content">
                <div class="chart-container">
                    <h3>ðŸ¢ Top Suppliers</h3>
                    <div class="chart-wrapper">
                        <canvas id="supplierChart"></canvas>
                    </div>
                </div>

                <div class="table-container">
                    <h3>ðŸ“‹ Supplier Details</h3>
                    <table id="supplierTable">
                        <thead>
                            <tr>
                                <th>Supplier</th>
                                <th>Total Spend</th>
                                <th>% of Total</th>
                                <th>Transactions</th>
                                <th>Categories</th>
                            </tr>
                        </thead>
                        <tbody id="supplierTableBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Enhanced Pareto Analysis Tab -->
            <div id="pareto" class="tab-content">
                <!-- Pareto Insights Panel -->
                <div class="pareto-insights" id="paretoInsights">
                    <div class="pareto-title">ðŸŽ¯ Pareto Analysis Insights & Interpretation</div>
                    <div class="pareto-metrics" id="paretoMetrics">
                        <!-- Metrics will be populated here -->
                    </div>
                    <div class="pareto-interpretation" id="paretoInterpretation">
                        <!-- Interpretation will be populated here -->
                    </div>
                </div>

                <div class="chart-container">
                    <h3>ðŸŽ¯ Pareto Analysis (80/20 Rule)</h3>
                    <div class="chart-wrapper">
                        <canvas id="paretoChart"></canvas>
                    </div>
                </div>

                <div class="table-container">
                    <h3>ðŸ“‹ Pareto Details with Strategic Recommendations</h3>
                    <table id="paretoTable">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Supplier</th>
                                <th>Spend</th>
                                <th>Cumulative %</th>
                                <th>Classification</th>
                                <th>Strategic Priority</th>
                                <th>Recommended Action</th>
                            </tr>
                        </thead>
                        <tbody id="paretoTableBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Enhanced Stratification Tab with Procurement Specialist Insights -->
            <div id="stratification" class="tab-content">
                <!-- Enhanced SpendBand Insights Panel -->
                <div class="spendband-insights" id="spendbandInsights" style="display: none;">
                    <div class="spendband-title">
                        ðŸŽ¯ Procurement Specialist SpendBand Analysis & Strategic Intelligence
                    </div>
                    <div class="spendband-metrics" id="spendbandMetrics">
                        <!-- SpendBand metrics will be populated here -->
                    </div>
                    <div class="spendband-interpretation" id="spendbandInterpretation">
                        <!-- SpendBand interpretation will be populated here -->
                    </div>
                </div>

                <div class="chart-container">
                    <h3>ðŸ“‹ Spend Stratification</h3>
                    <div class="chart-wrapper">
                        <canvas id="stratificationChart"></canvas>
                    </div>
                </div>

                <div class="table-container">
                    <h3>ðŸ“‹ Stratification Details</h3>
                    <table id="stratificationTable">
                        <thead>
                            <tr>
                                <th>Segment</th>
                                <th>Spend Range</th>
                                <th>Total Spend</th>
                                <th>% of Total</th>
                                <th>Suppliers</th>
                                <th>Strategy</th>
                            </tr>
                        </thead>
                        <tbody id="stratificationTableBody">
                        </tbody>
                    </table>
                </div>

                <!-- Enhanced SpendBand Analysis Table with Improved Sorting -->
                <div class="table-container" id="spendBandContainer" style="display: none;">
                    <h3>ðŸ“Š SpendBand Analysis (Sorted by SpendBand)</h3>
                    <table id="spendBandTable">
                        <thead>
                            <tr>
                                <th>SpendBand</th>
                                <th>Total Spend</th>
                                <th>% of Total</th>
                                <th>Suppliers</th>
                                <th>Transactions</th>
                                <th>Avg Spend per Supplier</th>
                            </tr>
                        </thead>
                        <tbody id="spendBandTableBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Seasonality Intelligence Tab -->
            <div id="seasonality" class="tab-content">
                <!-- Seasonality Intelligence Panel -->
                <div class="seasonality-intelligence" id="seasonalityIntelligence" style="display: none;">
                    <div class="seasonality-title">
                        ðŸŒŸ Seasonality Intelligence & Optimization Opportunities
                    </div>
                    <div class="seasonality-metrics" id="seasonalityMetrics">
                        <!-- Seasonality metrics will be populated here -->
                    </div>
                    <div class="seasonality-insights" id="seasonalityInsightsPanel">
                        <!-- Seasonality insights will be populated here -->
                    </div>
                </div>

                <!-- Seasonality Charts -->
                <div class="seasonality-chart-container" id="seasonalityCharts" style="display: none;">
                    <h3>ðŸ“Š Seasonal Patterns Analysis</h3>
                    <div class="chart-wrapper">
                        <canvas id="seasonalityChart"></canvas>
                    </div>
                </div>

                <!-- Opportunity Cards -->
                <div class="opportunity-cards" id="opportunityCards" style="display: none;">
                    <!-- Opportunity cards will be populated here -->
                </div>

                <!-- No Seasonality Message -->
                <div class="seasonality-ready" id="noSeasonalityMessage">
                    <div style="font-size: 3rem; margin-bottom: 20px;">ðŸ“Š</div>
                    <h3>Seasonality Analysis Ready</h3>
                    <p>Upload your procurement data with date information to discover seasonal patterns and optimization
                        opportunities.</p>
                    <p style="margin-top: 15px; font-size: 0.9rem;">
                        <strong>Required columns:</strong> Date, Amount, Category, Supplier
                    </p>
                </div>
            </div>

            <!-- Tail Spend Analysis Tab -->
            <div id="tailspend" class="tab-content">
                <!-- Tail Spend Analysis Container -->
                <div class="tail-spend-container" id="tailSpendContainer">
                    <div class="tail-spend-title">
                        ðŸŽ¯ Tail Spend Analysis & Vendor Consolidation Opportunities
                    </div>

                    <!-- Executive Summary Metrics -->
                    <div class="tail-spend-metrics" id="tailSpendMetrics">
                        <div class="tail-spend-metric">
                            <div class="tail-spend-metric-value" id="totalVendorsCount">-</div>
                            <div class="tail-spend-metric-label">Total Vendors</div>
                        </div>
                        <div class="tail-spend-metric">
                            <div class="tail-spend-metric-value" id="tailVendorsCount">-</div>
                            <div class="tail-spend-metric-label">Tail Vendors</div>
                        </div>
                        <div class="tail-spend-metric">
                            <div class="tail-spend-metric-value" id="tailSpendAmount">-</div>
                            <div class="tail-spend-metric-label">Tail Spend</div>
                        </div>
                        <div class="tail-spend-metric">
                            <div class="tail-spend-metric-value" id="tailSpendPercentage">-</div>
                            <div class="tail-spend-metric-label">% of Total Spend</div>
                        </div>
                        <div class="tail-spend-metric">
                            <div class="tail-spend-metric-value" id="totalSavingsOpportunity">-</div>
                            <div class="tail-spend-metric-label">Savings Opportunity</div>
                        </div>
                    </div>

                    <!-- Pareto Analysis Chart -->
                    <div class="pareto-analysis-container">
                        <div class="tail-segmentation-title">
                            ðŸ“Š Vendor Pareto Analysis
                        </div>
                        <div class="pareto-chart-container">
                            <canvas id="tailParetoChart"></canvas>
                        </div>
                    </div>

                    <!-- Tail Segmentation -->
                    <div class="tail-segmentation-container">
                        <div class="tail-segmentation-title">
                            ðŸ” Tail Vendor Segmentation
                        </div>
                        <div id="tailSegmentation">
                            <!-- Segmentation cards will be populated here -->
                        </div>
                    </div>

                    <!-- Savings Opportunities -->
                    <div class="savings-opportunities-container">
                        <div class="savings-opportunities-title">
                            ðŸ’° Savings Opportunities & Strategic Recommendations
                        </div>
                        <div id="savingsStrategies">
                            <!-- Savings strategy cards will be populated here -->
                        </div>

                        <!-- Implementation Timeline -->
                        <div class="implementation-timeline">
                            <h4 style="margin-bottom: 15px; color: #2c3e50;">ðŸ“… Implementation Timeline</h4>
                            <div id="implementationTimeline">
                                <!-- Timeline phases will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Vendor Risk Analysis -->
                    <div class="vendor-risk-container">
                        <div class="tail-segmentation-title">
                            âš ï¸ Vendor Risk Assessment
                        </div>
                        <div class="table-container">
                            <table id="vendorRiskTable">
                                <thead>
                                    <tr>
                                        <th>Vendor</th>
                                        <th>Annual Spend</th>
                                        <th>Transaction Count</th>
                                        <th>Risk Score</th>
                                        <th>Consolidation Priority</th>
                                        <th>Recommended Action</th>
                                    </tr>
                                </thead>
                                <tbody id="vendorRiskTableBody">
                                    <!-- Risk assessment data will be populated here -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Category-Level Analysis -->
                    <div class="tail-segmentation-container">
                        <div class="tail-segmentation-title">
                            ðŸ“ˆ Category-Level Tail Analysis
                        </div>
                        <div id="categoryTailAnalysis">
                            <!-- Category analysis will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- No Data Message -->
                <div class="seasonality-ready" id="noTailSpendMessage">
                    <div style="font-size: 3rem; margin-bottom: 20px;">ðŸŽ¯</div>
                    <h3>Tail Spend Analysis Ready</h3>
                    <p>Upload your procurement data to identify vendor consolidation opportunities and calculate savings
                        potential.</p>
                    <p style="margin-top: 15px; font-size: 0.9rem;">
                        <strong>Required columns:</strong> Vendor/Supplier, Amount, Category
                    </p>
                </div>
            </div>

            <!-- Predictive Analytics Tab -->
            <div id="predictive" class="tab-content">
                <div class="predictive-container" id="predictiveContainer">
                    <!-- Forecast Summary -->
                    <div class="forecast-summary-container">
                        <div class="forecast-summary-title">
                            ðŸ”® Predictive Spend Forecasting & Scenario Planning
                        </div>
                        <div id="forecastSummary">
                            <!-- Forecast summary will be populated here -->
                        </div>
                    </div>

                    <!-- Total Spend Forecast -->
                    <div class="forecast-section">
                        <div class="forecast-section-title">
                            ðŸ“Š Total Spend Forecast (Next 12 Months)
                        </div>
                        <div class="forecast-chart-container">
                            <canvas id="totalForecastChart"></canvas>
                        </div>
                        <div id="totalForecastMetrics">
                            <!-- Total forecast metrics will be populated here -->
                        </div>
                    </div>

                    <!-- Category Forecasts -->
                    <div class="forecast-section">
                        <div class="forecast-section-title">
                            ðŸ“ˆ Category Spend Forecasts
                        </div>
                        <div id="categoryForecasts">
                            <!-- Category forecasts will be populated here -->
                        </div>
                    </div>

                    <!-- Supplier Forecasts -->
                    <div class="forecast-section">
                        <div class="forecast-section-title">
                            ðŸ¢ Top Supplier Forecasts
                        </div>
                        <div id="supplierForecasts">
                            <!-- Supplier forecasts will be populated here -->
                        </div>
                    </div>

                    <!-- Scenario Analysis -->
                    <div class="forecast-section">
                        <div class="forecast-section-title">
                            ðŸŽ¯ Scenario Planning & What-If Analysis
                        </div>
                        <div id="scenarioAnalysis">
                            <!-- Scenario analysis will be populated here -->
                        </div>
                    </div>

                    <!-- Forecast Accuracy & Data Quality -->
                    <div class="forecast-section">
                        <div class="forecast-section-title">
                            ðŸ“‹ Forecast Accuracy & Data Quality
                        </div>
                        <div id="forecastAccuracy">
                            <!-- Forecast accuracy metrics will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- No Data Message -->
                <div class="seasonality-ready" id="noPredictiveMessage">
                    <div style="font-size: 3rem; margin-bottom: 20px;">ðŸ”®</div>
                    <h3>Predictive Analytics Ready</h3>
                    <p>Upload your procurement data to generate spend forecasts and scenario analysis.</p>
                    <p style="margin-top: 15px; font-size: 0.9rem;">
                        <strong>Required:</strong> At least 6 months of historical data with dates for reliable
                        forecasting
                    </p>
                </div>
            </div>

            <!-- AI Insights Tab -->
            <div id="aiInsights" class="tab-content">
                <div class="insights-panel">
                    <div class="insights-header">
                        <h2>ðŸ¤– AI-Powered Insights</h2>
                        <div class="insights-controls">
                            <button class="refresh-btn" onclick="refreshAIInsights()">
                                <span class="refresh-icon">ðŸ”„</span> Refresh
                            </button>
                            <button class="view-toggle-btn" onclick="toggleInsightsView()">
                                <span id="viewToggleIcon">ðŸ“Š</span> <span id="viewToggleText">Switch to Tab View</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="insights-summary">
                        <div class="summary-card">
                            <div class="summary-value" id="totalInsights">0</div>
                            <div class="summary-label">Total Insights</div>
                        </div>
                        <div class="summary-card high-priority">
                            <div class="summary-value" id="highPriorityCount">0</div>
                            <div class="summary-label">High Priority</div>
                        </div>
                        <div class="summary-card savings">
                            <div class="summary-value" id="potentialSavings">$0</div>
                            <div class="summary-label">Potential Savings</div>
                        </div>
                        <div class="summary-card">
                            <div class="summary-value" id="lastUpdated">Never</div>
                            <div class="summary-label">Last Updated</div>
                        </div>
                    </div>
                    
                    <!-- Smart Search Interface -->
                    <div class="nlq-container">
                        <div class="nlq-header">
                            <span class="nlq-icon">ðŸ”</span>
                            <span class="nlq-title">Smart Search - Filter insights by keywords</span>
                        </div>
                        <div class="nlq-input-wrapper">
                            <input type="text" 
                                   id="nlqInput" 
                                   class="nlq-input" 
                                   placeholder="Search insights: 'savings', 'high priority', 'facilities', 'trends', etc."
                                   onkeypress="handleNLQKeyPress(event)">
                            <button class="nlq-button" onclick="processNLQuery()">
                                Search
                            </button>
                        </div>
                        <div class="nlq-suggestions">
                            <span class="nlq-suggestion-label">Quick filters:</span>
                            <button class="nlq-suggestion" onclick="setNLQuery('savings')">Savings</button>
                            <button class="nlq-suggestion" onclick="setNLQuery('high priority')">High Priority</button>
                            <button class="nlq-suggestion" onclick="setNLQuery('facilities')">Facilities</button>
                            <button class="nlq-suggestion" onclick="setNLQuery('trends')">Trends</button>
                        </div>
                    </div>
                    
                    <!-- AI Assistant Interface -->
                    <div class="ai-assistant-container">
                        <div class="ai-assistant-header">
                            <span class="ai-assistant-icon">ðŸ¤–</span>
                            <span class="ai-assistant-title">AI Assistant - Ask anything about your data</span>
                            <button class="ai-config-btn" onclick="configureAIAssistant()" title="Configure API Key">âš™ï¸</button>
                        </div>
                        <div class="ai-assistant-input-wrapper">
                            <textarea id="aiAssistantInput" 
                                     class="ai-assistant-input" 
                                     placeholder="Ask complex questions like: 'Why did spending increase last quarter?' or 'What are the risks with our top suppliers?'"
                                     rows="3"></textarea>
                            <button class="ai-assistant-button" onclick="processAIQuery()">
                                <span class="ai-button-text">Ask AI</span>
                                <span class="ai-button-spinner" style="display: none;">â³</span>
                            </button>
                        </div>
                        <div class="ai-assistant-suggestions">
                            <span class="ai-suggestion-label">Example questions:</span>
                            <button class="ai-suggestion" onclick="setAIQuery('Why did spending in Facilities increase in the last 3 months?')">Spending trends</button>
                            <button class="ai-suggestion" onclick="setAIQuery('What are the main risks with our supplier concentration?')">Risk analysis</button>
                            <button class="ai-suggestion" onclick="setAIQuery('How can we optimize our procurement strategy?')">Strategy advice</button>
                            <button class="ai-suggestion" onclick="setAIQuery('Compare our spending patterns to industry benchmarks')">Benchmarking</button>
                        </div>
                        <div class="ai-assistant-response" id="aiAssistantResponse" style="display: none;">
                            <!-- AI responses will appear here -->
                        </div>
                    </div>
                    
                    <!-- Tab Navigation (hidden by default) -->
                    <div class="insights-tabs" id="insightsTabs" style="display: none;">
                        <button class="insight-tab-btn active" onclick="showInsightTab('savings')">
                            ðŸ’° Savings Opportunities <span class="tab-count" id="savingsCount">0</span>
                        </button>
                        <button class="insight-tab-btn" onclick="showInsightTab('anomaly')">
                            âš ï¸ Anomalies <span class="tab-count" id="anomalyCount">0</span>
                        </button>
                        <button class="insight-tab-btn" onclick="showInsightTab('pattern')">
                            ðŸ” Patterns <span class="tab-count" id="patternCount">0</span>
                        </button>
                        <button class="insight-tab-btn" onclick="showInsightTab('trend')">
                            ðŸ“ˆ Trends <span class="tab-count" id="trendCount">0</span>
                        </button>
                        <button class="insight-tab-btn" onclick="showInsightTab('all')">
                            ðŸ“‹ All Insights
                        </button>
                    </div>
                    
                    <!-- List View (default) -->
                    <div class="insights-list-view" id="insightsListView">
                        <div class="insight-filters">
                            <select class="insight-filter" id="insightTypeFilter" onchange="filterInsights()">
                                <option value="all">All Types</option>
                                <option value="anomaly">Anomalies</option>
                                <option value="trend">Trends</option>
                                <option value="savings">Savings</option>
                                <option value="pattern">Patterns</option>
                            </select>
                            <select class="insight-filter" id="insightSeverityFilter" onchange="filterInsights()">
                                <option value="all">All Priorities</option>
                                <option value="high">High</option>
                                <option value="medium">Medium</option>
                                <option value="low">Low</option>
                            </select>
                        </div>
                        <div class="insights-list" id="insightsList">
                            <!-- Insights will be populated here -->
                            <div class="no-insights">
                                <p>Click "Refresh" to generate AI insights from your data.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Tab Content View (hidden by default) -->
                    <div class="insights-tab-view" id="insightsTabView" style="display: none;">
                        <div class="insight-tab-content active" id="savings-insights">
                            <!-- Savings insights will be populated here -->
                        </div>
                        <div class="insight-tab-content" id="anomaly-insights">
                            <!-- Anomaly insights will be populated here -->
                        </div>
                        <div class="insight-tab-content" id="pattern-insights">
                            <!-- Pattern insights will be populated here -->
                        </div>
                        <div class="insight-tab-content" id="trend-insights">
                            <!-- Trend insights will be populated here -->
                        </div>
                        <div class="insight-tab-content" id="all-insights">
                            <!-- All insights will be populated here -->
                        </div>
                    </div>
                    
                    <div class="insights-footer">
                        <button class="export-insights-btn" onclick="exportAIInsights()">
                            ðŸ“¥ Export Insights Report
                        </button>
                        <button class="configure-btn" onclick="configureAISettings()">
                            âš™ï¸ Configure AI Settings
                        </button>
                    </div>
                </div>
            </div>

            <!-- Maverick Spend & Compliance Tab -->
            <div id="maverick" class="tab-content">
                <div class="maverick-container" id="maverickContainer">
                    <!-- Compliance Overview -->
                    <div class="compliance-overview-container">
                        <div class="compliance-overview-title">
                            ðŸš¨ Maverick Spend Detection & Compliance Monitoring
                        </div>
                        <div id="complianceOverview">
                            <!-- Compliance overview will be populated here -->
                        </div>
                    </div>

                    <!-- Compliance Score Dashboard -->
                    <div class="compliance-score-container">
                        <div class="section-title">ðŸ“Š Compliance Score Dashboard</div>
                        <div id="complianceScores">
                            <!-- Compliance scores will be populated here -->
                        </div>
                    </div>

                    <!-- Alert Categories -->
                    <div class="alert-categories-container">
                        <div class="section-title">âš ï¸ Compliance Alerts & Violations</div>
                        <div class="alert-tabs">
                            <div class="alert-tab-btn active" onclick="showAlertTab('newSuppliers')">New Suppliers</div>
                            <div class="alert-tab-btn" onclick="showAlertTab('spendAnomalies')">Spend Anomalies</div>
                            <div class="alert-tab-btn" onclick="showAlertTab('concentrationRisks')">Concentration Risks
                            </div>
                            <div class="alert-tab-btn" onclick="showAlertTab('unusualTransactions')">Unusual
                                Transactions</div>
                            <div class="alert-tab-btn" onclick="showAlertTab('offContract')">Off-Contract Spend</div>
                        </div>
                        <div class="alert-content">
                            <div id="newSuppliers-alert" class="alert-tab-content active">
                                <!-- New suppliers alerts will be populated here -->
                            </div>
                            <div id="spendAnomalies-alert" class="alert-tab-content">
                                <!-- Spend anomalies alerts will be populated here -->
                            </div>
                            <div id="concentrationRisks-alert" class="alert-tab-content">
                                <!-- Concentration risks alerts will be populated here -->
                            </div>
                            <div id="unusualTransactions-alert" class="alert-tab-content">
                                <!-- Unusual transactions alerts will be populated here -->
                            </div>
                            <div id="offContract-alert" class="alert-tab-content">
                                <!-- Off-contract spend alerts will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Recommendations -->
                    <div class="recommendations-container">
                        <div class="section-title">ðŸ’¡ Compliance Recommendations</div>
                        <div id="complianceRecommendations">
                            <!-- Recommendations will be populated here -->
                        </div>
                    </div>

                    <!-- Supplier Risk Matrix -->
                    <div class="risk-matrix-container">
                        <div class="section-title">ðŸŽ¯ Supplier Risk Matrix</div>
                        <div id="supplierRiskMatrix">
                            <!-- Risk matrix will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- No Data Message -->
                <div class="seasonality-ready" id="noMaverickMessage">
                    <div style="font-size: 3rem; margin-bottom: 20px;">ðŸš¨</div>
                    <h3>Maverick Spend Detection Ready</h3>
                    <p>Upload your procurement data to detect compliance violations and spending anomalies.</p>
                    <p style="margin-top: 15px; font-size: 0.9rem;">
                        <strong>Required:</strong> Transaction-level data with suppliers, categories, and amounts
                    </p>
                </div>
            </div>
        </div>

        <!-- Contract Optimization Intelligence Tab -->
        <div id="contracts" class="tab-content">
            <div class="contracts-container" id="contractsContainer">
                <!-- Portfolio Overview -->
                <div class="contracts-overview-container">
                    <div class="contracts-overview-title">
                        ðŸ“‹ Contract Optimization Intelligence
                    </div>
                    <div id="contractPortfolioOverview">
                        <!-- Portfolio overview will be populated here -->
                    </div>
                </div>

                <!-- Renewal Pipeline -->
                <div class="contracts-section">
                    <div class="contracts-section-title">
                        ðŸ“… Contract Renewal Pipeline
                    </div>
                    <div id="contractRenewalPipeline">
                        <!-- Renewal pipeline will be populated here -->
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="contracts-section">
                    <div class="contracts-section-title">
                        ðŸ“Š Contract Performance Metrics
                    </div>
                    <div id="contractPerformanceMetrics">
                        <!-- Performance metrics will be populated here -->
                    </div>
                </div>

                <!-- Volume Commitments -->
                <div class="contracts-section">
                    <div class="contracts-section-title">
                        ðŸ“ˆ Volume Commitments & Compliance
                    </div>
                    <div id="contractVolumeCommitments">
                        <!-- Volume commitments will be populated here -->
                    </div>
                </div>

                <!-- Optimization Opportunities -->
                <div class="contracts-section">
                    <div class="contracts-section-title">
                        ðŸ’¡ Optimization Opportunities
                    </div>
                    <div id="contractOptimizationOpportunities">
                        <!-- Optimization opportunities will be populated here -->
                    </div>
                </div>

                <!-- Risk Assessment -->
                <div class="contracts-section">
                    <div class="contracts-section-title">
                        âš ï¸ Contract Risk Assessment
                    </div>
                    <div id="contractRiskAssessment">
                        <!-- Risk assessment will be populated here -->
                    </div>
                </div>

                <!-- Strategic Recommendations -->
                <div class="contracts-section">
                    <div class="contracts-section-title">
                        ðŸŽ¯ Strategic Recommendations
                    </div>
                    <div id="contractRecommendations">
                        <!-- Recommendations will be populated here -->
                    </div>
                </div>

                <!-- No Data Message -->
                <div class="seasonality-ready" id="noContractsMessage">
                    <div style="font-size: 3rem; margin-bottom: 20px;">ðŸ“‹</div>
                    <h3>Contract Optimization Intelligence Ready</h3>
                    <p>Upload your procurement data to analyze contract performance and identify optimization
                        opportunities.</p>
                    <p style="margin-top: 15px; font-size: 0.9rem;">
                        <strong>Note:</strong> Analysis works with transaction data by inferring contract relationships
                        from supplier spending patterns
                    </p>
                </div>
            </div>
        </div>

        <!-- Enhanced Subcategory Modal -->
        <div id="subcategoryModal" class="modal">
            <div class="modal-content">
                <span class="close-btn" onclick="closeModal()">&times;</span>
                <h2 id="modalTitle">Subcategory Analysis</h2>

                <!-- Subcategory Insights -->
                <div class="category-insights" id="modalInsights" style="margin-bottom: 20px;">
                    <!-- Modal insights will be populated here -->
                </div>

                <div class="chart-container" style="margin-bottom: 20px;">
                    <h3>ðŸ“Š Subcategory Distribution</h3>
                    <div class="chart-wrapper" style="height: 300px;">
                        <canvas id="subcategoryChart"></canvas>
                    </div>
                </div>

                <div class="table-container">
                    <h3>ðŸ“‹ Detailed Subcategory Analysis</h3>
                    <table id="subcategoryTable">
                        <thead>
                            <tr>
                                <th>Subcategory</th>
                                <th>Total Spend</th>
                                <th>% of Category</th>
                                <th>Transactions</th>
                                <th>Suppliers</th>
                                <th>Avg/Transaction</th>
                                <th>Concentration</th>
                            </tr>
                        </thead>
                        <tbody id="subcategoryTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Filter Customizer Modal -->
        <div id="filterCustomizerModal" class="modal">
            <div class="modal-content" style="max-width: 800px;">
                <span class="close-btn" onclick="closeFilterCustomizer()">&times;</span>
                <h2>ðŸŽ›ï¸ Customize Dashboard Filters</h2>

                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <p style="margin: 0 0 10px 0; color: #666;">
                        Select which fields from your data should appear as filters in the dashboard.
                        If no fields are selected, the default filters (Category, Subcategory, Location) will be used.
                    </p>
                    <p style="margin: 0; color: #666; font-size: 0.9rem;">
                        <strong>Note:</strong> Fields marked as <span style="color: #667eea;">(core)</span> are
                        essential dashboard fields used for analysis.
                        Only categorical fields suitable for filtering are shown here.
                    </p>
                </div>

                <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 15px; color: #2d3748;">Available Fields</h3>
                        <div id="availableFields"
                            style="border: 2px solid #e2e8f0; border-radius: 8px; padding: 15px; min-height: 300px; background: white;">
                            <!-- Available fields will be populated here -->
                        </div>
                    </div>

                    <div style="display: flex; flex-direction: column; justify-content: center; gap: 10px;">
                        <button class="filter-btn" onclick="addSelectedFields()" style="padding: 10px 20px;">â†’</button>
                        <button class="filter-btn" onclick="removeSelectedFields()"
                            style="padding: 10px 20px;">â†</button>
                    </div>

                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 15px; color: #2d3748;">Selected Filters</h3>
                        <div id="selectedFields"
                            style="border: 2px solid #667eea; border-radius: 8px; padding: 15px; min-height: 300px; background: #f8f9ff;">
                            <!-- Selected fields will be populated here -->
                        </div>
                    </div>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; gap: 10px;">
                        <button class="filter-btn" onclick="resetToDefaults()" style="background: #718096;">Reset to
                            Defaults</button>
                        <button class="filter-btn" onclick="clearAllFilters()" style="background: #e53e3e;">Clear
                            All</button>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="filter-btn" onclick="cancelFilterCustomization()"
                            style="background: transparent; border: 2px solid #cbd5e0; color: #4a5568;">Cancel</button>
                        <button class="filter-btn" onclick="applyFilterCustomization()"
                            style="background: #48bb78;">Apply Changes</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Check if user has seen intro before
        window.addEventListener('DOMContentLoaded', function () {
            const hasSeenIntro = localStorage.getItem('vstx-pro-intro-seen');
            if (hasSeenIntro === 'true') {
                document.getElementById('introOverlay').classList.add('hidden');
            }

            // Load filter configuration
            loadFilterConfiguration();
        });

        // Intro Functions
        function startDashboard() {
            const introOverlay = document.getElementById('introOverlay');
            introOverlay.style.opacity = '0';
            introOverlay.style.transform = 'translateY(-100%)';

            setTimeout(() => {
                introOverlay.classList.add('hidden');
            }, 500);

            // Save preference if checkbox is checked
            if (document.getElementById('rememberChoice').checked) {
                localStorage.setItem('vstx-pro-intro-seen', 'true');
            }
        }

        function skipIntro() {
            startDashboard();
        }

        function updatePreference() {
            const checkbox = document.getElementById('rememberChoice');
            if (checkbox.checked) {
                localStorage.setItem('vstx-pro-intro-seen', 'true');
            } else {
                localStorage.removeItem('vstx-pro-intro-seen');
            }
        }

        // Add a way to show intro again from main dashboard
        function showIntroAgain() {
            localStorage.removeItem('vstx-pro-intro-seen');
            document.getElementById('introOverlay').classList.remove('hidden');
            document.getElementById('introOverlay').style.opacity = '1';
            document.getElementById('introOverlay').style.transform = 'translateY(0)';
        }

        let rawData = [];
        let filteredData = [];
        let charts = {};
        let debugMode = false;
        let categoryAnalytics = {};
        let paretoAnalytics = {};
        let spendbandAnalytics = {};
        let seasonalityAnalytics = {};
        let tailSpendAnalytics = {};
        let paretoAnalysis = {};
        let vendorRiskScores = {};
        let categorySubcategoryMap = {};

        // Filter customization variables
        let availableFieldsData = {};
        let selectedFilterFields = [];
        const defaultFilterFields = ['category', 'subcategory', 'location'];
        let filterFieldsConfig = null;

        // Required fields for dashboard functionality (these are not filters, but core data fields)
        const requiredDataFields = ['supplier', 'category', 'subcategory', 'amount', 'date', 'transactions'];

        // Fields that can be used as filters (subset of all fields)
        const filterableFields = new Set();
        
        // Theme Management
        function initTheme() {
            const savedTheme = localStorage.getItem('vstx-theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeToggle(savedTheme);
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('vstx-theme', newTheme);
            updateThemeToggle(newTheme);
            
            // Update chart colors if charts exist
            if (Object.keys(charts).length > 0) {
                updateChartThemes();
            }
        }
        
        function updateThemeToggle(theme) {
            // Update main theme toggle
            const themeIcon = document.getElementById('themeIcon');
            const themeName = document.getElementById('themeName');
            
            if (themeIcon && themeName) {
                if (theme === 'dark') {
                    themeIcon.textContent = 'â˜€ï¸';
                    themeName.textContent = 'Light';
                } else {
                    themeIcon.textContent = 'ðŸŒ™';
                    themeName.textContent = 'Dark';
                }
            }
            
            // Update intro theme toggle
            const introThemeIcon = document.getElementById('introThemeIcon');
            const introThemeName = document.getElementById('introThemeName');
            
            if (introThemeIcon && introThemeName) {
                if (theme === 'dark') {
                    introThemeIcon.textContent = 'â˜€ï¸';
                    introThemeName.textContent = 'Light';
                } else {
                    introThemeIcon.textContent = 'ðŸŒ™';
                    introThemeName.textContent = 'Dark';
                }
            }
        }
        
        function updateChartThemes() {
            // Update chart default colors for dark theme
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            
            Chart.defaults.color = isDark ? '#ffffff' : '#666';
            Chart.defaults.borderColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            Chart.defaults.plugins.legend.labels.color = isDark ? '#ffffff' : '#666';
            Chart.defaults.plugins.title.color = isDark ? '#ffffff' : '#333';
            
            // Refresh all charts
            updateCharts();
        }
        
        // Initialize theme on load
        initTheme();

        // Seasonality Analysis Class
        class SeasonalityAnalyzer {
            constructor() {
                this.monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                this.seasonNames = {
                    'Winter': [12, 1, 2],
                    'Spring': [3, 4, 5],
                    'Summer': [6, 7, 8],
                    'Fall': [9, 10, 11]
                };
            }

            // Calculate seasonal indices for each category
            calculateSeasonalIndices(data, category) {
                const categoryData = data.filter(row => row.category === category);
                if (categoryData.length < 12) return null; // Insufficient data

                // Group by month
                const monthlyData = {};
                for (let month = 1; month <= 12; month++) {
                    monthlyData[month] = {
                        spend: 0,
                        count: 0,
                        transactions: 0
                    };
                }

                categoryData.forEach(row => {
                    const month = new Date(row.date).getMonth() + 1;
                    // Ensure month is valid (1-12) and monthlyData[month] exists
                    if (month >= 1 && month <= 12 && monthlyData[month]) {
                        monthlyData[month].spend += row.amount;
                        monthlyData[month].count++;
                        monthlyData[month].transactions += row.transactions || 1;
                    }
                });

                // Calculate overall average
                const totalSpend = categoryData.reduce((sum, row) => sum + row.amount, 0);
                const avgMonthlySpend = totalSpend / 12;

                // Calculate seasonal indices
                const seasonalIndices = {};
                let maxIndex = 0;
                let minIndex = Infinity;
                let maxMonth = 1;
                let minMonth = 1;

                for (let month = 1; month <= 12; month++) {
                    // Ensure monthlyData[month] exists before accessing its properties
                    if (!monthlyData[month]) {
                        monthlyData[month] = { spend: 0, count: 0, transactions: 0 };
                    }

                    const monthlySpend = monthlyData[month].spend;
                    const index = avgMonthlySpend > 0 ? (monthlySpend / avgMonthlySpend) * 100 : 100;
                    seasonalIndices[month] = {
                        index: index,
                        spend: monthlySpend,
                        count: monthlyData[month].count,
                        transactions: monthlyData[month].transactions,
                        percentage: (monthlySpend / totalSpend) * 100
                    };

                    if (index > maxIndex) {
                        maxIndex = index;
                        maxMonth = month;
                    }
                    if (index < minIndex) {
                        minIndex = index;
                        minMonth = month;
                    }
                }

                // Calculate seasonality strength (coefficient of variation)
                const indices = Object.values(seasonalIndices).map(d => d.index);
                const mean = indices.reduce((sum, val) => sum + val, 0) / indices.length;
                const variance = indices.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / indices.length;
                const stdDev = Math.sqrt(variance);
                const seasonalityStrength = (stdDev / mean) * 100;

                return {
                    category: category,
                    seasonalIndices: seasonalIndices,
                    seasonalityStrength: seasonalityStrength,
                    peakMonth: maxMonth,
                    lowMonth: minMonth,
                    peakIndex: maxIndex,
                    lowIndex: minIndex,
                    totalSpend: totalSpend,
                    dataPoints: categoryData.length
                };
            }

            // Identify optimization opportunities
            identifyOpportunities(seasonalityResults) {
                const opportunities = [];

                Object.values(seasonalityResults).forEach(result => {
                    if (!result || result.seasonalityStrength < 15) return;

                    const category = result.category;
                    const strength = result.seasonalityStrength;
                    const totalSpend = result.totalSpend;
                    const peakMonth = result.peakMonth;
                    const lowMonth = result.lowMonth;

                    // Determine opportunity type and savings potential
                    let opportunityType, savingsRange, impactLevel;

                    if (strength > 30) {
                        opportunityType = 'Off-Peak Contracting';
                        savingsRange = [0.15, 0.25]; // 15-25%
                        impactLevel = 'High';
                    } else if (strength > 20) {
                        opportunityType = 'Seasonal Negotiation';
                        savingsRange = [0.10, 0.20]; // 10-20%
                        impactLevel = 'Medium';
                    } else {
                        opportunityType = 'Volume Consolidation';
                        savingsRange = [0.05, 0.10]; // 5-10%
                        impactLevel = 'Low';
                    }

                    // Calculate potential savings
                    const peakSpendShare = result.seasonalIndices[peakMonth].percentage;
                    const conservativeSavings = totalSpend * (peakSpendShare / 100) * savingsRange[0];
                    const optimisticSavings = totalSpend * (peakSpendShare / 100) * savingsRange[1];

                    opportunities.push({
                        category: category,
                        type: opportunityType,
                        impact: impactLevel,
                        seasonalityStrength: strength,
                        peakMonth: peakMonth,
                        lowMonth: lowMonth,
                        peakMonthName: this.monthNames[peakMonth - 1],
                        lowMonthName: this.monthNames[lowMonth - 1],
                        totalSpend: totalSpend,
                        conservativeSavings: conservativeSavings,
                        optimisticSavings: optimisticSavings,
                        timeline: '6-12 months'
                    });
                });

                // Sort by potential savings
                opportunities.sort((a, b) => b.optimisticSavings - a.optimisticSavings);

                return opportunities;
            }

            // Analyze all categories
            analyzeSeasonality(data) {
                const results = {};
                const categories = [...new Set(data.map(row => row.category))];

                categories.forEach(category => {
                    const seasonalData = this.calculateSeasonalIndices(data, category);
                    if (seasonalData) {
                        results[category] = seasonalData;
                    }
                });

                const opportunities = this.identifyOpportunities(results);

                return {
                    categoryResults: results,
                    opportunities: opportunities,
                    summary: this.generateSummary(results, opportunities)
                };
            }

            // Generate executive summary
            generateSummary(results, opportunities) {
                const totalCategories = Object.keys(results).length;
                const highImpactOpportunities = opportunities.filter(o => o.impact === 'High').length;
                const totalSavingsPotential = opportunities.reduce((sum, o) => sum + o.optimisticSavings, 0);

                return {
                    totalCategories: totalCategories,
                    totalOpportunities: opportunities.length,
                    highImpactOpportunities: highImpactOpportunities,
                    totalSavingsPotential: totalSavingsPotential
                };
            }
        }

        // Vendor Consolidation Analyzer Class
        class VendorConsolidationAnalyzer {
            constructor() {
                this.consolidationBenchmarks = {
                    multiCategoryBonus: 0.08,     // 8% additional savings for multi-category vendors
                    geographicConsolidation: 0.05, // 5% savings for geographic consolidation
                    volumeThreshold: 25000,       // Minimum combined spend for strategic partnership
                    adminSavingsPerVendor: 2500   // Administrative cost savings per eliminated vendor
                };
            }

            // Analyze vendors across multiple categories
            analyzeCrossCategoryOpportunities(data) {
                const vendorCategories = {};
                const vendorLocations = {};
                const vendorBusinessUnits = {};

                // Build vendor profile maps
                data.forEach(row => {
                    const vendor = row.supplier || row.vendor || 'Unknown';
                    const category = row.category || 'Unknown';
                    const location = row.location || 'Unknown';
                    const businessUnit = row.businessUnit || 'Unknown';
                    const amount = parseFloat(row.amount) || 0;

                    // Track categories per vendor
                    if (!vendorCategories[vendor]) {
                        vendorCategories[vendor] = {};
                    }
                    if (!vendorCategories[vendor][category]) {
                        vendorCategories[vendor][category] = 0;
                    }
                    vendorCategories[vendor][category] += amount;

                    // Track locations per vendor
                    if (!vendorLocations[vendor]) {
                        vendorLocations[vendor] = {};
                    }
                    if (!vendorLocations[vendor][location]) {
                        vendorLocations[vendor][location] = 0;
                    }
                    vendorLocations[vendor][location] += amount;

                    // Track business units per vendor
                    if (!vendorBusinessUnits[vendor]) {
                        vendorBusinessUnits[vendor] = {};
                    }
                    if (!vendorBusinessUnits[vendor][businessUnit]) {
                        vendorBusinessUnits[vendor][businessUnit] = 0;
                    }
                    vendorBusinessUnits[vendor][businessUnit] += amount;
                });

                // Identify multi-category vendors
                const multiCategoryVendors = [];
                Object.entries(vendorCategories).forEach(([vendor, categories]) => {
                    const categoryList = Object.keys(categories);
                    if (categoryList.length > 1) {
                        const totalSpend = Object.values(categories).reduce((sum, spend) => sum + spend, 0);
                        const locationCount = Object.keys(vendorLocations[vendor] || {}).length;
                        const businessUnitCount = Object.keys(vendorBusinessUnits[vendor] || {}).length;

                        multiCategoryVendors.push({
                            vendor,
                            categories: categoryList,
                            categoryCount: categoryList.length,
                            totalSpend,
                            locationCount,
                            businessUnitCount,
                            categoryBreakdown: categories,
                            locationBreakdown: vendorLocations[vendor] || {},
                            businessUnitBreakdown: vendorBusinessUnits[vendor] || {},
                            consolidationPotential: this.calculateConsolidationPotential(totalSpend, categoryList.length, locationCount)
                        });
                    }
                });

                return multiCategoryVendors.sort((a, b) => b.consolidationPotential.totalSavings - a.consolidationPotential.totalSavings);
            }

            // Calculate consolidation potential for a vendor
            calculateConsolidationPotential(totalSpend, categoryCount, locationCount) {
                const baseSavingsRate = 0.12; // 12% base savings rate
                const multiCategoryBonus = (categoryCount - 1) * this.consolidationBenchmarks.multiCategoryBonus;
                const geographicBonus = Math.max(0, (locationCount - 1) * this.consolidationBenchmarks.geographicConsolidation);

                const totalSavingsRate = Math.min(0.25, baseSavingsRate + multiCategoryBonus + geographicBonus); // Cap at 25%
                const totalSavings = totalSpend * totalSavingsRate;
                const adminSavings = this.consolidationBenchmarks.adminSavingsPerVendor;

                return {
                    totalSavings: totalSavings + adminSavings,
                    savingsRate: totalSavingsRate,
                    adminSavings,
                    strategicValue: totalSpend >= this.consolidationBenchmarks.volumeThreshold ? 'High' : 'Medium'
                };
            }

            // Identify category consolidation opportunities
            identifyCategoryConsolidationOpportunities(data) {
                const categoryVendors = {};

                // Group vendors by category
                data.forEach(row => {
                    const vendor = row.supplier || row.vendor || 'Unknown';
                    const category = row.category || 'Unknown';
                    const amount = parseFloat(row.amount) || 0;

                    if (!categoryVendors[category]) {
                        categoryVendors[category] = {};
                    }
                    if (!categoryVendors[category][vendor]) {
                        categoryVendors[category][vendor] = 0;
                    }
                    categoryVendors[category][vendor] += amount;
                });

                // Analyze consolidation opportunities within each category
                const categoryOpportunities = [];
                Object.entries(categoryVendors).forEach(([category, vendors]) => {
                    const vendorList = Object.entries(vendors)
                        .map(([vendor, spend]) => ({ vendor, spend }))
                        .sort((a, b) => b.spend - a.spend);

                    if (vendorList.length > 3) { // Only analyze categories with multiple vendors
                        const totalCategorySpend = vendorList.reduce((sum, v) => sum + v.spend, 0);
                        const topVendor = vendorList[0];
                        const tailVendors = vendorList.slice(3); // Vendors beyond top 3
                        const tailSpend = tailVendors.reduce((sum, v) => sum + v.spend, 0);

                        if (tailSpend > 5000) { // Only consider if tail spend is significant
                            const consolidationSavings = tailSpend * 0.15; // 15% savings on consolidated tail spend
                            const adminSavings = tailVendors.length * 1000; // $1000 admin savings per vendor

                            categoryOpportunities.push({
                                category,
                                totalVendors: vendorList.length,
                                totalSpend: totalCategorySpend,
                                topVendor: topVendor.vendor,
                                topVendorSpend: topVendor.spend,
                                tailVendorCount: tailVendors.length,
                                tailSpend,
                                consolidationSavings,
                                adminSavings,
                                totalSavings: consolidationSavings + adminSavings,
                                recommendation: this.generateCategoryRecommendation(vendorList.length, tailSpend, topVendor.spend)
                            });
                        }
                    }
                });

                return categoryOpportunities.sort((a, b) => b.totalSavings - a.totalSavings);
            }

            // Generate category-specific recommendations
            generateCategoryRecommendation(vendorCount, tailSpend, topVendorSpend) {
                if (vendorCount > 10 && tailSpend > 20000) {
                    return 'High Priority: Significant consolidation opportunity with multiple tail vendors';
                } else if (vendorCount > 6 && tailSpend > 10000) {
                    return 'Medium Priority: Moderate consolidation potential';
                } else if (topVendorSpend > tailSpend * 3) {
                    return 'Strategic Partnership: Consider expanding relationship with top vendor';
                } else {
                    return 'Low Priority: Limited consolidation benefits';
                }
            }

            // Generate geographic consolidation recommendations
            analyzeGeographicConsolidation(data) {
                const locationVendors = {};

                data.forEach(row => {
                    const vendor = row.supplier || row.vendor || 'Unknown';
                    const location = row.location || 'Unknown';
                    const amount = parseFloat(row.amount) || 0;

                    if (!locationVendors[location]) {
                        locationVendors[location] = {};
                    }
                    if (!locationVendors[location][vendor]) {
                        locationVendors[location][vendor] = 0;
                    }
                    locationVendors[location][vendor] += amount;
                });

                const geographicOpportunities = [];
                Object.entries(locationVendors).forEach(([location, vendors]) => {
                    const vendorList = Object.entries(vendors)
                        .map(([vendor, spend]) => ({ vendor, spend }))
                        .sort((a, b) => b.spend - a.spend);

                    if (vendorList.length > 2) {
                        const totalLocationSpend = vendorList.reduce((sum, v) => sum + v.spend, 0);
                        const consolidationSavings = totalLocationSpend * 0.08; // 8% savings for geographic consolidation

                        geographicOpportunities.push({
                            location,
                            vendorCount: vendorList.length,
                            totalSpend: totalLocationSpend,
                            topVendor: vendorList[0].vendor,
                            consolidationSavings,
                            recommendation: `Consider consolidating ${vendorList.length} vendors in ${location}`
                        });
                    }
                });

                return geographicOpportunities.sort((a, b) => b.consolidationSavings - a.consolidationSavings);
            }

            // Main consolidation analysis
            performConsolidationAnalysis(data) {
                const crossCategoryOpportunities = this.analyzeCrossCategoryOpportunities(data);
                const categoryOpportunities = this.identifyCategoryConsolidationOpportunities(data);
                const geographicOpportunities = this.analyzeGeographicConsolidation(data);

                // Calculate total savings potential
                const totalCrossCategorySavings = crossCategoryOpportunities.reduce((sum, opp) => sum + opp.consolidationPotential.totalSavings, 0);
                const totalCategorySavings = categoryOpportunities.reduce((sum, opp) => sum + opp.totalSavings, 0);
                const totalGeographicSavings = geographicOpportunities.reduce((sum, opp) => sum + opp.consolidationSavings, 0);

                return {
                    crossCategoryOpportunities,
                    categoryOpportunities,
                    geographicOpportunities,
                    summary: {
                        totalOpportunities: crossCategoryOpportunities.length + categoryOpportunities.length + geographicOpportunities.length,
                        totalSavingsPotential: totalCrossCategorySavings + totalCategorySavings + totalGeographicSavings,
                        crossCategorySavings: totalCrossCategorySavings,
                        categorySavings: totalCategorySavings,
                        geographicSavings: totalGeographicSavings,
                        topOpportunity: this.identifyTopOpportunity(crossCategoryOpportunities, categoryOpportunities, geographicOpportunities)
                    }
                };
            }

            // Identify the top consolidation opportunity
            identifyTopOpportunity(crossCategory, category, geographic) {
                const allOpportunities = [
                    ...crossCategory.map(opp => ({ type: 'Cross-Category', vendor: opp.vendor, savings: opp.consolidationPotential.totalSavings })),
                    ...category.map(opp => ({ type: 'Category', vendor: opp.category, savings: opp.totalSavings })),
                    ...geographic.map(opp => ({ type: 'Geographic', vendor: opp.location, savings: opp.consolidationSavings }))
                ];

                return allOpportunities.sort((a, b) => b.savings - a.savings)[0] || null;
            }
        }

        // Initialize vendor consolidation analyzer
        const vendorConsolidationAnalyzer = new VendorConsolidationAnalyzer();

        // Initialize seasonality analyzer
        const seasonalityAnalyzer = new SeasonalityAnalyzer();
        
        // AI Insights Engine
        class AIInsightsEngine {
            constructor() {
                this.insights = [];
                this.config = {
                    sensitivity: 'medium',
                    maxInsights: 20,
                    anomalyThreshold: 3, // 3 standard deviations
                    trendMinDataPoints: 3
                };
            }
            
            async analyzeData(data) {
                if (!data || data.length === 0) return [];
                
                this.insights = [];
                
                // Run different analysis types
                this.detectAnomalies(data);
                this.analyzeTrends(data);
                this.findPatterns(data);
                this.identifySavingsOpportunities(data);
                
                // Sort by priority, but ensure savings insights are included
                this.insights.sort((a, b) => {
                    // First priority: savings insights should always be near the top
                    if (a.type === 'savings' && b.type !== 'savings') return -1;
                    if (b.type === 'savings' && a.type !== 'savings') return 1;
                    
                    // Then sort by severity
                    const priorityScore = { high: 3, medium: 2, low: 1 };
                    return priorityScore[b.severity] - priorityScore[a.severity];
                });
                
                // Ensure we always include at least some of each type of insight
                const insightsByType = {
                    savings: this.insights.filter(i => i.type === 'savings'),
                    trend: this.insights.filter(i => i.type === 'trend'),
                    pattern: this.insights.filter(i => i.type === 'pattern'),
                    anomaly: this.insights.filter(i => i.type === 'anomaly')
                };
                
                // Reserve slots for each type (ensure at least 2 of each type if available)
                const reservedSlots = {
                    savings: Math.min(5, insightsByType.savings.length), // Up to 5 savings
                    trend: Math.min(3, insightsByType.trend.length),     // Up to 3 trends
                    pattern: Math.min(3, insightsByType.pattern.length), // Up to 3 patterns
                    anomaly: 0 // Anomalies get remaining slots
                };
                
                // Calculate remaining slots for anomalies
                const usedSlots = Object.values(reservedSlots).reduce((sum, count) => sum + count, 0);
                const remainingSlots = Math.max(0, this.config.maxInsights - usedSlots);
                reservedSlots.anomaly = Math.min(remainingSlots, insightsByType.anomaly.length);
                
                // Build final insights array with balanced distribution
                this.insights = [
                    ...insightsByType.savings.slice(0, reservedSlots.savings),
                    ...insightsByType.trend.slice(0, reservedSlots.trend),
                    ...insightsByType.pattern.slice(0, reservedSlots.pattern),
                    ...insightsByType.anomaly.slice(0, reservedSlots.anomaly)
                ];
                
                console.log('AI Insights: Distribution by type:', {
                    savings: insightsByType.savings.length,
                    trend: insightsByType.trend.length,
                    pattern: insightsByType.pattern.length,
                    anomaly: insightsByType.anomaly.length,
                    total: this.insights.length
                });
                console.log('AI Insights: Final insights generated:', this.insights);
                console.log('AI Insights: Savings insights:', this.insights.filter(i => i.type === 'savings'));
                
                return this.insights;
            }
            
            detectAnomalies(data) {
                // Statistical anomaly detection
                const amounts = data.map(row => row.amount);
                const mean = amounts.reduce((sum, val) => sum + val, 0) / amounts.length;
                const variance = amounts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amounts.length;
                const stdDev = Math.sqrt(variance);
                
                data.forEach((row, index) => {
                    const zScore = Math.abs((row.amount - mean) / stdDev);
                    
                    if (zScore > this.config.anomalyThreshold) {
                        this.insights.push({
                            id: `anomaly-${index}`,
                            type: 'anomaly',
                            severity: zScore > 4 ? 'high' : 'medium',
                            title: 'Unusual Spending Amount Detected',
                            summary: `Transaction with ${row.supplier} shows ${row.amount > mean ? 'unusually high' : 'unusually low'} spending of ${this.formatCurrency(row.amount)}`,
                            metrics: {
                                amount: this.formatCurrency(row.amount),
                                expectedRange: `${this.formatCurrency(mean - 2*stdDev)} - ${this.formatCurrency(mean + 2*stdDev)}`,
                                deviation: `${Math.round(zScore)} standard deviations`,
                                date: this.formatDate(row.date)
                            },
                            actions: [
                                {
                                    priority: 'immediate',
                                    action: 'Review transaction for accuracy',
                                    owner: 'Procurement Manager'
                                },
                                {
                                    priority: 'high',
                                    action: 'Verify approval process was followed',
                                    owner: 'Finance Team'
                                }
                            ],
                            data: row
                        });
                    }
                });
                
                // Detect new suppliers
                const supplierFirstSeen = {};
                data.forEach(row => {
                    if (!supplierFirstSeen[row.supplier]) {
                        supplierFirstSeen[row.supplier] = row.date;
                    }
                });
                
                const recentDate = new Date();
                recentDate.setMonth(recentDate.getMonth() - 1);
                
                Object.entries(supplierFirstSeen).forEach(([supplier, firstDate]) => {
                    if (new Date(firstDate) > recentDate) {
                        const supplierData = data.filter(row => row.supplier === supplier);
                        const totalSpend = supplierData.reduce((sum, row) => sum + row.amount, 0);
                        
                        if (totalSpend > mean * 2) {
                            this.insights.push({
                                id: `new-supplier-${supplier}`,
                                type: 'anomaly',
                                severity: 'high',
                                title: 'New Supplier with High Spending',
                                summary: `${supplier} is a new supplier with significant spending of ${this.formatCurrency(totalSpend)} in the first month`,
                                metrics: {
                                    totalSpend: this.formatCurrency(totalSpend),
                                    transactionCount: supplierData.length,
                                    avgTransaction: this.formatCurrency(totalSpend / supplierData.length),
                                    firstSeen: this.formatDate(firstDate)
                                },
                                actions: [
                                    {
                                        priority: 'immediate',
                                        action: 'Verify supplier onboarding compliance',
                                        owner: 'Vendor Management'
                                    },
                                    {
                                        priority: 'high',
                                        action: 'Review contract terms',
                                        owner: 'Legal Department'
                                    }
                                ]
                            });
                        }
                    }
                });
            }
            
            analyzeTrends(data) {
                console.log('AI Insights: analyzeTrends called with', data.length, 'rows');
                
                // Group by month
                const monthlyData = {};
                data.forEach(row => {
                    const date = new Date(row.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            total: 0,
                            count: 0,
                            categories: {}
                        };
                    }
                    
                    monthlyData[monthKey].total += row.amount;
                    monthlyData[monthKey].count++;
                    
                    if (!monthlyData[monthKey].categories[row.category]) {
                        monthlyData[monthKey].categories[row.category] = 0;
                    }
                    monthlyData[monthKey].categories[row.category] += row.amount;
                });
                
                const months = Object.keys(monthlyData).sort();
                console.log('AI Insights: Monthly data points:', months.length, 'months:', months);
                
                if (months.length >= this.config.trendMinDataPoints) {
                    // Overall spending trend
                    const values = months.map(m => monthlyData[m].total);
                    const trend = this.calculateTrend(values);
                    console.log('AI Insights: Overall trend calculated:', trend);
                    
                    if (Math.abs(trend.percentageChange) > 5) {
                        this.insights.push({
                            id: 'overall-trend',
                            type: 'trend',
                            severity: Math.abs(trend.percentageChange) > 20 ? 'high' : 'medium',
                            title: `Overall Spending ${trend.direction === 'up' ? 'Increasing' : 'Decreasing'}`,
                            summary: `Total spending has ${trend.direction === 'up' ? 'increased' : 'decreased'} by ${Math.abs(trend.percentageChange).toFixed(1)}% over the last ${months.length} months`,
                            metrics: {
                                startPeriod: months[0],
                                endPeriod: months[months.length - 1],
                                startAmount: this.formatCurrency(values[0]),
                                endAmount: this.formatCurrency(values[values.length - 1]),
                                averageMonthly: this.formatCurrency(values.reduce((a, b) => a + b, 0) / values.length)
                            },
                            actions: [
                                {
                                    priority: trend.direction === 'up' ? 'high' : 'medium',
                                    action: trend.direction === 'up' ? 'Review budget allocation' : 'Identify cost reduction successes',
                                    owner: 'Finance Director'
                                }
                            ]
                        });
                    }
                    
                    // Category trends
                    const categories = new Set();
                    Object.values(monthlyData).forEach(month => {
                        Object.keys(month.categories).forEach(cat => categories.add(cat));
                    });
                    
                    categories.forEach(category => {
                        const categoryValues = months.map(m => monthlyData[m].categories[category] || 0);
                        const categoryTrend = this.calculateTrend(categoryValues);
                        
                        if (Math.abs(categoryTrend.percentageChange) > 10) {
                            this.insights.push({
                                id: `category-trend-${category}`,
                                type: 'trend',
                                severity: Math.abs(categoryTrend.percentageChange) > 50 ? 'high' : 'medium',
                                title: `${category} Spending ${categoryTrend.direction === 'up' ? 'Surge' : 'Decline'}`,
                                summary: `${category} category spending has ${categoryTrend.direction === 'up' ? 'increased' : 'decreased'} by ${Math.abs(categoryTrend.percentageChange).toFixed(1)}%`,
                                metrics: {
                                    category: category,
                                    change: `${categoryTrend.percentageChange > 0 ? '+' : ''}${categoryTrend.percentageChange.toFixed(1)}%`,
                                    currentMonthly: this.formatCurrency(categoryValues[categoryValues.length - 1]),
                                    trend: categoryTrend.direction
                                },
                                actions: [
                                    {
                                        priority: 'medium',
                                        action: `Investigate ${category} spending changes`,
                                        owner: 'Category Manager'
                                    }
                                ]
                            });
                        }
                    });
                }
            }
            
            findPatterns(data) {
                console.log('AI Insights: findPatterns called with', data.length, 'rows');
                
                // Supplier concentration patterns
                const supplierSpend = {};
                const totalSpend = data.reduce((sum, row) => sum + row.amount, 0);
                
                data.forEach(row => {
                    if (!supplierSpend[row.supplier]) {
                        supplierSpend[row.supplier] = 0;
                    }
                    supplierSpend[row.supplier] += row.amount;
                });
                
                Object.entries(supplierSpend).forEach(([supplier, spend]) => {
                    const percentage = (spend / totalSpend) * 100;
                    
                    if (percentage > 15) {
                        this.insights.push({
                            id: `concentration-${supplier}`,
                            type: 'pattern',
                            severity: percentage > 30 ? 'high' : 'medium',
                            title: 'High Supplier Concentration Risk',
                            summary: `${supplier} accounts for ${percentage.toFixed(1)}% of total spending, creating dependency risk`,
                            metrics: {
                                supplier: supplier,
                                totalSpend: this.formatCurrency(spend),
                                percentage: `${percentage.toFixed(1)}%`,
                                transactions: data.filter(row => row.supplier === supplier).length
                            },
                            actions: [
                                {
                                    priority: 'high',
                                    action: 'Develop supplier diversification strategy',
                                    owner: 'Procurement Manager'
                                },
                                {
                                    priority: 'medium',
                                    action: 'Identify alternative suppliers',
                                    owner: 'Sourcing Team'
                                }
                            ]
                        });
                    }
                });
                
                // Seasonal patterns
                const monthlyTotals = {};
                data.forEach(row => {
                    const month = new Date(row.date).getMonth();
                    if (!monthlyTotals[month]) {
                        monthlyTotals[month] = 0;
                    }
                    monthlyTotals[month] += row.amount;
                });
                
                const avgMonthly = Object.values(monthlyTotals).reduce((a, b) => a + b, 0) / Object.keys(monthlyTotals).length;
                
                Object.entries(monthlyTotals).forEach(([month, total]) => {
                    const monthName = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][month];
                    const deviation = ((total - avgMonthly) / avgMonthly) * 100;
                    
                    if (Math.abs(deviation) > 30) {
                        this.insights.push({
                            id: `seasonal-${month}`,
                            type: 'pattern',
                            severity: 'low',
                            title: `${monthName} Spending Pattern`,
                            summary: `${monthName} shows ${deviation > 0 ? 'higher' : 'lower'} spending by ${Math.abs(deviation).toFixed(1)}% compared to monthly average`,
                            metrics: {
                                month: monthName,
                                spending: this.formatCurrency(total),
                                average: this.formatCurrency(avgMonthly),
                                deviation: `${deviation > 0 ? '+' : ''}${deviation.toFixed(1)}%`
                            },
                            actions: [
                                {
                                    priority: 'low',
                                    action: 'Plan budget accordingly for seasonal variations',
                                    owner: 'Finance Team'
                                }
                            ]
                        });
                    }
                });
                
                // Find recurring monthly charges (e.g., elevator maintenance)
                const supplierMonthly = {};
                data.forEach(row => {
                    const monthKey = new Date(row.date).toISOString().substring(0, 7);
                    const key = `${row.supplier}-${row.amount}`;
                    if (!supplierMonthly[key]) {
                        supplierMonthly[key] = {
                            supplier: row.supplier,
                            amount: row.amount,
                            months: new Set(),
                            category: row.category
                        };
                    }
                    supplierMonthly[key].months.add(monthKey);
                });
                
                Object.values(supplierMonthly).forEach(pattern => {
                    if (pattern.months.size >= 2) { // Lower threshold for recurring charges
                        this.insights.push({
                            id: `recurring-${pattern.supplier}-${pattern.amount}`,
                            type: 'pattern',
                            severity: 'medium',
                            title: 'Recurring Monthly Service Detected',
                            summary: `${pattern.supplier} has a recurring charge of ${this.formatCurrency(pattern.amount)} for ${pattern.months.size} months`,
                            metrics: {
                                supplier: pattern.supplier,
                                amount: this.formatCurrency(pattern.amount),
                                frequency: `${pattern.months.size} months`,
                                totalImpact: this.formatCurrency(pattern.amount * pattern.months.size),
                                category: pattern.category
                            },
                            actions: [
                                {
                                    priority: 'medium',
                                    action: 'Review contract for optimization opportunities',
                                    owner: 'Contract Manager'
                                }
                            ]
                        });
                    }
                });
                
                // Category spending patterns
                const categoryPatterns = {};
                data.forEach(row => {
                    if (!categoryPatterns[row.category]) {
                        categoryPatterns[row.category] = {
                            total: 0,
                            count: 0,
                            suppliers: new Set(),
                            subcategories: new Set()
                        };
                    }
                    categoryPatterns[row.category].total += row.amount;
                    categoryPatterns[row.category].count++;
                    categoryPatterns[row.category].suppliers.add(row.supplier);
                    if (row.subcategory) {
                        categoryPatterns[row.category].subcategories.add(row.subcategory);
                    }
                });
                
                Object.entries(categoryPatterns).forEach(([category, pattern]) => {
                    const avgTransaction = pattern.total / pattern.count;
                    
                    // Facilities-specific patterns
                    if (category === 'Facilities' && pattern.subcategories.size > 3) {
                        this.insights.push({
                            id: `facilities-diversity-${category}`,
                            type: 'pattern',
                            severity: 'low',
                            title: 'Diverse Facilities Management Services',
                            summary: `${category} encompasses ${pattern.subcategories.size} different service types from ${pattern.suppliers.size} suppliers`,
                            metrics: {
                                category: category,
                                serviceTypes: pattern.subcategories.size,
                                supplierCount: pattern.suppliers.size,
                                totalSpend: this.formatCurrency(pattern.total),
                                avgTransaction: this.formatCurrency(avgTransaction)
                            },
                            actions: [
                                {
                                    priority: 'low',
                                    action: 'Consider integrated facilities management approach',
                                    owner: 'Facilities Manager'
                                }
                            ]
                        });
                    }
                });
            }
            
            identifySavingsOpportunities(data) {
                console.log('AI Insights: identifySavingsOpportunities called with', data.length, 'rows');
                
                // Tail spend analysis
                const supplierSpend = {};
                data.forEach(row => {
                    if (!supplierSpend[row.supplier]) {
                        supplierSpend[row.supplier] = { total: 0, transactions: 0 };
                    }
                    supplierSpend[row.supplier].total += row.amount;
                    supplierSpend[row.supplier].transactions++;
                });
                
                console.log('AI Insights: Supplier spend analysis:', supplierSpend);
                
                const suppliers = Object.entries(supplierSpend)
                    .map(([supplier, data]) => ({ supplier, ...data }))
                    .sort((a, b) => a.total - b.total);
                
                const tailSuppliers = suppliers.slice(0, Math.floor(suppliers.length * 0.8));
                const tailSpend = tailSuppliers.reduce((sum, s) => sum + s.total, 0);
                const totalSpend = suppliers.reduce((sum, s) => sum + s.total, 0);
                const tailPercentage = (tailSpend / totalSpend) * 100;
                
                // Align with Tail Spend Analysis module thresholds
                // For smaller supplier counts, use more appropriate thresholds
                const minTailSuppliers = suppliers.length <= 5 ? 2 : 3;
                
                console.log('AI Insights: Tail analysis -', {
                    totalSuppliers: suppliers.length,
                    tailSuppliers: tailSuppliers.length,
                    minRequired: minTailSuppliers,
                    tailSpend: tailSpend,
                    totalSpend: totalSpend,
                    tailPercentage: tailPercentage
                });
                
                if (tailSuppliers.length >= minTailSuppliers && tailSpend > 0) {
                    const potentialSavings = tailSpend * 0.15; // 15% savings potential
                    console.log('AI Insights: Tail spend savings identified:', potentialSavings);
                    
                    this.insights.push({
                        id: 'tail-spend-opportunity',
                        type: 'savings',
                        severity: 'high',
                        title: 'Tail Spend Consolidation Opportunity',
                        summary: `${tailSuppliers.length} suppliers represent only ${tailPercentage.toFixed(1)}% of spend. Consolidation could save up to ${this.formatCurrency(potentialSavings)}`,
                        metrics: {
                            tailSuppliers: tailSuppliers.length,
                            tailSpend: this.formatCurrency(tailSpend),
                            percentage: `${tailPercentage.toFixed(1)}%`,
                            potentialSavings: this.formatCurrency(potentialSavings)
                        },
                        actions: [
                            {
                                priority: 'high',
                                action: 'Initiate vendor consolidation program',
                                owner: 'Procurement Director'
                            },
                            {
                                priority: 'medium',
                                action: 'Negotiate volume discounts with strategic suppliers',
                                owner: 'Sourcing Manager'
                            }
                        ],
                        savingsAmount: potentialSavings
                    });
                }
                
                // Category consolidation opportunities
                const categoryData = {};
                data.forEach(row => {
                    if (!categoryData[row.category]) {
                        categoryData[row.category] = {
                            suppliers: new Set(),
                            total: 0
                        };
                    }
                    categoryData[row.category].suppliers.add(row.supplier);
                    categoryData[row.category].total += row.amount;
                });
                
                Object.entries(categoryData).forEach(([category, data]) => {
                    // More realistic thresholds aligned with procurement best practices
                    if (data.suppliers.size > 2 && data.total > 1000) {
                        const potentialSavings = data.total * 0.10; // 10% savings potential
                        
                        this.insights.push({
                            id: `category-consolidation-${category}`,
                            type: 'savings',
                            severity: 'medium',
                            title: `${category} Supplier Rationalization`,
                            summary: `${category} has ${data.suppliers.size} suppliers. Reducing to 2-3 strategic partners could save ${this.formatCurrency(potentialSavings)}`,
                            metrics: {
                                category: category,
                                currentSuppliers: data.suppliers.size,
                                categorySpend: this.formatCurrency(data.total),
                                targetSuppliers: '2-3',
                                potentialSavings: this.formatCurrency(potentialSavings)
                            },
                            actions: [
                                {
                                    priority: 'medium',
                                    action: `Conduct ${category} supplier rationalization`,
                                    owner: 'Category Manager'
                                }
                            ],
                            savingsAmount: potentialSavings
                        });
                    }
                });
                
                // Additional savings opportunity: Micro-vendor consolidation (aligned with Tail Spend module)
                // Identify micro vendors (< $10K annual spend)
                const microVendors = suppliers.filter(s => s.total < 10000);
                const microSpend = microVendors.reduce((sum, s) => sum + s.total, 0);
                
                console.log('AI Insights: Micro-vendor analysis -', {
                    microVendors: microVendors.length,
                    microSpend: microSpend,
                    microVendorsList: microVendors
                });
                
                if (microVendors.length > 1 && microSpend > 0) {
                    const microSavings = microSpend * 0.15; // 15% savings on micro vendor consolidation
                    console.log('AI Insights: Micro-vendor savings identified:', microSavings);
                    
                    this.insights.push({
                        id: 'micro-vendor-consolidation',
                        type: 'savings',
                        severity: 'medium',
                        title: 'Micro-Vendor Consolidation Opportunity',
                        summary: `${microVendors.length} vendors with spend under $10K. Consolidation and process improvement could save ${this.formatCurrency(microSavings)}`,
                        metrics: {
                            microVendors: microVendors.length,
                            microSpend: this.formatCurrency(microSpend),
                            avgTransactionCost: this.formatCurrency(microSpend / microVendors.reduce((sum, v) => sum + v.transactions, 0)),
                            potentialSavings: this.formatCurrency(microSavings)
                        },
                        actions: [
                            {
                                priority: 'medium',
                                action: 'Implement P-Card program for small purchases',
                                owner: 'Procurement Manager'
                            },
                            {
                                priority: 'medium',
                                action: 'Consolidate micro-vendors to preferred suppliers',
                                owner: 'Category Manager'
                            }
                        ],
                        savingsAmount: microSavings
                    });
                }
                
                // Process optimization for small transactions (aligned with Tail Spend module)
                // This catches cases where we have many small transactions even if from few suppliers
                const transactionCounts = suppliers.map(s => s.transactions).reduce((sum, t) => sum + t, 0);
                const avgTransactionValue = totalSpend / transactionCounts;
                
                console.log('AI Insights: Transaction analysis -', {
                    totalTransactions: transactionCounts,
                    avgTransactionValue: avgTransactionValue,
                    totalSpend: totalSpend
                });
                
                // If average transaction is small and we have multiple transactions, there's process improvement opportunity
                if (avgTransactionValue < 500 && transactionCounts > 10 && totalSpend > 1000) {
                    const processSavings = totalSpend * 0.10; // 10% through process improvement
                    console.log('AI Insights: Process improvement savings identified:', processSavings);
                    
                    this.insights.push({
                        id: 'process-improvement-opportunity',
                        type: 'savings',
                        severity: 'medium',
                        title: 'Transaction Process Improvement Opportunity',
                        summary: `${transactionCounts} small transactions averaging ${this.formatCurrency(avgTransactionValue)}. Process improvements could save ${this.formatCurrency(processSavings)}`,
                        metrics: {
                            transactionCount: transactionCounts,
                            avgTransaction: this.formatCurrency(avgTransactionValue),
                            totalSpend: this.formatCurrency(totalSpend),
                            potentialSavings: this.formatCurrency(processSavings)
                        },
                        actions: [
                            {
                                priority: 'medium',
                                action: 'Implement procurement cards for small purchases',
                                owner: 'Finance Director'
                            },
                            {
                                priority: 'medium',
                                action: 'Establish blanket purchase orders',
                                owner: 'Procurement Manager'
                            }
                        ],
                        savingsAmount: processSavings
                    });
                }
                
                // If we still haven't found savings and there's reasonable spend, apply general tail spend logic
                const currentSavingsInsights = this.insights.filter(i => i.type === 'savings' && i.id.includes('opportunity'));
                if (currentSavingsInsights.length === 0 && totalSpend > 1000) {
                    // Apply general tail spend savings rate
                    const generalSavings = totalSpend * 0.10; // 10% general optimization
                    console.log('AI Insights: General optimization savings identified:', generalSavings);
                    
                    this.insights.push({
                        id: 'general-spend-optimization',
                        type: 'savings',
                        severity: 'low',
                        title: 'General Spend Optimization Opportunity',
                        summary: `Current spend of ${this.formatCurrency(totalSpend)} can be optimized through strategic sourcing and process improvements for savings of ${this.formatCurrency(generalSavings)}`,
                        metrics: {
                            currentSpend: this.formatCurrency(totalSpend),
                            supplierCount: suppliers.length,
                            potentialSavings: this.formatCurrency(generalSavings),
                            savingsPercentage: '10%'
                        },
                        actions: [
                            {
                                priority: 'low',
                                action: 'Conduct spend analysis and sourcing review',
                                owner: 'Procurement Team'
                            }
                        ],
                        savingsAmount: generalSavings
                    });
                }
            }
            
            calculateTrend(values) {
                if (values.length < 2) return { direction: 'stable', percentageChange: 0 };
                
                const firstValue = values[0];
                const lastValue = values[values.length - 1];
                const percentageChange = ((lastValue - firstValue) / firstValue) * 100;
                
                return {
                    direction: percentageChange > 0 ? 'up' : 'down',
                    percentageChange: percentageChange
                };
            }
            
            formatCurrency(amount) {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(amount);
            }
            
            formatDate(date) {
                return new Date(date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            }
            
            // Smart Search / Keyword Filtering
            processSmartSearch(query, insights) {
                if (!query || !insights || insights.length === 0) return insights;
                
                const queryLower = query.toLowerCase();
                let results = [...insights];
                
                // Define search patterns and their handlers
                const queryHandlers = [
                    // Type filters
                    {
                        patterns: ['saving', 'savings', 'cost reduction', 'opportunities'],
                        handler: () => results.filter(i => i.type === 'savings')
                    },
                    {
                        patterns: ['anomaly', 'anomalies', 'unusual', 'outlier'],
                        handler: () => results.filter(i => i.type === 'anomaly')
                    },
                    {
                        patterns: ['trend', 'trends', 'increasing', 'decreasing'],
                        handler: () => results.filter(i => i.type === 'trend')
                    },
                    {
                        patterns: ['pattern', 'patterns', 'recurring', 'regular'],
                        handler: () => results.filter(i => i.type === 'pattern')
                    },
                    
                    // Severity filters
                    {
                        patterns: ['high priority', 'urgent', 'critical', 'important'],
                        handler: () => results.filter(i => i.severity === 'high')
                    },
                    {
                        patterns: ['medium priority', 'moderate'],
                        handler: () => results.filter(i => i.severity === 'medium')
                    },
                    {
                        patterns: ['low priority', 'minor'],
                        handler: () => results.filter(i => i.severity === 'low')
                    },
                    
                    // Specific queries
                    {
                        patterns: ['top', 'highest', 'biggest'],
                        handler: () => {
                            if (queryLower.includes('saving')) {
                                return results
                                    .filter(i => i.type === 'savings' && i.savingsAmount)
                                    .sort((a, b) => b.savingsAmount - a.savingsAmount)
                                    .slice(0, 5);
                            }
                            return results.slice(0, 5);
                        }
                    },
                    {
                        patterns: ['recent', 'latest', 'new'],
                        handler: () => {
                            // Sort by metrics date if available, otherwise return newest insights
                            return results.sort((a, b) => {
                                const dateA = a.metrics?.date || a.id;
                                const dateB = b.metrics?.date || b.id;
                                return dateB.localeCompare(dateA);
                            }).slice(0, 10);
                        }
                    },
                    
                    // Category/supplier specific
                    {
                        patterns: ['facilities', 'facility'],
                        handler: () => results.filter(i => 
                            i.summary?.toLowerCase().includes('facilities') ||
                            i.metrics?.category?.toLowerCase().includes('facilities')
                        )
                    },
                    {
                        patterns: ['janitorial', 'cleaning'],
                        handler: () => results.filter(i => 
                            i.summary?.toLowerCase().includes('janitorial') ||
                            i.metrics?.category?.toLowerCase().includes('janitorial')
                        )
                    },
                    
                    // Action-based queries
                    {
                        patterns: ['action', 'actions', 'what should', 'what can', 'recommend'],
                        handler: () => {
                            if (queryLower.includes('immediate') || queryLower.includes('now')) {
                                return results.filter(i => 
                                    i.actions?.some(a => a.priority === 'immediate' || a.priority === 'high')
                                );
                            }
                            return results.filter(i => i.actions && i.actions.length > 0);
                        }
                    },
                    
                    // Amount-based queries
                    {
                        patterns: ['over', 'above', 'more than', 'greater than'],
                        handler: () => {
                            const match = queryLower.match(/(?:over|above|more than|greater than)\s*\$?([\d,]+)/);
                            if (match) {
                                const amount = parseFloat(match[1].replace(/,/g, ''));
                                return results.filter(i => {
                                    const value = i.savingsAmount || 
                                                 parseFloat(i.metrics?.totalSpend?.replace(/[$,]/g, '')) ||
                                                 parseFloat(i.metrics?.amount?.replace(/[$,]/g, '')) || 0;
                                    return value > amount;
                                });
                            }
                            return results;
                        }
                    },
                    
                    // Supplier-specific queries
                    {
                        patterns: ['supplier', 'vendor'],
                        handler: () => {
                            const words = queryLower.split(' ');
                            const supplierIndex = words.findIndex(w => w === 'supplier' || w === 'vendor');
                            if (supplierIndex < words.length - 1) {
                                const supplierName = words.slice(supplierIndex + 1).join(' ');
                                return results.filter(i => 
                                    i.summary?.toLowerCase().includes(supplierName) ||
                                    i.metrics?.supplier?.toLowerCase().includes(supplierName)
                                );
                            }
                            return results;
                        }
                    }
                ];
                
                // Process the query
                for (const handler of queryHandlers) {
                    if (handler.patterns.some(pattern => queryLower.includes(pattern))) {
                        results = handler.handler();
                        break;
                    }
                }
                
                // If no specific handler matched, try general text search
                if (results.length === insights.length) {
                    const searchTerms = queryLower.split(' ').filter(term => term.length > 2);
                    results = insights.filter(insight => {
                        const searchText = `${insight.title} ${insight.summary} ${JSON.stringify(insight.metrics)}`.toLowerCase();
                        return searchTerms.some(term => searchText.includes(term));
                    });
                }
                
                return results;
            }
        }
        
        // Initialize AI Insights Engine
        const aiInsightsEngine = new AIInsightsEngine();
        let currentInsights = [];
        let filteredInsights = [];
        
        // AI Assistant Configuration
        let aiAssistantConfig = {
            apiKey: localStorage.getItem('ai-assistant-api-key') || '',
            provider: localStorage.getItem('ai-assistant-provider') || 'openai', // 'openai' or 'anthropic'
            model: localStorage.getItem('ai-assistant-model') || 'gpt-4-turbo-preview'
        };

        // Safe element getter to prevent null reference errors
        function safeGetElement(id) {
            const element = document.getElementById(id);
            if (!element) {
                debugLog(`Element with id '${id}' not found`);
            }
            return element;
        }

        function debugLog(message, data = null) {
            if (debugMode) {
                console.log(message, data);
                const debugPanel = safeGetElement('debugPanel');
                if (debugPanel) {
                    const timestamp = new Date().toLocaleTimeString();
                    const logEntry = `[${timestamp}] ${message}`;
                    debugPanel.innerHTML += logEntry + (data ? '\n' + JSON.stringify(data, null, 2) : '') + '\n\n';
                    debugPanel.scrollTop = debugPanel.scrollHeight;
                }
            }
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            const debugPanel = safeGetElement('debugPanel');
            if (debugPanel) {
                debugPanel.style.display = debugMode ? 'block' : 'none';
                if (debugMode) {
                    debugPanel.innerHTML = 'Debug mode enabled\n\n';
                }
            }
            console.log('Debug mode:', debugMode ? 'ON' : 'OFF');
        }

        // Predictive Analytics Analyzer Class
        class PredictiveAnalyticsAnalyzer {
            constructor() {
                this.forecastingBenchmarks = {
                    minDataPoints: 6,           // Minimum months of data for reliable forecasting
                    forecastPeriods: 12,        // Number of months to forecast ahead
                    confidenceInterval: 0.95,   // 95% confidence interval
                    trendSmoothingFactor: 0.3,  // Exponential smoothing factor
                    seasonalSmoothingFactor: 0.2 // Seasonal smoothing factor
                };

                this.scenarioFactors = {
                    inflation: { min: -0.05, max: 0.15, default: 0.03 },      // -5% to 15% inflation
                    demandChange: { min: -0.30, max: 0.50, default: 0.00 },   // -30% to 50% demand change
                    marketGrowth: { min: -0.20, max: 0.25, default: 0.05 },   // -20% to 25% market growth
                    contractOptimization: { min: 0.00, max: 0.20, default: 0.08 } // 0% to 20% contract optimization
                };
            }

            // Main forecasting analysis function
            performForecastingAnalysis(data, seasonalityData = null) {
                try {
                    console.log('=== PERFORM FORECASTING ANALYSIS DEBUG ===');
                    console.log('Input data length:', data ? data.length : 'null');
                    console.log('Input data sample:', data ? data.slice(0, 2) : 'no data');
                    console.log('seasonalityData:', seasonalityData);

                    if (!data || data.length === 0) {
                        console.log('No data provided to performForecastingAnalysis');
                        return null;
                    }

                    console.log('Preparing time series data...');
                    const timeSeriesData = this.prepareTimeSeriesData(data);
                    console.log('Time series data prepared:', timeSeriesData);
                    console.log('Monthly data points:', Object.keys(timeSeriesData.monthly).length);
                    console.log('Category data points:', Object.keys(timeSeriesData.categoryMonthly).length);
                    console.log('Supplier data points:', Object.keys(timeSeriesData.supplierMonthly).length);

                    if (Object.keys(timeSeriesData.monthly).length < this.forecastingBenchmarks.minDataPoints) {
                        console.log('Insufficient monthly data points for forecasting:', Object.keys(timeSeriesData.monthly).length, 'minimum required:', this.forecastingBenchmarks.minDataPoints);
                        return null;
                    }

                    console.log('Generating category forecasts...');
                    const categoryForecasts = this.generateCategoryForecasts(timeSeriesData, seasonalityData);
                    console.log('Category forecasts generated:', Object.keys(categoryForecasts).length, 'categories');

                    console.log('Generating supplier forecasts...');
                    const supplierForecasts = this.generateSupplierForecasts(timeSeriesData);
                    console.log('Supplier forecasts generated:', Object.keys(supplierForecasts).length, 'suppliers');

                    console.log('Generating total spend forecast...');
                    const totalSpendForecast = this.generateTotalSpendForecast(timeSeriesData, seasonalityData);
                    console.log('Total spend forecast generated:', totalSpendForecast ? 'yes' : 'no');

                    console.log('Generating accuracy metrics...');
                    const accuracyMetrics = this.generateAccuracyMetrics(categoryForecasts, supplierForecasts);
                    console.log('Accuracy metrics generated:', accuracyMetrics);

                    console.log('Generating scenario analysis...');
                    const scenarioAnalysis = this.generateScenarioAnalysis(totalSpendForecast, categoryForecasts);
                    console.log('Scenario analysis generated:', scenarioAnalysis ? Object.keys(scenarioAnalysis).length + ' scenarios' : 'no scenarios');

                    const result = {
                        categoryForecasts,
                        supplierForecasts,
                        totalSpendForecast,
                        accuracyMetrics,
                        scenarioAnalysis,
                        summary: this.generateForecastSummary(categoryForecasts, totalSpendForecast, scenarioAnalysis)
                    };

                    console.log('Final result summary:', {
                        categoryCount: Object.keys(categoryForecasts).length,
                        supplierCount: Object.keys(supplierForecasts).length,
                        hasTotalForecast: !!totalSpendForecast,
                        hasScenarios: !!scenarioAnalysis,
                        hasAccuracy: !!accuracyMetrics
                    });
                    console.log('=== PERFORM FORECASTING ANALYSIS DEBUG END ===');

                    return result;
                } catch (error) {
                    console.error('Error in forecasting analysis:', error);
                    console.error('Error stack:', error.stack);
                    return null;
                }
            }

            // Prepare time series data from raw procurement data
            prepareTimeSeriesData(data) {
                const monthlyData = {};
                const categoryMonthlyData = {};
                const supplierMonthlyData = {};

                console.log('=== PREPARE TIME SERIES DATA DEBUG ===');
                console.log('Processing', data.length, 'rows');

                let processedRows = 0;
                let skippedRows = 0;
                const uniqueYearMonths = new Set();

                data.forEach((row, index) => {
                    // Try multiple possible date field names, prioritizing "Transaction Date"
                    let dateValue = row['Transaction Date'] || row.date || row.Date || row.transaction_date || row.transactionDate ||
                        row.purchase_date || row.purchaseDate || row.invoice_date || row.invoiceDate;

                    if (!dateValue) {
                        if (index < 5) console.warn('No date field found in row:', row);
                        skippedRows++;
                        return; // Skip this row if no date is found
                    }

                    // Custom parsing for MM/DD/YYYY format
                    let date;
                    if (typeof dateValue === 'string' && dateValue.includes('/')) {
                        // Handle MM/DD/YYYY or M/D/YYYY format
                        const parts = dateValue.split('/');
                        if (parts.length === 3) {
                            const month = parseInt(parts[0]) - 1; // JavaScript months are 0-indexed
                            const day = parseInt(parts[1]);
                            const year = parseInt(parts[2]);
                            date = new Date(year, month, day);
                        } else {
                            date = new Date(dateValue);
                        }
                    } else {
                        date = new Date(dateValue);
                    }

                    // Check if date is valid
                    if (isNaN(date.getTime())) {
                        if (index < 5) console.warn('Invalid date found:', dateValue, 'parsed as:', date);
                        skippedRows++;
                        return; // Skip this row if date is invalid
                    }

                    const yearMonth = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    uniqueYearMonths.add(yearMonth);

                    // Log first few rows for debugging
                    if (index < 10) {
                        console.log(`Row ${index}: dateValue="${dateValue}", parsed date="${date.toISOString()}", yearMonth="${yearMonth}"`);
                    }

                    const category = row.category || row.Category || row['Category'] || 'Unknown';
                    const supplier = row.supplier || row.Supplier || row.vendor || row.Vendor || row['Supplier'] || 'Unknown';
                    const amount = parseFloat(row.amount || row.Amount || row.spend || row.Spend || row.value || row.Value || row['Amount'] || row['Spend']) || 0;

                    // Total monthly data
                    if (!monthlyData[yearMonth]) {
                        monthlyData[yearMonth] = { spend: 0, transactions: 0, date: date };
                        console.log(`Created new month entry: ${yearMonth}`);
                    }
                    monthlyData[yearMonth].spend += amount;
                    monthlyData[yearMonth].transactions += 1;

                    // Category monthly data
                    if (!categoryMonthlyData[category]) {
                        categoryMonthlyData[category] = {};
                    }
                    if (!categoryMonthlyData[category][yearMonth]) {
                        categoryMonthlyData[category][yearMonth] = { spend: 0, transactions: 0, date: date };
                    }
                    categoryMonthlyData[category][yearMonth].spend += amount;
                    categoryMonthlyData[category][yearMonth].transactions += 1;

                    // Supplier monthly data (top suppliers only)
                    if (!supplierMonthlyData[supplier]) {
                        supplierMonthlyData[supplier] = {};
                    }
                    if (!supplierMonthlyData[supplier][yearMonth]) {
                        supplierMonthlyData[supplier][yearMonth] = { spend: 0, transactions: 0, date: date };
                    }
                    supplierMonthlyData[supplier][yearMonth].spend += amount;
                    supplierMonthlyData[supplier][yearMonth].transactions += 1;

                    processedRows++;
                });

                console.log('=== TIME SERIES PROCESSING SUMMARY ===');
                console.log('Total rows processed:', processedRows);
                console.log('Rows skipped (no/invalid date):', skippedRows);
                console.log('Unique year-months found:', Array.from(uniqueYearMonths).sort());
                console.log('Monthly data keys:', Object.keys(monthlyData).sort());
                console.log('Monthly data summary:', Object.entries(monthlyData).map(([month, data]) => ({
                    month,
                    spend: data.spend,
                    transactions: data.transactions
                })));
                console.log('=== END TIME SERIES DEBUG ===');

                return {
                    monthly: monthlyData,
                    categoryMonthly: categoryMonthlyData,
                    supplierMonthly: supplierMonthlyData
                };
            }

            // Generate category-level forecasts
            generateCategoryForecasts(timeSeriesData, seasonalityData) {
                const categoryForecasts = {};

                Object.entries(timeSeriesData.categoryMonthly).forEach(([category, monthlyData]) => {
                    const dataPoints = Object.keys(monthlyData).length;

                    if (dataPoints >= this.forecastingBenchmarks.minDataPoints) {
                        const sortedData = Object.entries(monthlyData)
                            .sort(([a], [b]) => new Date(a) - new Date(b))
                            .map(([month, data]) => ({ month, ...data }));

                        // Get seasonality data for this category if available
                        const categorySeasonality = seasonalityData?.categoryResults?.[category];

                        const forecast = this.generateTimeSeriesForecast(sortedData, categorySeasonality);

                        categoryForecasts[category] = {
                            historical: sortedData,
                            forecast: forecast,
                            totalHistoricalSpend: sortedData.reduce((sum, d) => sum + d.spend, 0),
                            projectedAnnualSpend: forecast.reduce((sum, d) => sum + d.spend, 0),
                            growthRate: this.calculateGrowthRate(sortedData),
                            confidence: this.calculateForecastConfidence(sortedData, categorySeasonality)
                        };
                    }
                });

                return categoryForecasts;
            }

            // Generate supplier-level forecasts (top suppliers only)
            generateSupplierForecasts(timeSeriesData) {
                const supplierForecasts = {};

                // Calculate total spend per supplier to identify top suppliers
                const supplierTotals = {};
                Object.entries(timeSeriesData.supplierMonthly).forEach(([supplier, monthlyData]) => {
                    supplierTotals[supplier] = Object.values(monthlyData).reduce((sum, d) => sum + d.spend, 0);
                });

                // Get top 10 suppliers by spend
                const topSuppliers = Object.entries(supplierTotals)
                    .sort(([, a], [, b]) => b - a)
                    .slice(0, 10)
                    .map(([supplier]) => supplier);

                topSuppliers.forEach(supplier => {
                    const monthlyData = timeSeriesData.supplierMonthly[supplier];
                    const dataPoints = Object.keys(monthlyData).length;

                    if (dataPoints >= this.forecastingBenchmarks.minDataPoints) {
                        const sortedData = Object.entries(monthlyData)
                            .sort(([a], [b]) => new Date(a) - new Date(b))
                            .map(([month, data]) => ({ month, ...data }));

                        const forecast = this.generateTimeSeriesForecast(sortedData);

                        supplierForecasts[supplier] = {
                            historical: sortedData,
                            forecast: forecast,
                            totalHistoricalSpend: sortedData.reduce((sum, d) => sum + d.spend, 0),
                            projectedAnnualSpend: forecast.reduce((sum, d) => sum + d.spend, 0),
                            growthRate: this.calculateGrowthRate(sortedData),
                            riskLevel: this.assessSupplierRisk(sortedData)
                        };
                    }
                });

                return supplierForecasts;
            }

            // Generate total spend forecast
            generateTotalSpendForecast(timeSeriesData, seasonalityData) {
                const monthlyData = timeSeriesData.monthly;
                const dataPoints = Object.keys(monthlyData).length;

                if (dataPoints < this.forecastingBenchmarks.minDataPoints) {
                    return null;
                }

                const sortedData = Object.entries(monthlyData)
                    .sort(([a], [b]) => new Date(a) - new Date(b))
                    .map(([month, data]) => ({ month, ...data }));

                const forecast = this.generateTimeSeriesForecast(sortedData, null, true);

                return {
                    historical: sortedData,
                    forecast: forecast,
                    totalHistoricalSpend: sortedData.reduce((sum, d) => sum + d.spend, 0),
                    projectedAnnualSpend: forecast.reduce((sum, d) => sum + d.spend, 0),
                    growthRate: this.calculateGrowthRate(sortedData),
                    confidence: this.calculateForecastConfidence(sortedData)
                };
            }

            // Core time series forecasting using exponential smoothing with trend and seasonality
            generateTimeSeriesForecast(historicalData, seasonalityData = null, isTotal = false) {
                const forecast = [];
                const spendValues = historicalData.map(d => d.spend);

                // Initialize exponential smoothing parameters
                let level = spendValues[0];
                let trend = spendValues.length > 1 ? spendValues[1] - spendValues[0] : 0;
                const seasonalPeriod = 12; // Monthly seasonality

                // Calculate seasonal indices if seasonality data is available
                let seasonalIndices = new Array(seasonalPeriod).fill(1);
                if (seasonalityData && seasonalityData.seasonalIndices) {
                    for (let i = 1; i <= 12; i++) {
                        if (seasonalityData.seasonalIndices[i]) {
                            seasonalIndices[i - 1] = seasonalityData.seasonalIndices[i].index / 100;
                        }
                    }
                }

                // Apply exponential smoothing to historical data
                for (let i = 1; i < spendValues.length; i++) {
                    const prevLevel = level;
                    level = this.forecastingBenchmarks.trendSmoothingFactor * spendValues[i] +
                        (1 - this.forecastingBenchmarks.trendSmoothingFactor) * (level + trend);
                    trend = this.forecastingBenchmarks.seasonalSmoothingFactor * (level - prevLevel) +
                        (1 - this.forecastingBenchmarks.seasonalSmoothingFactor) * trend;
                }

                // Generate future forecasts
                const lastDate = new Date(historicalData[historicalData.length - 1].month + '-01');

                for (let i = 1; i <= this.forecastingBenchmarks.forecastPeriods; i++) {
                    const forecastDate = new Date(lastDate);
                    forecastDate.setMonth(forecastDate.getMonth() + i);

                    const seasonalIndex = seasonalIndices[(forecastDate.getMonth()) % seasonalPeriod];
                    const baseSpend = level + (trend * i);
                    const seasonalSpend = baseSpend * seasonalIndex;

                    // Add some randomness for confidence intervals
                    const variance = this.calculateVariance(spendValues);
                    const confidenceRange = Math.sqrt(variance) * 1.96; // 95% confidence interval

                    forecast.push({
                        month: `${forecastDate.getFullYear()}-${String(forecastDate.getMonth() + 1).padStart(2, '0')}`,
                        spend: Math.max(0, seasonalSpend),
                        lowerBound: Math.max(0, seasonalSpend - confidenceRange),
                        upperBound: seasonalSpend + confidenceRange,
                        confidence: this.calculatePeriodConfidence(i),
                        date: forecastDate
                    });
                }

                return forecast;
            }

            // Calculate growth rate from historical data
            calculateGrowthRate(historicalData) {
                if (historicalData.length < 2) return 0;

                const firstPeriod = historicalData.slice(0, Math.floor(historicalData.length / 2));
                const secondPeriod = historicalData.slice(Math.floor(historicalData.length / 2));

                const firstAvg = firstPeriod.reduce((sum, d) => sum + d.spend, 0) / firstPeriod.length;
                const secondAvg = secondPeriod.reduce((sum, d) => sum + d.spend, 0) / secondPeriod.length;

                return firstAvg > 0 ? ((secondAvg - firstAvg) / firstAvg) * 100 : 0;
            }

            // Calculate forecast confidence based on data quality and patterns
            calculateForecastConfidence(historicalData, seasonalityData = null) {
                let confidence = 0.7; // Base confidence

                // Adjust based on data points
                if (historicalData.length >= 12) confidence += 0.15;
                else if (historicalData.length >= 6) confidence += 0.05;

                // Adjust based on data consistency
                const spendValues = historicalData.map(d => d.spend);
                const variance = this.calculateVariance(spendValues);
                const mean = spendValues.reduce((sum, val) => sum + val, 0) / spendValues.length;
                const coefficientOfVariation = Math.sqrt(variance) / mean;

                if (coefficientOfVariation < 0.3) confidence += 0.1;
                else if (coefficientOfVariation > 0.7) confidence -= 0.1;

                // Adjust based on seasonality strength
                if (seasonalityData && seasonalityData.seasonalityStrength > 20) {
                    confidence += 0.05;
                }

                return Math.min(0.95, Math.max(0.5, confidence));
            }

            // Calculate period-specific confidence (decreases over time)
            calculatePeriodConfidence(period) {
                const baseConfidence = 0.85;
                const decayRate = 0.02;
                return Math.max(0.5, baseConfidence - (period * decayRate));
            }

            // Calculate variance for confidence intervals
            calculateVariance(values) {
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            }

            // Assess supplier risk based on spend volatility
            assessSupplierRisk(historicalData) {
                const spendValues = historicalData.map(d => d.spend);
                const variance = this.calculateVariance(spendValues);
                const mean = spendValues.reduce((sum, val) => sum + val, 0) / spendValues.length;
                const coefficientOfVariation = Math.sqrt(variance) / mean;

                if (coefficientOfVariation > 0.5) return 'High';
                else if (coefficientOfVariation > 0.3) return 'Medium';
                else return 'Low';
            }

            // Generate scenario analysis
            generateScenarioAnalysis(totalSpendForecast, categoryForecasts) {
                if (!totalSpendForecast) return null;

                const baselineSpend = totalSpendForecast.projectedAnnualSpend;
                const scenarios = {};

                // Define scenario combinations
                const scenarioDefinitions = {
                    conservative: {
                        name: 'Conservative Growth',
                        description: 'Low inflation, minimal demand growth, moderate contract optimization',
                        factors: { inflation: 0.02, demandChange: 0.02, marketGrowth: 0.02, contractOptimization: 0.05 }
                    },
                    baseline: {
                        name: 'Baseline Forecast',
                        description: 'Expected inflation, stable demand, standard market growth',
                        factors: { inflation: 0.03, demandChange: 0.00, marketGrowth: 0.05, contractOptimization: 0.08 }
                    },
                    optimistic: {
                        name: 'Optimistic Scenario',
                        description: 'Controlled inflation, demand growth, strong contract optimization',
                        factors: { inflation: 0.025, demandChange: 0.10, marketGrowth: 0.08, contractOptimization: 0.12 }
                    },
                    challenging: {
                        name: 'Challenging Environment',
                        description: 'High inflation, demand volatility, limited optimization opportunities',
                        factors: { inflation: 0.08, demandChange: -0.05, marketGrowth: 0.02, contractOptimization: 0.03 }
                    }
                };

                Object.entries(scenarioDefinitions).forEach(([key, scenario]) => {
                    const adjustedSpend = this.applyScenarioFactors(baselineSpend, scenario.factors);
                    const categoryImpacts = this.calculateCategoryScenarioImpacts(categoryForecasts, scenario.factors);

                    scenarios[key] = {
                        ...scenario,
                        projectedSpend: adjustedSpend,
                        spendChange: adjustedSpend - baselineSpend,
                        percentageChange: ((adjustedSpend - baselineSpend) / baselineSpend) * 100,
                        categoryImpacts: categoryImpacts,
                        riskLevel: this.assessScenarioRisk(scenario.factors)
                    };
                });

                return scenarios;
            }

            // Apply scenario factors to baseline spend
            applyScenarioFactors(baselineSpend, factors) {
                let adjustedSpend = baselineSpend;

                // Apply inflation
                adjustedSpend *= (1 + factors.inflation);

                // Apply demand change
                adjustedSpend *= (1 + factors.demandChange);

                // Apply market growth
                adjustedSpend *= (1 + factors.marketGrowth);

                // Apply contract optimization (savings)
                adjustedSpend *= (1 - factors.contractOptimization);

                return adjustedSpend;
            }

            // Calculate category-specific scenario impacts
            calculateCategoryScenarioImpacts(categoryForecasts, factors) {
                const impacts = {};

                Object.entries(categoryForecasts).forEach(([category, forecast]) => {
                    const baselineSpend = forecast.projectedAnnualSpend;
                    const adjustedSpend = this.applyScenarioFactors(baselineSpend, factors);

                    impacts[category] = {
                        baselineSpend: baselineSpend,
                        adjustedSpend: adjustedSpend,
                        impact: adjustedSpend - baselineSpend,
                        percentageImpact: ((adjustedSpend - baselineSpend) / baselineSpend) * 100
                    };
                });

                return impacts;
            }

            // Assess scenario risk level
            assessScenarioRisk(factors) {
                const riskScore = Math.abs(factors.inflation - 0.03) * 2 +
                    Math.abs(factors.demandChange) * 1.5 +
                    Math.abs(factors.marketGrowth - 0.05) * 1 +
                    Math.abs(factors.contractOptimization - 0.08) * 0.5;

                if (riskScore > 0.15) return 'High';
                else if (riskScore > 0.08) return 'Medium';
                else return 'Low';
            }

            // Calculate accuracy metrics for historical forecasts
            calculateAccuracyMetrics(timeSeriesData) {
                // This would typically involve backtesting, but for now we'll provide estimated metrics
                return {
                    meanAbsolutePercentageError: 12.5, // Estimated 12.5% MAPE
                    forecastAccuracy: 87.5, // 87.5% accuracy
                    confidenceLevel: 85, // 85% confidence in forecasts
                    dataQuality: this.assessDataQuality(timeSeriesData)
                };
            }

            // Assess data quality for forecasting
            assessDataQuality(timeSeriesData) {
                const monthlyDataPoints = Object.keys(timeSeriesData.monthly).length;
                const categoryCount = Object.keys(timeSeriesData.categoryMonthly).length;

                let qualityScore = 0;

                // Data volume
                if (monthlyDataPoints >= 12) qualityScore += 30;
                else if (monthlyDataPoints >= 6) qualityScore += 20;
                else qualityScore += 10;

                // Data diversity
                if (categoryCount >= 10) qualityScore += 25;
                else if (categoryCount >= 5) qualityScore += 15;
                else qualityScore += 5;

                // Data consistency (simplified check)
                const spendValues = Object.values(timeSeriesData.monthly).map(d => d.spend);
                const hasZeros = spendValues.some(val => val === 0);
                if (!hasZeros) qualityScore += 20;

                // Data recency
                const latestDate = new Date(Math.max(...Object.keys(timeSeriesData.monthly).map(d => new Date(d + '-01'))));
                const monthsOld = (new Date() - latestDate) / (1000 * 60 * 60 * 24 * 30);
                if (monthsOld <= 1) qualityScore += 25;
                else if (monthsOld <= 3) qualityScore += 15;
                else qualityScore += 5;

                if (qualityScore >= 80) return 'Excellent';
                else if (qualityScore >= 60) return 'Good';
                else if (qualityScore >= 40) return 'Fair';
                else return 'Poor';
            }

            // Generate forecast summary
            generateForecastSummary(categoryForecasts, totalSpendForecast, scenarioAnalysis) {
                const categoryCount = Object.keys(categoryForecasts).length;
                const totalProjectedSpend = totalSpendForecast ? totalSpendForecast.projectedAnnualSpend : 0;
                const totalHistoricalSpend = totalSpendForecast ? totalSpendForecast.totalHistoricalSpend : 0;
                const overallGrowthRate = totalSpendForecast ? totalSpendForecast.growthRate : 0;

                // Find highest growth categories
                const categoryGrowthRates = Object.entries(categoryForecasts)
                    .map(([category, forecast]) => ({ category, growthRate: forecast.growthRate }))
                    .sort((a, b) => b.growthRate - a.growthRate);

                const highestGrowthCategory = categoryGrowthRates[0];
                const lowestGrowthCategory = categoryGrowthRates[categoryGrowthRates.length - 1];

                // Scenario range
                const scenarioRange = scenarioAnalysis ? {
                    min: Math.min(...Object.values(scenarioAnalysis).map(s => s.projectedSpend)),
                    max: Math.max(...Object.values(scenarioAnalysis).map(s => s.projectedSpend))
                } : null;

                return {
                    totalProjectedSpend,
                    totalHistoricalSpend,
                    projectedGrowth: totalProjectedSpend - totalHistoricalSpend,
                    projectedGrowthPercentage: totalHistoricalSpend > 0 ? ((totalProjectedSpend - totalHistoricalSpend) / totalHistoricalSpend) * 100 : 0,
                    overallGrowthRate,
                    categoryCount,
                    highestGrowthCategory: highestGrowthCategory ? highestGrowthCategory.category : 'N/A',
                    highestGrowthRate: highestGrowthCategory ? highestGrowthCategory.growthRate : 0,
                    lowestGrowthCategory: lowestGrowthCategory ? lowestGrowthCategory.category : 'N/A',
                    lowestGrowthRate: lowestGrowthCategory ? lowestGrowthCategory.growthRate : 0,
                    scenarioRange,
                    forecastPeriod: this.forecastingBenchmarks.forecastPeriods
                };
            }

            // Generate accuracy metrics for forecasting models
            generateAccuracyMetrics(categoryForecasts, supplierForecasts) {
                try {
                    // Calculate data quality score based on available data
                    const totalDataPoints = this.monthlyDataPoints || 0;
                    const categoryCount = categoryForecasts ? Object.keys(categoryForecasts).length : 0;
                    const supplierCount = supplierForecasts ? Object.keys(supplierForecasts).length : 0;

                    // Base data quality assessment
                    let dataQualityScore = 70; // Base score
                    if (totalDataPoints >= 12) dataQualityScore += 15; // Full year of data
                    if (categoryCount >= 2) dataQualityScore += 10; // Multiple categories
                    if (supplierCount >= 5) dataQualityScore += 5; // Multiple suppliers

                    const dataQuality = dataQualityScore >= 90 ? 'Excellent' :
                        dataQualityScore >= 80 ? 'Good' :
                            dataQualityScore >= 70 ? 'Fair' : 'Poor';

                    // Return flat structure expected by display function
                    const metrics = {
                        forecastAccuracy: Math.min(95, dataQualityScore + 10), // Forecast accuracy percentage
                        meanAbsolutePercentageError: Math.max(5, 25 - (dataQualityScore - 70) * 0.5), // MAPE
                        confidenceLevel: 95, // Statistical confidence level
                        dataQuality: dataQuality,

                        // Additional nested structure for other uses
                        detailed: {
                            dataQuality: {
                                score: dataQualityScore,
                                factors: [
                                    'Historical data completeness',
                                    'Date consistency',
                                    'Spend pattern regularity'
                                ]
                            },
                            forecastAccuracy: {
                                expectedMAPE: Math.max(5, 25 - (dataQualityScore - 70) * 0.5),
                                confidenceLevel: 95,
                                methodology: 'Exponential Smoothing with Seasonality'
                            },
                            modelReliability: {
                                categoryModels: categoryCount,
                                supplierModels: supplierCount,
                                totalDataPoints: totalDataPoints
                            },
                            recommendations: [
                                'Review forecasts monthly for accuracy',
                                'Update models with new data quarterly',
                                'Monitor seasonal pattern changes'
                            ]
                        }
                    };

                    return metrics;
                } catch (error) {
                    console.error('Error generating accuracy metrics:', error);
                    return {
                        forecastAccuracy: 75,
                        meanAbsolutePercentageError: 20,
                        confidenceLevel: 90,
                        dataQuality: 'Fair',
                        detailed: {
                            dataQuality: { score: 70, factors: ['Basic data validation'] },
                            forecastAccuracy: { expectedMAPE: 20, confidenceLevel: 90, methodology: 'Basic forecasting' },
                            modelReliability: { categoryModels: 0, supplierModels: 0, totalDataPoints: 0 },
                            recommendations: ['Improve data quality for better forecasting']
                        }
                    };
                }
            }
        }

        // Initialize predictive analytics analyzer
        const predictiveAnalyticsAnalyzer = new PredictiveAnalyticsAnalyzer();

        // Tail Spend Analysis Class
        class TailSpendAnalyzer {
            constructor() {
                this.industryBenchmarks = {
                    vendorConsolidation: 0.15, // 15% savings on micro vendors
                    processImprovement: 0.10,  // 10% savings on tail spend
                    pcardImplementation: 50,   // $50 per transaction
                    contractOptimization: 0.12 // 12% savings on small vendors
                };

                this.segmentThresholds = {
                    micro: 10000,    // < $10K
                    small: 50000     // $10K - $50K, > $50K = mid-tail
                };

                this.riskFactors = {
                    singleSource: 0.3,
                    lowVolume: 0.2,
                    irregularSpend: 0.25,
                    newVendor: 0.15,
                    criticalCategory: 0.1
                };
            }

            // Perform comprehensive Pareto analysis
            performParetoAnalysis(data) {
                // Aggregate spend by vendor
                const vendorSpend = {};
                const vendorTransactions = {};

                data.forEach(row => {
                    const vendor = row.supplier || row.vendor || 'Unknown';
                    const amount = parseFloat(row.amount) || 0;

                    if (!vendorSpend[vendor]) {
                        vendorSpend[vendor] = 0;
                        vendorTransactions[vendor] = 0;
                    }

                    vendorSpend[vendor] += amount;
                    vendorTransactions[vendor]++;
                });

                // Sort vendors by spend (descending)
                const sortedVendors = Object.entries(vendorSpend)
                    .map(([vendor, spend]) => ({
                        vendor,
                        spend,
                        transactions: vendorTransactions[vendor]
                    }))
                    .sort((a, b) => b.spend - a.spend);

                // Calculate cumulative percentages
                const totalSpend = sortedVendors.reduce((sum, v) => sum + v.spend, 0);
                let cumulativeSpend = 0;

                const paretoData = sortedVendors.map((vendor, index) => {
                    cumulativeSpend += vendor.spend;
                    const cumulativePercentage = (cumulativeSpend / totalSpend) * 100;
                    const spendPercentage = (vendor.spend / totalSpend) * 100;

                    return {
                        ...vendor,
                        rank: index + 1,
                        spendPercentage,
                        cumulativePercentage,
                        classification: cumulativePercentage <= 80 ? 'Core' : 'Tail'
                    };
                });

                return {
                    vendors: paretoData,
                    totalSpend,
                    totalVendors: sortedVendors.length
                };
            }

            // Main analysis function
            performComprehensiveAnalysis(data, seasonalityData = null) {
                try {
                    // Step 1: Pareto Analysis
                    const paretoData = this.performParetoAnalysis(data);

                    // Step 2: Tail Segmentation
                    const tailVendors = paretoData.vendors.filter(v => v.classification === 'Tail');
                    const segments = {
                        micro: { vendors: [], totalSpend: 0, totalTransactions: 0 },
                        small: { vendors: [], totalSpend: 0, totalTransactions: 0 },
                        midTail: { vendors: [], totalSpend: 0, totalTransactions: 0 }
                    };

                    tailVendors.forEach(vendor => {
                        let segment;
                        if (vendor.spend < this.segmentThresholds.micro) {
                            segment = 'micro';
                        } else if (vendor.spend < this.segmentThresholds.small) {
                            segment = 'small';
                        } else {
                            segment = 'midTail';
                        }

                        segments[segment].vendors.push(vendor);
                        segments[segment].totalSpend += vendor.spend;
                        segments[segment].totalTransactions += vendor.transactions;
                    });

                    // Step 3: Savings Calculations
                    const totalTailSpend = segments.micro.totalSpend + segments.small.totalSpend + segments.midTail.totalSpend;
                    const totalTailTransactions = segments.micro.totalTransactions + segments.small.totalTransactions;

                    const savingsOpportunities = {
                        vendorConsolidation: {
                            name: 'Vendor Consolidation',
                            description: 'Consolidate micro vendors to reduce administrative overhead',
                            targetSpend: segments.micro.totalSpend,
                            conservativeSavings: segments.micro.totalSpend * this.industryBenchmarks.vendorConsolidation * 0.7,
                            optimisticSavings: segments.micro.totalSpend * this.industryBenchmarks.vendorConsolidation,
                            vendorsAffected: segments.micro.vendors.length,
                            timeline: '3-6 months'
                        },
                        processImprovement: {
                            name: 'Process Improvement',
                            description: 'Streamline procurement processes for tail spend',
                            targetSpend: totalTailSpend,
                            conservativeSavings: totalTailSpend * this.industryBenchmarks.processImprovement * 0.6,
                            optimisticSavings: totalTailSpend * this.industryBenchmarks.processImprovement,
                            vendorsAffected: segments.micro.vendors.length + segments.small.vendors.length,
                            timeline: '2-4 months'
                        },
                        pcardImplementation: {
                            name: 'P-Card Implementation',
                            description: 'Implement procurement cards for small transactions',
                            targetSpend: totalTailSpend,
                            conservativeSavings: totalTailTransactions * this.industryBenchmarks.pcardImplementation * 0.8,
                            optimisticSavings: totalTailTransactions * this.industryBenchmarks.pcardImplementation,
                            vendorsAffected: segments.micro.vendors.length + segments.small.vendors.length,
                            timeline: '6-12 months'
                        },
                        contractOptimization: {
                            name: 'Contract Optimization',
                            description: 'Negotiate better terms with small vendors',
                            targetSpend: segments.small.totalSpend,
                            conservativeSavings: segments.small.totalSpend * this.industryBenchmarks.contractOptimization * 0.75,
                            optimisticSavings: segments.small.totalSpend * this.industryBenchmarks.contractOptimization,
                            vendorsAffected: segments.small.vendors.length,
                            timeline: '4-8 months'
                        }
                    };

                    // Calculate summary metrics
                    const coreVendors = paretoData.vendors.filter(v => v.classification === 'Core');
                    const totalSavings = Object.values(savingsOpportunities).reduce((sum, s) => sum + s.conservativeSavings, 0);

                    return {
                        summary: {
                            totalVendors: paretoData.totalVendors,
                            coreVendors: coreVendors.length,
                            tailVendors: tailVendors.length,
                            totalSpend: paretoData.totalSpend,
                            tailSpend: totalTailSpend,
                            tailSpendPercentage: (totalTailSpend / paretoData.totalSpend) * 100,
                            totalSavingsOpportunity: totalSavings,
                            savingsPercentage: (totalSavings / totalTailSpend) * 100
                        },
                        paretoData,
                        segments,
                        savingsOpportunities
                    };
                } catch (error) {
                    console.error('Error in tail spend analysis:', error);
                    throw error;
                }
            }
        }

        // Maverick Spend Detection & Compliance Analyzer Class
        class MaverickSpendAnalyzer {
            constructor() {
                this.complianceThresholds = {
                    newSupplierAlert: 30,        // Days - flag suppliers not seen in last 30 days
                    spendDeviationThreshold: 2.5, // Standard deviations for anomaly detection
                    categoryConcentrationLimit: 0.8, // 80% spend with single supplier in category
                    unusualTransactionMultiplier: 3, // Flag transactions 3x larger than average
                    minimumTransactionHistory: 5     // Minimum transactions for baseline
                };

                this.riskWeights = {
                    newSupplier: 0.3,
                    spendDeviation: 0.25,
                    categoryConcentration: 0.2,
                    unusualTransaction: 0.15,
                    offContract: 0.1
                };

                this.complianceCategories = {
                    excellent: { min: 90, color: '#28a745', label: 'Excellent' },
                    good: { min: 75, color: '#17a2b8', label: 'Good' },
                    fair: { min: 60, color: '#ffc107', label: 'Fair' },
                    poor: { min: 0, color: '#dc3545', label: 'Poor' }
                };
            }

            // Main analysis function
            performMaverickAnalysis(data) {
                try {
                    console.log('=== MAVERICK SPEND ANALYSIS START ===');
                    console.log('Input data length:', data.length);

                    // Prepare data structures
                    const supplierProfiles = this.buildSupplierProfiles(data);
                    const categoryProfiles = this.buildCategoryProfiles(data);
                    const transactionPatterns = this.analyzeTransactionPatterns(data);

                    // Detect various types of maverick spend
                    const newSupplierAlerts = this.detectNewSuppliers(data, supplierProfiles);
                    const spendAnomalies = this.detectSpendAnomalies(data, supplierProfiles);
                    const concentrationRisks = this.detectConcentrationRisks(categoryProfiles);
                    const unusualTransactions = this.detectUnusualTransactions(data, transactionPatterns);
                    const offContractSpend = this.detectOffContractSpend(data, supplierProfiles);

                    // Calculate compliance scores
                    const complianceScores = this.calculateComplianceScores(data, {
                        newSupplierAlerts,
                        spendAnomalies,
                        concentrationRisks,
                        unusualTransactions,
                        offContractSpend
                    });

                    // Generate recommendations
                    const recommendations = this.generateRecommendations({
                        newSupplierAlerts,
                        spendAnomalies,
                        concentrationRisks,
                        unusualTransactions,
                        offContractSpend,
                        complianceScores
                    });

                    console.log('Maverick analysis completed successfully');

                    return {
                        summary: {
                            totalTransactions: data.length,
                            totalSpend: data.reduce((sum, row) => sum + row.amount, 0),
                            overallComplianceScore: complianceScores.overall,
                            complianceLevel: this.getComplianceLevel(complianceScores.overall),
                            totalAlerts: newSupplierAlerts.length + spendAnomalies.length +
                                concentrationRisks.length + unusualTransactions.length + offContractSpend.length,
                            riskLevel: this.calculateRiskLevel(complianceScores.overall)
                        },
                        alerts: {
                            newSuppliers: newSupplierAlerts,
                            spendAnomalies: spendAnomalies,
                            concentrationRisks: concentrationRisks,
                            unusualTransactions: unusualTransactions,
                            offContractSpend: offContractSpend
                        },
                        complianceScores: complianceScores,
                        recommendations: recommendations,
                        supplierProfiles: supplierProfiles,
                        categoryProfiles: categoryProfiles
                    };

                } catch (error) {
                    console.error('Error in maverick spend analysis:', error);
                    return {
                        summary: { totalTransactions: 0, totalSpend: 0, overallComplianceScore: 0, totalAlerts: 0 },
                        alerts: { newSuppliers: [], spendAnomalies: [], concentrationRisks: [], unusualTransactions: [], offContractSpend: [] },
                        complianceScores: { overall: 0 },
                        recommendations: [],
                        error: error.message
                    };
                }
            }

            // Build supplier profiles for analysis
            buildSupplierProfiles(data) {
                const profiles = {};

                data.forEach(row => {
                    const supplier = row.supplier;
                    if (!profiles[supplier]) {
                        profiles[supplier] = {
                            name: supplier,
                            totalSpend: 0,
                            transactionCount: 0,
                            categories: new Set(),
                            firstSeen: row.date,
                            lastSeen: row.date,
                            transactions: [],
                            avgTransactionSize: 0,
                            spendByMonth: {},
                            businessUnits: new Set()
                        };
                    }

                    const profile = profiles[supplier];
                    profile.totalSpend += row.amount;
                    profile.transactionCount += 1;
                    profile.categories.add(row.category);
                    profile.businessUnits.add(row.businessUnit);
                    profile.transactions.push(row);

                    if (row.date < profile.firstSeen) profile.firstSeen = row.date;
                    if (row.date > profile.lastSeen) profile.lastSeen = row.date;

                    // Track monthly spend
                    const monthKey = `${row.date.getFullYear()}-${row.date.getMonth() + 1}`;
                    profile.spendByMonth[monthKey] = (profile.spendByMonth[monthKey] || 0) + row.amount;
                });

                // Calculate averages and statistics
                Object.values(profiles).forEach(profile => {
                    profile.avgTransactionSize = profile.totalSpend / profile.transactionCount;
                    profile.categories = Array.from(profile.categories);
                    profile.businessUnits = Array.from(profile.businessUnits);

                    // Calculate spend volatility
                    const monthlySpends = Object.values(profile.spendByMonth);
                    if (monthlySpends.length > 1) {
                        const avgMonthlySpend = monthlySpends.reduce((sum, spend) => sum + spend, 0) / monthlySpends.length;
                        const variance = monthlySpends.reduce((sum, spend) => sum + Math.pow(spend - avgMonthlySpend, 2), 0) / monthlySpends.length;
                        profile.spendVolatility = Math.sqrt(variance) / avgMonthlySpend;
                    } else {
                        profile.spendVolatility = 0;
                    }
                });

                return profiles;
            }

            // Build category profiles for concentration analysis
            buildCategoryProfiles(data) {
                const profiles = {};

                data.forEach(row => {
                    const category = row.category;
                    if (!profiles[category]) {
                        profiles[category] = {
                            name: category,
                            totalSpend: 0,
                            suppliers: {},
                            transactionCount: 0
                        };
                    }

                    const profile = profiles[category];
                    profile.totalSpend += row.amount;
                    profile.transactionCount += 1;

                    if (!profile.suppliers[row.supplier]) {
                        profile.suppliers[row.supplier] = {
                            spend: 0,
                            transactions: 0,
                            percentage: 0
                        };
                    }

                    profile.suppliers[row.supplier].spend += row.amount;
                    profile.suppliers[row.supplier].transactions += 1;
                });

                // Calculate supplier percentages within each category
                Object.values(profiles).forEach(profile => {
                    Object.values(profile.suppliers).forEach(supplier => {
                        supplier.percentage = (supplier.spend / profile.totalSpend) * 100;
                    });
                });

                return profiles;
            }

            // Analyze transaction patterns for anomaly detection
            analyzeTransactionPatterns(data) {
                const patterns = {
                    byCategory: {},
                    bySupplier: {},
                    overall: {
                        avgAmount: 0,
                        stdDeviation: 0,
                        totalTransactions: data.length
                    }
                };

                // Calculate overall statistics
                const amounts = data.map(row => row.amount);
                patterns.overall.avgAmount = amounts.reduce((sum, amt) => sum + amt, 0) / amounts.length;

                const variance = amounts.reduce((sum, amt) => sum + Math.pow(amt - patterns.overall.avgAmount, 2), 0) / amounts.length;
                patterns.overall.stdDeviation = Math.sqrt(variance);

                // Calculate category-specific patterns
                data.forEach(row => {
                    if (!patterns.byCategory[row.category]) {
                        patterns.byCategory[row.category] = {
                            amounts: [],
                            avgAmount: 0,
                            stdDeviation: 0
                        };
                    }
                    patterns.byCategory[row.category].amounts.push(row.amount);
                });

                // Calculate statistics for each category
                Object.values(patterns.byCategory).forEach(categoryPattern => {
                    const amounts = categoryPattern.amounts;
                    categoryPattern.avgAmount = amounts.reduce((sum, amt) => sum + amt, 0) / amounts.length;

                    const variance = amounts.reduce((sum, amt) => sum + Math.pow(amt - categoryPattern.avgAmount, 2), 0) / amounts.length;
                    categoryPattern.stdDeviation = Math.sqrt(variance);
                });

                return patterns;
            }

            // Detect new suppliers that haven't been used recently
            detectNewSuppliers(data, supplierProfiles) {
                const alerts = [];
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - this.complianceThresholds.newSupplierAlert);

                Object.values(supplierProfiles).forEach(profile => {
                    if (profile.firstSeen > cutoffDate) {
                        alerts.push({
                            type: 'New Supplier',
                            supplier: profile.name,
                            firstSeen: profile.firstSeen,
                            totalSpend: profile.totalSpend,
                            transactionCount: profile.transactionCount,
                            categories: profile.categories,
                            riskLevel: this.calculateSupplierRiskLevel(profile),
                            recommendation: 'Verify supplier approval and compliance documentation'
                        });
                    }
                });

                return alerts.sort((a, b) => b.totalSpend - a.totalSpend);
            }

            // Detect spending anomalies based on historical patterns
            detectSpendAnomalies(data, supplierProfiles) {
                const alerts = [];

                Object.values(supplierProfiles).forEach(profile => {
                    if (profile.transactionCount < this.complianceThresholds.minimumTransactionHistory) return;

                    // Check for recent spending spikes
                    const recentTransactions = profile.transactions.filter(t => {
                        const daysDiff = (new Date() - t.date) / (1000 * 60 * 60 * 24);
                        return daysDiff <= 30;
                    });

                    if (recentTransactions.length > 0) {
                        const recentSpend = recentTransactions.reduce((sum, t) => sum + t.amount, 0);
                        const historicalAvgMonthly = profile.totalSpend / Object.keys(profile.spendByMonth).length;

                        if (recentSpend > historicalAvgMonthly * this.complianceThresholds.spendDeviationThreshold) {
                            alerts.push({
                                type: 'Spend Anomaly',
                                supplier: profile.name,
                                recentSpend: recentSpend,
                                historicalAverage: historicalAvgMonthly,
                                deviationMultiple: recentSpend / historicalAvgMonthly,
                                riskLevel: recentSpend > historicalAvgMonthly * 3 ? 'High' : 'Medium',
                                recommendation: 'Review recent spending increase and verify business justification'
                            });
                        }
                    }
                });

                return alerts.sort((a, b) => b.deviationMultiple - a.deviationMultiple);
            }

            // Detect supplier concentration risks within categories
            detectConcentrationRisks(categoryProfiles) {
                const alerts = [];

                Object.values(categoryProfiles).forEach(profile => {
                    const sortedSuppliers = Object.entries(profile.suppliers)
                        .sort((a, b) => b[1].spend - a[1].spend);

                    if (sortedSuppliers.length > 0) {
                        const topSupplier = sortedSuppliers[0];
                        const concentration = topSupplier[1].percentage / 100;

                        if (concentration > this.complianceThresholds.categoryConcentrationLimit) {
                            alerts.push({
                                type: 'Concentration Risk',
                                category: profile.name,
                                supplier: topSupplier[0],
                                concentration: concentration * 100,
                                spend: topSupplier[1].spend,
                                totalCategorySpend: profile.totalSpend,
                                riskLevel: concentration > 0.9 ? 'High' : 'Medium',
                                recommendation: 'Develop alternative suppliers to reduce dependency risk'
                            });
                        }
                    }
                });

                return alerts.sort((a, b) => b.concentration - a.concentration);
            }

            // Detect unusually large transactions
            detectUnusualTransactions(data, patterns) {
                const alerts = [];

                data.forEach(row => {
                    const categoryPattern = patterns.byCategory[row.category];
                    if (!categoryPattern) return;

                    const threshold = categoryPattern.avgAmount * this.complianceThresholds.unusualTransactionMultiplier;

                    if (row.amount > threshold && categoryPattern.avgAmount > 0) {
                        alerts.push({
                            type: 'Unusual Transaction',
                            supplier: row.supplier,
                            category: row.category,
                            amount: row.amount,
                            categoryAverage: categoryPattern.avgAmount,
                            multiple: row.amount / categoryPattern.avgAmount,
                            date: row.date,
                            riskLevel: row.amount > threshold * 2 ? 'High' : 'Medium',
                            recommendation: 'Verify transaction approval and business justification'
                        });
                    }
                });

                return alerts.sort((a, b) => b.multiple - a.multiple).slice(0, 20); // Top 20 unusual transactions
            }

            // Detect potential off-contract spending (simplified heuristic)
            detectOffContractSpend(data, supplierProfiles) {
                const alerts = [];

                // Simple heuristic: suppliers with very low transaction counts might be off-contract
                Object.values(supplierProfiles).forEach(profile => {
                    if (profile.transactionCount <= 2 && profile.totalSpend > 1000) {
                        alerts.push({
                            type: 'Potential Off-Contract',
                            supplier: profile.name,
                            totalSpend: profile.totalSpend,
                            transactionCount: profile.transactionCount,
                            avgTransactionSize: profile.avgTransactionSize,
                            categories: profile.categories,
                            riskLevel: profile.totalSpend > 10000 ? 'High' : 'Medium',
                            recommendation: 'Verify if supplier has approved contract or should be added to preferred vendor list'
                        });
                    }
                });

                return alerts.sort((a, b) => b.totalSpend - a.totalSpend);
            }

            // Calculate overall compliance scores
            calculateComplianceScores(data, alerts) {
                const totalSpend = data.reduce((sum, row) => sum + row.amount, 0);
                const totalTransactions = data.length;

                // Calculate individual risk scores
                const newSupplierRisk = Math.min(100, (alerts.newSupplierAlerts.length / totalTransactions) * 10000);
                const spendAnomalyRisk = Math.min(100, (alerts.spendAnomalies.length / totalTransactions) * 10000);
                const concentrationRisk = Math.min(100, alerts.concentrationRisks.length * 10);
                const unusualTransactionRisk = Math.min(100, (alerts.unusualTransactions.length / totalTransactions) * 1000);
                const offContractRisk = Math.min(100, (alerts.offContractSpend.reduce((sum, alert) => sum + alert.totalSpend, 0) / totalSpend) * 100);

                // Calculate weighted overall score
                const overallRisk = (
                    newSupplierRisk * this.riskWeights.newSupplier +
                    spendAnomalyRisk * this.riskWeights.spendDeviation +
                    concentrationRisk * this.riskWeights.categoryConcentration +
                    unusualTransactionRisk * this.riskWeights.unusualTransaction +
                    offContractRisk * this.riskWeights.offContract
                );

                const complianceScore = Math.max(0, 100 - overallRisk);

                return {
                    overall: Math.round(complianceScore),
                    breakdown: {
                        newSupplierCompliance: Math.round(100 - newSupplierRisk),
                        spendPatternCompliance: Math.round(100 - spendAnomalyRisk),
                        concentrationCompliance: Math.round(100 - concentrationRisk),
                        transactionCompliance: Math.round(100 - unusualTransactionRisk),
                        contractCompliance: Math.round(100 - offContractRisk)
                    }
                };
            }

            // Generate actionable recommendations
            generateRecommendations(analysisResults) {
                const recommendations = [];

                // High-priority recommendations based on alerts
                if (analysisResults.newSupplierAlerts.length > 0) {
                    recommendations.push({
                        priority: 'High',
                        category: 'Supplier Management',
                        title: 'Review New Supplier Approvals',
                        description: `${analysisResults.newSupplierAlerts.length} new suppliers detected. Ensure proper approval process and compliance documentation.`,
                        impact: 'Risk Mitigation',
                        timeline: 'Immediate',
                        effort: 'Medium'
                    });
                }

                if (analysisResults.concentrationRisks.length > 0) {
                    recommendations.push({
                        priority: 'High',
                        category: 'Risk Management',
                        title: 'Address Supplier Concentration Risks',
                        description: `${analysisResults.concentrationRisks.length} categories have high supplier concentration. Develop alternative suppliers.`,
                        impact: 'Risk Reduction',
                        timeline: '3-6 months',
                        effort: 'High'
                    });
                }

                if (analysisResults.spendAnomalies.length > 0) {
                    recommendations.push({
                        priority: 'Medium',
                        category: 'Spend Control',
                        title: 'Investigate Spending Anomalies',
                        description: `${analysisResults.spendAnomalies.length} suppliers show unusual spending patterns. Review for business justification.`,
                        impact: 'Cost Control',
                        timeline: '1-2 weeks',
                        effort: 'Low'
                    });
                }

                if (analysisResults.offContractSpend.length > 0) {
                    recommendations.push({
                        priority: 'Medium',
                        category: 'Contract Management',
                        title: 'Review Potential Off-Contract Spending',
                        description: `${analysisResults.offContractSpend.length} suppliers may represent off-contract spending. Verify contract status.`,
                        impact: 'Compliance',
                        timeline: '2-4 weeks',
                        effort: 'Medium'
                    });
                }

                // General compliance improvement recommendations
                if (analysisResults.complianceScores.overall < 80) {
                    recommendations.push({
                        priority: 'Medium',
                        category: 'Process Improvement',
                        title: 'Implement Procurement Controls',
                        description: 'Overall compliance score indicates need for stronger procurement controls and approval processes.',
                        impact: 'Process Enhancement',
                        timeline: '3-6 months',
                        effort: 'High'
                    });
                }

                return recommendations.sort((a, b) => {
                    const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                });
            }

            // Helper functions
            calculateSupplierRiskLevel(profile) {
                if (profile.totalSpend > 50000) return 'High';
                if (profile.totalSpend > 10000) return 'Medium';
                return 'Low';
            }

            calculateRiskLevel(complianceScore) {
                if (complianceScore >= 80) return 'Low';
                if (complianceScore >= 60) return 'Medium';
                return 'High';
            }

            getComplianceLevel(score) {
                for (const [level, config] of Object.entries(this.complianceCategories)) {
                    if (score >= config.min) {
                        return config.label;
                    }
                }
                return 'Poor';
            }

            getComplianceColor(score) {
                for (const [level, config] of Object.entries(this.complianceCategories)) {
                    if (score >= config.min) {
                        return config.color;
                    }
                }
                return '#dc3545';
            }
        }

        // Contract Optimization Intelligence Analyzer Class
        class ContractOptimizationAnalyzer {
            constructor() {
                this.contractThresholds = {
                    minimumContractValue: 25000,     // Treat suppliers with >$25K annual spend as "contracts"
                    renewalWindowDays: 90,           // Flag contracts within 90 days of renewal
                    performanceMinimumTransactions: 5, // Minimum transactions for performance analysis
                    riskConcentrationLimit: 0.6,     // 60% spend concentration triggers risk alert
                    volumeCommitmentVariance: 0.15   // 15% variance from expected volume
                };

                this.performanceWeights = {
                    costStability: 0.25,      // Price consistency over time
                    volumeConsistency: 0.20,  // Spending pattern reliability
                    transactionFrequency: 0.15, // Engagement level
                    spendGrowth: 0.20,        // Relationship growth
                    categoryDiversification: 0.20 // Service breadth
                };

                this.riskFactors = {
                    supplierConcentration: 0.3,
                    performanceVariability: 0.25,
                    spendVolatility: 0.2,
                    categoryDependency: 0.15,
                    renewalTimeline: 0.1
                };
            }

            // Main contract optimization analysis
            performContractAnalysis(data) {
                try {
                    console.log('=== ENHANCED CONTRACT OPTIMIZATION ANALYSIS START ===');
                    console.log('Analyzing', data.length, 'transactions for contract intelligence');

                    // Build intelligent contract profiles from transaction data
                    const contractProfiles = this.inferContractRelationships(data);
                    const portfolioMetrics = this.calculatePortfolioMetrics(contractProfiles, data);
                    const renewalPipeline = this.generateRenewalPipeline(contractProfiles);
                    const performanceMetrics = this.calculatePerformanceMetrics(contractProfiles, data);
                    const volumeCommitments = this.analyzeVolumeCommitments(contractProfiles, data);
                    const optimizationOpportunities = this.identifyOptimizationOpportunities(contractProfiles, data);
                    const riskAssessment = this.assessContractRisks(contractProfiles, data);
                    const recommendations = this.generateStrategicRecommendations(contractProfiles, optimizationOpportunities, riskAssessment);

                    const results = {
                        portfolioOverview: portfolioMetrics,
                        renewalPipeline: renewalPipeline,
                        performanceMetrics: performanceMetrics,
                        volumeCommitments: volumeCommitments,
                        optimizationOpportunities: optimizationOpportunities,
                        riskAssessment: riskAssessment,
                        recommendations: recommendations,
                        contractProfiles: contractProfiles
                    };

                    console.log('Contract optimization analysis completed successfully');
                    console.log('Portfolio overview:', portfolioMetrics);
                    console.log('Renewal pipeline items:', renewalPipeline.length);
                    console.log('Optimization opportunities:', optimizationOpportunities.length);

                    return results;

                } catch (error) {
                    console.error('Error in contract optimization analysis:', error);
                    return this.getEmptyResults();
                }
            }

            // Infer contract relationships from transaction patterns
            inferContractRelationships(data) {
                const supplierProfiles = {};

                // Build supplier transaction profiles
                data.forEach(row => {
                    const supplier = row.supplier || row.vendor || 'Unknown';
                    const amount = parseFloat(row.amount) || 0;
                    const date = parseDate(row.date);
                    const category = row.category || 'Unknown';

                    if (!supplierProfiles[supplier]) {
                        supplierProfiles[supplier] = {
                            supplier: supplier,
                            transactions: [],
                            categories: new Set(),
                            totalSpend: 0,
                            firstTransaction: date,
                            lastTransaction: date,
                            transactionCount: 0
                        };
                    }

                    const profile = supplierProfiles[supplier];
                    profile.transactions.push({ amount, date, category });
                    profile.categories.add(category);
                    profile.totalSpend += amount;
                    profile.transactionCount++;

                    if (date < profile.firstTransaction) profile.firstTransaction = date;
                    if (date > profile.lastTransaction) profile.lastTransaction = date;
                });

                // Convert to contract profiles for suppliers meeting threshold
                const contractProfiles = {};
                Object.values(supplierProfiles).forEach(profile => {
                    if (profile.totalSpend >= this.contractThresholds.minimumContractValue) {
                        const contractId = `CONTRACT_${profile.supplier.replace(/\s+/g, '_').toUpperCase()}`;

                        // Calculate contract period and renewal date
                        const contractPeriodMonths = this.calculateContractPeriod(profile);
                        const estimatedRenewalDate = this.estimateRenewalDate(profile, contractPeriodMonths);
                        const annualValue = this.calculateAnnualValue(profile);

                        contractProfiles[contractId] = {
                            contractId: contractId,
                            supplier: profile.supplier,
                            annualValue: annualValue,
                            totalSpend: profile.totalSpend,
                            startDate: profile.firstTransaction,
                            endDate: profile.lastTransaction,
                            estimatedRenewalDate: estimatedRenewalDate,
                            contractPeriodMonths: contractPeriodMonths,
                            categories: Array.from(profile.categories),
                            transactionCount: profile.transactionCount,
                            transactions: profile.transactions,
                            isInferred: true // Mark as inferred from transaction data
                        };
                    }
                });

                console.log(`Inferred ${Object.keys(contractProfiles).length} contract relationships from transaction data`);
                return contractProfiles;
            }

            // Calculate contract period based on transaction patterns
            calculateContractPeriod(profile) {
                const daysDiff = (profile.lastTransaction - profile.firstTransaction) / (1000 * 60 * 60 * 24);
                const monthsDiff = daysDiff / 30.44; // Average days per month

                // Infer standard contract periods
                if (monthsDiff <= 6) return 12; // Short history suggests annual contract
                if (monthsDiff <= 18) return 12; // Likely annual
                if (monthsDiff <= 30) return 24; // Likely 2-year
                return 36; // Likely 3-year for longer relationships
            }

            // Estimate renewal date based on transaction patterns
            estimateRenewalDate(profile, contractPeriodMonths) {
                const startDate = new Date(profile.firstTransaction);
                const renewalDate = new Date(startDate);
                renewalDate.setMonth(renewalDate.getMonth() + contractPeriodMonths);

                // If calculated renewal is in the past, project forward
                while (renewalDate < new Date()) {
                    renewalDate.setMonth(renewalDate.getMonth() + contractPeriodMonths);
                }

                return renewalDate;
            }

            // Calculate annual value from transaction history
            calculateAnnualValue(profile) {
                const daysDiff = (profile.lastTransaction - profile.firstTransaction) / (1000 * 60 * 60 * 24);
                if (daysDiff < 30) return profile.totalSpend * 12; // Less than a month, annualize

                const annualizedSpend = (profile.totalSpend / daysDiff) * 365.25;
                return annualizedSpend;
            }

            // Calculate portfolio-level metrics
            calculatePortfolioMetrics(contractProfiles, data) {
                const contracts = Object.values(contractProfiles);
                const totalContracts = contracts.length;
                const totalValue = contracts.reduce((sum, contract) => sum + contract.annualValue, 0);

                // Calculate portfolio health score
                const avgContractValue = totalValue / totalContracts;
                const categoryDiversification = this.calculateCategoryDiversification(contracts);
                const renewalDistribution = this.calculateRenewalDistribution(contracts);

                const healthScore = Math.min(100,
                    (categoryDiversification * 0.4) +
                    (renewalDistribution * 0.3) +
                    (Math.min(100, avgContractValue / 50000 * 30)) // Value factor
                );

                return {
                    totalContracts: totalContracts,
                    totalValue: totalValue,
                    averageValue: avgContractValue,
                    healthScore: Math.round(healthScore),
                    categoryDiversification: Math.round(categoryDiversification),
                    renewalDistribution: Math.round(renewalDistribution)
                };
            }

            // Calculate category diversification score
            calculateCategoryDiversification(contracts) {
                const categorySpend = {};
                let totalSpend = 0;

                contracts.forEach(contract => {
                    contract.categories.forEach(category => {
                        if (!categorySpend[category]) categorySpend[category] = 0;
                        categorySpend[category] += contract.annualValue / contract.categories.length;
                        totalSpend += contract.annualValue / contract.categories.length;
                    });
                });

                // Calculate Herfindahl-Hirschman Index for diversification
                const categoryShares = Object.values(categorySpend).map(spend => spend / totalSpend);
                const hhi = categoryShares.reduce((sum, share) => sum + (share * share), 0);

                // Convert to diversification score (lower HHI = higher diversification)
                return Math.max(0, (1 - hhi) * 100);
            }

            // Calculate renewal distribution score
            calculateRenewalDistribution(contracts) {
                const renewalQuarters = {};

                contracts.forEach(contract => {
                    const quarter = Math.floor(contract.estimatedRenewalDate.getMonth() / 3) + 1;
                    const year = contract.estimatedRenewalDate.getFullYear();
                    const key = `${year}-Q${quarter}`;

                    if (!renewalQuarters[key]) renewalQuarters[key] = 0;
                    renewalQuarters[key]++;
                });

                // Calculate distribution evenness
                const quarterCounts = Object.values(renewalQuarters);
                const avgPerQuarter = quarterCounts.reduce((sum, count) => sum + count, 0) / quarterCounts.length;
                const variance = quarterCounts.reduce((sum, count) => sum + Math.pow(count - avgPerQuarter, 2), 0) / quarterCounts.length;

                // Lower variance = better distribution
                return Math.max(0, 100 - (variance * 10));
            }

            // Generate renewal pipeline with intelligent prioritization
            generateRenewalPipeline(contractProfiles) {
                const contracts = Object.values(contractProfiles);
                const now = new Date();
                const renewalWindow = new Date(now.getTime() + (this.contractThresholds.renewalWindowDays * 24 * 60 * 60 * 1000));

                const upcomingRenewals = contracts
                    .filter(contract => contract.estimatedRenewalDate <= renewalWindow)
                    .map(contract => {
                        const daysToRenewal = Math.ceil((contract.estimatedRenewalDate - now) / (1000 * 60 * 60 * 24));
                        const priority = this.calculateRenewalPriority(contract, daysToRenewal);

                        return {
                            contractId: contract.contractId,
                            supplier: contract.supplier,
                            renewalDate: contract.estimatedRenewalDate,
                            daysToRenewal: daysToRenewal,
                            annualValue: contract.annualValue,
                            priority: priority.level,
                            priorityScore: priority.score,
                            categories: contract.categories,
                            riskFactors: this.identifyRenewalRisks(contract)
                        };
                    })
                    .sort((a, b) => b.priorityScore - a.priorityScore);

                return upcomingRenewals;
            }

            // Calculate renewal priority based on multiple factors
            calculateRenewalPriority(contract, daysToRenewal) {
                let score = 0;

                // Time urgency (0-40 points)
                if (daysToRenewal <= 30) score += 40;
                else if (daysToRenewal <= 60) score += 25;
                else if (daysToRenewal <= 90) score += 10;

                // Contract value (0-30 points)
                if (contract.annualValue >= 500000) score += 30;
                else if (contract.annualValue >= 100000) score += 20;
                else if (contract.annualValue >= 50000) score += 10;

                // Category importance (0-20 points)
                const criticalCategories = ['IT Services', 'Professional Services', 'Facilities', 'Security'];
                const hasCriticalCategory = contract.categories.some(cat =>
                    criticalCategories.some(critical => cat.toLowerCase().includes(critical.toLowerCase()))
                );
                if (hasCriticalCategory) score += 20;

                // Multi-category bonus (0-10 points)
                if (contract.categories.length > 1) score += 10;

                // Determine priority level
                let level = 'Low';
                if (score >= 70) level = 'High';
                else if (score >= 40) level = 'Medium';

                return { level, score };
            }

            // Identify renewal-specific risks
            identifyRenewalRisks(contract) {
                const risks = [];

                if (contract.annualValue > 200000) {
                    risks.push('High-value contract requires executive approval');
                }

                if (contract.categories.length > 2) {
                    risks.push('Multi-category contract may require complex negotiations');
                }

                const monthsActive = (new Date() - contract.startDate) / (1000 * 60 * 60 * 24 * 30.44);
                if (monthsActive < 12) {
                    risks.push('Relatively new relationship - limited performance history');
                }

                return risks;
            }

            // Calculate comprehensive performance metrics
            calculatePerformanceMetrics(contractProfiles, data) {
                const contracts = Object.values(contractProfiles);
                let totalScore = 0;
                let scoredContracts = 0;

                const categoryScores = {};
                const performanceBreakdown = {
                    costStability: 0,
                    volumeConsistency: 0,
                    transactionFrequency: 0,
                    spendGrowth: 0,
                    categoryDiversification: 0
                };

                contracts.forEach(contract => {
                    if (contract.transactionCount >= this.contractThresholds.performanceMinimumTransactions) {
                        const score = this.calculateContractPerformanceScore(contract);

                        // Ensure score is valid
                        if (score && typeof score.overall === 'number' && !isNaN(score.overall)) {
                            totalScore += score.overall;
                            scoredContracts++;

                            // Aggregate category scores
                            contract.categories.forEach(category => {
                                if (!categoryScores[category]) {
                                    categoryScores[category] = { total: 0, count: 0 };
                                }
                                categoryScores[category].total += score.overall;
                                categoryScores[category].count++;
                            });

                            // Aggregate performance breakdown
                            Object.keys(performanceBreakdown).forEach(metric => {
                                const value = score.breakdown[metric];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    performanceBreakdown[metric] += value;
                                }
                            });
                        }
                    }
                });

                // Calculate averages with fallbacks
                const overallScore = scoredContracts > 0 ? Math.round(totalScore / scoredContracts) : 0;

                Object.keys(performanceBreakdown).forEach(metric => {
                    performanceBreakdown[metric] = scoredContracts > 0 ?
                        Math.round(performanceBreakdown[metric] / scoredContracts) : 0;
                });

                // Calculate category averages with fallbacks
                const categoryAverages = {};
                Object.entries(categoryScores).forEach(([category, data]) => {
                    if (data.count > 0) {
                        categoryAverages[category] = Math.round(data.total / data.count);
                    }
                });

                return {
                    overallScore: overallScore,
                    scoredContracts: scoredContracts,
                    totalContracts: contracts.length,
                    performanceBreakdown: performanceBreakdown,
                    categoryPerformance: categoryAverages
                };
            }

            // Calculate individual contract performance score
            calculateContractPerformanceScore(contract) {
                const transactions = contract.transactions.sort((a, b) => a.date - b.date);
                const amounts = transactions.map(t => t.amount);

                // Ensure we have valid data
                if (!amounts.length || amounts.length < 2) {
                    return {
                        overall: 50, // Default neutral score
                        breakdown: {
                            costStability: 50,
                            volumeConsistency: 50,
                            transactionFrequency: 50,
                            spendGrowth: 50,
                            categoryDiversification: 50
                        }
                    };
                }

                // Cost Stability (lower variance = higher score)
                const avgAmount = amounts.reduce((sum, amt) => sum + amt, 0) / amounts.length;
                let costStability = 50; // Default neutral score

                if (avgAmount > 0) {
                    const variance = amounts.reduce((sum, amt) => sum + Math.pow(amt - avgAmount, 2), 0) / amounts.length;
                    const coefficientOfVariation = Math.sqrt(variance) / avgAmount;
                    costStability = Math.max(0, Math.min(100, 100 - (coefficientOfVariation * 100)));
                }

                // Volume Consistency (regular transaction pattern)
                let volumeConsistency = 50; // Default neutral score

                if (transactions.length > 2) {
                    const daysBetweenTransactions = [];
                    for (let i = 1; i < transactions.length; i++) {
                        const days = (transactions[i].date - transactions[i - 1].date) / (1000 * 60 * 60 * 24);
                        if (days > 0) daysBetweenTransactions.push(days);
                    }

                    if (daysBetweenTransactions.length > 0) {
                        const avgDaysBetween = daysBetweenTransactions.reduce((sum, days) => sum + days, 0) / daysBetweenTransactions.length;
                        if (avgDaysBetween > 0) {
                            const dayVariance = daysBetweenTransactions.reduce((sum, days) => sum + Math.pow(days - avgDaysBetween, 2), 0) / daysBetweenTransactions.length;
                            const dayCoefficient = Math.sqrt(dayVariance) / avgDaysBetween;
                            volumeConsistency = Math.max(0, Math.min(100, 100 - (dayCoefficient * 50)));
                        }
                    }
                }

                // Transaction Frequency (more frequent = better engagement)
                let transactionFrequency = 50; // Default neutral score

                const totalDays = (contract.lastTransaction - contract.firstTransaction) / (1000 * 60 * 60 * 24);
                if (totalDays > 0 && contract.transactionCount > 0) {
                    const annualizedFrequency = (contract.transactionCount / totalDays) * 365;
                    transactionFrequency = Math.min(100, Math.max(0, annualizedFrequency * 10)); // Scale appropriately
                }

                // Spend Growth (positive growth = good relationship)
                let spendGrowth = 50; // Default neutral score

                if (transactions.length >= 4) { // Need at least 4 transactions for meaningful comparison
                    const midPoint = Math.floor(transactions.length / 2);
                    const firstHalf = transactions.slice(0, midPoint);
                    const secondHalf = transactions.slice(midPoint);

                    const firstHalfAvg = firstHalf.reduce((sum, t) => sum + t.amount, 0) / firstHalf.length;
                    const secondHalfAvg = secondHalf.reduce((sum, t) => sum + t.amount, 0) / secondHalf.length;

                    if (firstHalfAvg > 0) {
                        const growthRate = ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100;
                        spendGrowth = Math.max(0, Math.min(100, 50 + (growthRate * 0.5))); // Normalize around 50
                    }
                }

                // Category Diversification (more categories = more strategic)
                const categoryDiversification = Math.min(100, Math.max(0, contract.categories.length * 25));

                // Calculate weighted overall score
                const breakdown = {
                    costStability: Math.round(costStability),
                    volumeConsistency: Math.round(volumeConsistency),
                    transactionFrequency: Math.round(transactionFrequency),
                    spendGrowth: Math.round(spendGrowth),
                    categoryDiversification: Math.round(categoryDiversification)
                };

                const overall = Object.entries(this.performanceWeights).reduce((sum, [metric, weight]) => {
                    const value = breakdown[metric] || 0;
                    return sum + (value * weight);
                }, 0);

                return {
                    overall: Math.round(Math.max(0, Math.min(100, overall))),
                    breakdown
                };
            }

            // Analyze volume commitments and compliance
            analyzeVolumeCommitments(contractProfiles, data) {
                const contracts = Object.values(contractProfiles);
                const commitmentAnalysis = [];

                contracts.forEach(contract => {
                    // Estimate volume commitment based on annual value
                    const estimatedCommitment = contract.annualValue;
                    const actualSpend = contract.totalSpend;

                    // Annualize actual spend if contract period is less than a year
                    const contractDays = (contract.lastTransaction - contract.startDate) / (1000 * 60 * 60 * 24);
                    const annualizedActual = contractDays < 365 ? (actualSpend / contractDays) * 365 : actualSpend;

                    const variance = Math.abs(annualizedActual - estimatedCommitment) / estimatedCommitment;

                    let status = 'Compliant';
                    let riskLevel = 'Low';

                    if (variance > this.contractThresholds.volumeCommitmentVariance) {
                        if (annualizedActual < estimatedCommitment) {
                            status = 'Under-performing';
                            riskLevel = variance > 0.3 ? 'High' : 'Medium';
                        } else {
                            status = 'Over-performing';
                            riskLevel = 'Low'; // Over-performance is generally good
                        }
                    }

                    commitmentAnalysis.push({
                        contractId: contract.contractId,
                        supplier: contract.supplier,
                        estimatedCommitment: estimatedCommitment,
                        actualSpend: annualizedActual,
                        variance: variance,
                        status: status,
                        riskLevel: riskLevel,
                        categories: contract.categories
                    });
                });

                // Calculate summary metrics
                const totalCommitments = commitmentAnalysis.length;
                const compliantCount = commitmentAnalysis.filter(c => c.status === 'Compliant').length;
                const complianceRate = totalCommitments > 0 ? (compliantCount / totalCommitments) * 100 : 0;

                return {
                    commitments: commitmentAnalysis,
                    summary: {
                        totalCommitments: totalCommitments,
                        compliantCount: compliantCount,
                        complianceRate: Math.round(complianceRate)
                    }
                };
            }

            // Identify optimization opportunities
            identifyOptimizationOpportunities(contractProfiles, data) {
                const opportunities = [];
                const contracts = Object.values(contractProfiles);

                // Consolidation opportunities
                const consolidationOpps = this.identifyConsolidationOpportunities(contracts);
                opportunities.push(...consolidationOpps);

                // Renegotiation opportunities
                const renegotiationOpps = this.identifyRenegotiationOpportunities(contracts);
                opportunities.push(...renegotiationOpps);

                // Volume leverage opportunities
                const volumeOpps = this.identifyVolumeLeverageOpportunities(contracts);
                opportunities.push(...volumeOpps);

                return opportunities.sort((a, b) => b.savingsPotential - a.savingsPotential);
            }

            // Identify consolidation opportunities
            identifyConsolidationOpportunities(contracts) {
                const opportunities = [];
                const categoryGroups = {};

                // Group contracts by category
                contracts.forEach(contract => {
                    contract.categories.forEach(category => {
                        if (!categoryGroups[category]) categoryGroups[category] = [];
                        categoryGroups[category].push(contract);
                    });
                });

                // Look for consolidation opportunities within categories
                Object.entries(categoryGroups).forEach(([category, categoryContracts]) => {
                    if (categoryContracts.length > 2) {
                        const totalValue = categoryContracts.reduce((sum, c) => sum + c.annualValue, 0);
                        const savingsPotential = totalValue * 0.08; // 8% savings from consolidation

                        opportunities.push({
                            type: 'Consolidation',
                            category: category,
                            description: `Consolidate ${categoryContracts.length} suppliers in ${category}`,
                            suppliers: categoryContracts.map(c => c.supplier),
                            currentValue: totalValue,
                            savingsPotential: savingsPotential,
                            priority: totalValue > 200000 ? 'High' : 'Medium',
                            implementation: 'Q2 2025',
                            effort: 'Medium'
                        });
                    }
                });

                return opportunities;
            }

            // Identify renegotiation opportunities
            identifyRenegotiationOpportunities(contracts) {
                const opportunities = [];

                contracts.forEach(contract => {
                    // Look for contracts with poor performance or high value
                    const performance = this.calculateContractPerformanceScore(contract);

                    if (performance.overall < 70 || contract.annualValue > 100000) {
                        const savingsPotential = contract.annualValue * 0.12; // 12% potential savings

                        opportunities.push({
                            type: 'Renegotiation',
                            category: contract.categories.join(', '),
                            description: `Renegotiate terms with ${contract.supplier}`,
                            suppliers: [contract.supplier],
                            currentValue: contract.annualValue,
                            savingsPotential: savingsPotential,
                            priority: contract.annualValue > 200000 ? 'High' : 'Medium',
                            implementation: 'Q3 2025',
                            effort: 'High'
                        });
                    }
                });

                return opportunities;
            }

            // Identify volume leverage opportunities
            identifyVolumeLeverageOpportunities(contracts) {
                const opportunities = [];

                // Look for suppliers with multiple contracts or high growth
                const supplierGroups = {};
                contracts.forEach(contract => {
                    if (!supplierGroups[contract.supplier]) {
                        supplierGroups[contract.supplier] = [];
                    }
                    supplierGroups[contract.supplier].push(contract);
                });

                Object.entries(supplierGroups).forEach(([supplier, supplierContracts]) => {
                    const totalValue = supplierContracts.reduce((sum, c) => sum + c.annualValue, 0);

                    if (totalValue > 150000) {
                        const savingsPotential = totalValue * 0.06; // 6% savings from volume leverage

                        opportunities.push({
                            type: 'Volume Leverage',
                            category: 'Multi-category',
                            description: `Leverage volume with ${supplier} across categories`,
                            suppliers: [supplier],
                            currentValue: totalValue,
                            savingsPotential: savingsPotential,
                            priority: totalValue > 300000 ? 'High' : 'Medium',
                            implementation: 'Q1 2025',
                            effort: 'Low'
                        });
                    }
                });

                return opportunities;
            }

            // Assess contract risks
            assessContractRisks(contractProfiles, data) {
                const contracts = Object.values(contractProfiles);
                const riskAssessment = {
                    overallRiskScore: 0,
                    riskFactors: [],
                    highRiskContracts: [],
                    riskDistribution: { high: 0, medium: 0, low: 0 }
                };

                let totalRiskScore = 0;

                contracts.forEach(contract => {
                    const contractRisk = this.calculateContractRisk(contract, contracts);
                    totalRiskScore += contractRisk.score;

                    if (contractRisk.level === 'High') {
                        riskAssessment.highRiskContracts.push({
                            contractId: contract.contractId,
                            supplier: contract.supplier,
                            riskScore: contractRisk.score,
                            riskFactors: contractRisk.factors,
                            annualValue: contract.annualValue
                        });
                        riskAssessment.riskDistribution.high++;
                    } else if (contractRisk.level === 'Medium') {
                        riskAssessment.riskDistribution.medium++;
                    } else {
                        riskAssessment.riskDistribution.low++;
                    }
                });

                riskAssessment.overallRiskScore = Math.round(totalRiskScore / contracts.length);

                // Identify portfolio-level risk factors
                riskAssessment.riskFactors = this.identifyPortfolioRiskFactors(contracts);

                return riskAssessment;
            }

            // Calculate individual contract risk
            calculateContractRisk(contract, allContracts) {
                let riskScore = 0;
                const factors = [];

                // Supplier concentration risk
                const totalPortfolioValue = allContracts.reduce((sum, c) => sum + c.annualValue, 0);
                const concentrationRatio = contract.annualValue / totalPortfolioValue;
                if (concentrationRatio > this.contractThresholds.riskConcentrationLimit) {
                    riskScore += 30;
                    factors.push(`High concentration: ${Math.round(concentrationRatio * 100)}% of portfolio`);
                }

                // Performance variability risk
                const performance = this.calculateContractPerformanceScore(contract);
                if (performance.overall < 60) {
                    riskScore += 25;
                    factors.push(`Poor performance score: ${Math.round(performance.overall)}`);
                }

                // Spend volatility risk
                const amounts = contract.transactions.map(t => t.amount);
                const avgAmount = amounts.reduce((sum, amt) => sum + amt, 0) / amounts.length;
                const variance = amounts.reduce((sum, amt) => sum + Math.pow(amt - avgAmount, 2), 0) / amounts.length;
                const coefficientOfVariation = Math.sqrt(variance) / avgAmount;
                if (coefficientOfVariation > 0.5) {
                    riskScore += 20;
                    factors.push(`High spend volatility: ${Math.round(coefficientOfVariation * 100)}% CV`);
                }

                // Category dependency risk
                if (contract.categories.length === 1) {
                    riskScore += 15;
                    factors.push('Single category dependency');
                }

                // Renewal timeline risk
                const daysToRenewal = (contract.estimatedRenewalDate - new Date()) / (1000 * 60 * 60 * 24);
                if (daysToRenewal < 30) {
                    riskScore += 10;
                    factors.push(`Renewal due in ${Math.round(daysToRenewal)} days`);
                }

                let level = 'Low';
                if (riskScore >= 60) level = 'High';
                else if (riskScore >= 30) level = 'Medium';

                return { score: riskScore, level, factors };
            }

            // Identify portfolio-level risk factors
            identifyPortfolioRiskFactors(contracts) {
                const factors = [];

                // Check for over-concentration in categories
                const categorySpend = {};
                let totalSpend = 0;
                contracts.forEach(contract => {
                    contract.categories.forEach(category => {
                        if (!categorySpend[category]) categorySpend[category] = 0;
                        categorySpend[category] += contract.annualValue;
                        totalSpend += contract.annualValue;
                    });
                });

                Object.entries(categorySpend).forEach(([category, spend]) => {
                    const concentration = spend / totalSpend;
                    if (concentration > 0.4) {
                        factors.push({
                            factor: 'Category Over-concentration',
                            description: `${Math.round(concentration * 100)}% of spend in ${category}`,
                            severity: 'High'
                        });
                    }
                });

                // Check for renewal clustering
                const renewalQuarters = {};
                contracts.forEach(contract => {
                    const quarter = Math.floor(contract.estimatedRenewalDate.getMonth() / 3) + 1;
                    const year = contract.estimatedRenewalDate.getFullYear();
                    const key = `${year}-Q${quarter}`;

                    if (!renewalQuarters[key]) renewalQuarters[key] = 0;
                    renewalQuarters[key]++;
                });

                Object.entries(renewalQuarters).forEach(([quarter, count]) => {
                    if (count > contracts.length * 0.4) {
                        factors.push({
                            factor: 'Renewal Clustering',
                            description: `${count} contracts renewing in ${quarter}`,
                            severity: 'Medium'
                        });
                    }
                });

                return factors;
            }

            // Generate strategic recommendations
            generateStrategicRecommendations(contractProfiles, optimizationOpportunities, riskAssessment) {
                const recommendations = [];

                // High-priority recommendations based on opportunities
                optimizationOpportunities.slice(0, 3).forEach((opp, index) => {
                    recommendations.push({
                        priority: 'High',
                        category: 'Optimization',
                        title: opp.description,
                        description: `Implement ${opp.type.toLowerCase()} strategy to achieve $${Math.round(opp.savingsPotential).toLocaleString()} in annual savings`,
                        impact: `$${Math.round(opp.savingsPotential).toLocaleString()} annual savings`,
                        timeline: opp.implementation,
                        effort: opp.effort,
                        owner: 'Procurement Team'
                    });
                });

                // Risk mitigation recommendations
                if (riskAssessment.overallRiskScore > 60) {
                    recommendations.push({
                        priority: 'High',
                        category: 'Risk Management',
                        title: 'Implement Contract Risk Mitigation Plan',
                        description: 'Address high-risk contracts and portfolio concentration issues',
                        impact: 'Reduced operational and financial risk',
                        timeline: 'Q1 2025',
                        effort: 'High',
                        owner: 'Risk Management'
                    });
                }

                // Performance improvement recommendations
                recommendations.push({
                    priority: 'Medium',
                    category: 'Performance',
                    title: 'Establish Supplier Performance Monitoring',
                    description: 'Implement regular performance reviews and KPI tracking',
                    impact: 'Improved supplier relationships and service quality',
                    timeline: 'Q2 2025',
                    effort: 'Medium',
                    owner: 'Supplier Management'
                });

                // Process improvement recommendations
                recommendations.push({
                    priority: 'Medium',
                    category: 'Process',
                    title: 'Automate Contract Renewal Alerts',
                    description: 'Implement automated alerts for upcoming renewals',
                    impact: 'Reduced risk of contract lapses and improved planning',
                    timeline: 'Q1 2025',
                    effort: 'Low',
                    owner: 'IT Team'
                });

                return recommendations.sort((a, b) => {
                    const priorityOrder = { 'High': 3, 'Medium': 2, 'Low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                });
            }

            // Get empty results structure for error cases
            getEmptyResults() {
                return {
                    portfolioOverview: {
                        totalContracts: 0,
                        totalValue: 0,
                        averageValue: 0,
                        healthScore: 0,
                        categoryDiversification: 0,
                        renewalDistribution: 0
                    },
                    renewalPipeline: [],
                    performanceMetrics: {
                        overallScore: 0,
                        scoredContracts: 0,
                        totalContracts: 0,
                        performanceBreakdown: {},
                        categoryPerformance: {}
                    },
                    volumeCommitments: {
                        commitments: [],
                        summary: { totalCommitments: 0, compliantCount: 0, complianceRate: 0 }
                    },
                    optimizationOpportunities: [],
                    riskAssessment: {
                        overallRiskScore: 0,
                        riskFactors: [],
                        highRiskContracts: [],
                        riskDistribution: { high: 0, medium: 0, low: 0 }
                    },
                    recommendations: [],
                    contractProfiles: {}
                };
            }
        }

        // Initialize maverick spend analyzer
        const maverickSpendAnalyzer = new MaverickSpendAnalyzer();

        // Initialize contract optimization analyzer
        const contractOptimizationAnalyzer = new ContractOptimizationAnalyzer();

        function toggleDebug() {
            debugMode = !debugMode;
            const debugPanel = safeGetElement('debugPanel');
            if (debugPanel) {
                debugPanel.style.display = debugMode ? 'block' : 'none';
                if (debugMode) {
                    debugPanel.innerHTML = 'Debug mode enabled...\n\n';
                }
            }
        }

        // File handling
        document.getElementById('fileInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const fileName = safeGetElement('fileName');
                if (fileName) {
                    fileName.textContent = `Selected: ${file.name}`;
                }
                const processBtn = safeGetElement('processBtn');
                if (processBtn) {
                    processBtn.style.display = 'block';
                }
            }
        });

        function showStatus(message, type = 'info') {
            const statusDiv = safeGetElement('statusMessage');
            if (statusDiv) {
                statusDiv.innerHTML = `<div class="status-message ${type}">${message}</div>`;
            }
            debugLog(`Status: ${type} - ${message}`);
        }

        function showProgress(show) {
            const progressContainer = safeGetElement('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = show ? 'block' : 'none';
            }
        }

        function updateProgress(percentage, message) {
            const progressFill = safeGetElement('progressFill');
            const progressText = safeGetElement('progressText');

            if (progressFill) {
                progressFill.style.width = percentage + '%';
                progressFill.textContent = percentage + '%';
            }

            if (progressText) {
                progressText.textContent = message;
            }

            debugLog(`Progress: ${percentage}% - ${message}`);
        }

        async function processFile() {
            const fileInput = safeGetElement('fileInput');
            if (!fileInput) {
                showStatus('File input not found', 'error');
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                showStatus('Please select a file first', 'error');
                return;
            }

            debugLog('Starting file processing', { fileName: file.name, fileSize: file.size });

            showProgress(true);
            updateProgress(0, 'Starting...');

            const processBtn = safeGetElement('processBtn');
            if (processBtn) {
                processBtn.textContent = 'â³ Processing...';
                processBtn.disabled = true;
            }

            try {
                const reader = new FileReader();

                reader.onload = async function (e) {
                    const data = e.target.result;
                    updateProgress(20, 'File loaded, parsing...');

                    if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                        await processExcelFile(data);
                    } else {
                        await processCSVFile(data);
                    }
                };

                reader.onerror = function () {
                    showStatus('Error reading file', 'error');
                    showProgress(false);
                    if (processBtn) {
                        processBtn.textContent = 'ðŸš€ Process Data';
                        processBtn.disabled = false;
                    }
                };

                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            } catch (error) {
                debugLog('File processing error', error);
                showStatus('Error processing file: ' + error.message, 'error');
                showProgress(false);
                if (processBtn) {
                    processBtn.textContent = 'ðŸš€ Process Data';
                    processBtn.disabled = false;
                }
            }
        }

        async function processExcelFile(data) {
            try {
                updateProgress(30, 'Processing Excel file...');

                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                updateProgress(50, 'Converting Excel data...');
                debugLog('Excel data converted', { totalRows: jsonData.length });

                if (jsonData.length < 2) {
                    showStatus('Excel file appears to be empty', 'warning');
                    showProgress(false);
                    return;
                }

                const headers = jsonData[0];
                const objectData = [];
                for (let i = 1; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index];
                    });
                    objectData.push(obj);
                }

                await processData(objectData);
            } catch (error) {
                debugLog('Excel processing error', error);
                showStatus('Error processing Excel file: ' + error.message, 'error');
                showProgress(false);
            }
        }

        async function processCSVFile(data) {
            try {
                updateProgress(30, 'Processing CSV file...');

                Papa.parse(data, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    complete: async function (results) {
                        debugLog('CSV parsed', { totalRows: results.data.length });
                        await processData(results.data);
                    },
                    error: function (error) {
                        debugLog('CSV parsing error', error);
                        showStatus('Error parsing CSV: ' + error.message, 'error');
                        showProgress(false);
                    }
                });
            } catch (error) {
                debugLog('CSV processing error', error);
                showStatus('Error processing CSV file: ' + error.message, 'error');
                showProgress(false);
            }
        }

        async function processData(data) {
            try {
                updateProgress(60, 'Processing data...');

                // Clear category-subcategory map
                categorySubcategoryMap = {};

                // Enhanced column mapping including SpendBand
                const columnMap = {
                    supplier: findColumn(data, ['supplier', 'vendor', 'supplier name', 'vendor name', 'company']),
                    category: findColumn(data, ['category', 'type', 'class', 'service', 'product']),
                    subcategory: findColumn(data, ['subcategory', 'sub category', 'subtype', 'sub-category', 'sub_category']),
                    amount: findColumn(data, ['amount', 'spend', 'cost', 'value', 'price', 'total', 'spend amount']),
                    transactions: findColumn(data, ['transactions', 'count', 'qty', 'quantity', 'transaction count']),
                    date: findColumn(data, ['date', 'transaction date', 'purchase date', 'order date']),
                    businessUnit: findColumn(data, ['business unit', 'division', 'unit', 'bu', 'business_unit']),
                    location: findColumn(data, ['location', 'city', 'site', 'office', 'region', 'regional division', 'area']),
                    spendBand: findColumn(data, ['spendband', 'spend band', 'spend_band', 'band', 'tier', 'level'])
                };

                debugLog('Column mapping', columnMap);

                const processedData = [];
                const categories = new Set();
                const subcategories = new Set();
                const businessUnits = new Set();
                const locations = new Set();
                const spendBands = new Set();

                updateProgress(70, 'Validating and cleaning data...');

                for (let i = 0; i < data.length; i++) {
                    const row = data[i];

                    const supplier = getColumnValue(row, columnMap.supplier) || 'Unknown Supplier';
                    const category = getColumnValue(row, columnMap.category) || 'Other';
                    const subcategory = getColumnValue(row, columnMap.subcategory) || 'General';
                    const amountStr = getColumnValue(row, columnMap.amount) || '0';
                    const transactionsStr = getColumnValue(row, columnMap.transactions) || '1';
                    const dateStr = getColumnValue(row, columnMap.date) || '';
                    const businessUnit = getColumnValue(row, columnMap.businessUnit) || 'Unknown';
                    const location = getColumnValue(row, columnMap.location) || 'Unknown';
                    const spendBand = getColumnValue(row, columnMap.spendBand) || 'Unclassified';

                    // Parse amount and date
                    const amount = parseAmount(amountStr);
                    const transactions = parseInt(transactionsStr) || 1;
                    const date = parseDate(dateStr);

                    if (amount > 0) {
                        processedData.push({
                            supplier: supplier.trim(),
                            category: category.trim(),
                            subcategory: subcategory.trim(),
                            amount: amount,
                            transactions: transactions,
                            date: date,
                            businessUnit: businessUnit.trim(),
                            location: location.trim(),
                            spendBand: spendBand.trim(),
                            _originalData: row  // Store reference to original row data
                        });

                        // Add to sets for filter population
                        if (category && category.trim() !== '') {
                            categories.add(category.trim());

                            // Build category-subcategory map
                            if (!categorySubcategoryMap[category.trim()]) {
                                categorySubcategoryMap[category.trim()] = new Set();
                            }
                            if (subcategory && subcategory.trim() !== '') {
                                categorySubcategoryMap[category.trim()].add(subcategory.trim());
                            }
                        }
                        if (subcategory && subcategory.trim() !== '') {
                            subcategories.add(subcategory.trim());
                        }
                        if (businessUnit && businessUnit.trim() !== '') {
                            businessUnits.add(businessUnit.trim());
                        }
                        if (location && location.trim() !== '') {
                            locations.add(location.trim());
                        }
                        if (spendBand && spendBand.trim() !== '') {
                            spendBands.add(spendBand.trim());
                        }
                    }

                    if (i % 100 === 0) {
                        updateProgress(70 + (i / data.length) * 20, `Processing row ${i + 1} of ${data.length}...`);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }

                updateProgress(90, 'Finalizing...');

                // Build available fields data for ALL columns in the uploaded data
                availableFieldsData = {};
                filterableFields.clear();

                // First, get all unique column names from the original data
                if (data.length > 0) {
                    const allColumns = Object.keys(data[0]);

                    // Process each column to collect unique values
                    allColumns.forEach(column => {
                        const columnKey = column.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
                        const uniqueValues = new Set();
                        let isNumeric = true;
                        let isDate = true;
                        let hasData = false;

                        // Collect unique values and detect data type
                        data.forEach(row => {
                            const value = row[column];
                            if (value && value.toString().trim() !== '') {
                                hasData = true;
                                const trimmedValue = value.toString().trim();
                                uniqueValues.add(trimmedValue);

                                // Check if numeric
                                if (isNumeric && isNaN(parseFloat(trimmedValue.replace(/[$,]/g, '')))) {
                                    isNumeric = false;
                                }

                                // Check if date
                                if (isDate && !Date.parse(trimmedValue)) {
                                    isDate = false;
                                }
                            }
                        });

                        // Skip columns that are primarily numeric or dates (not good for categorical filters)
                        // unless they have very few unique values (like year, month, etc.)
                        const shouldInclude = hasData && (!isNumeric || uniqueValues.size <= 20) && (!isDate || uniqueValues.size <= 50);

                        // Add to available fields if it has data and is suitable for filtering
                        if (shouldInclude && uniqueValues.size > 0) {
                            // Check if this is a field that should be filterable
                            const isFilterable = !['amount', 'spend', 'cost', 'value', 'price', 'total', 'spend amount',
                                'transactions', 'count', 'qty', 'quantity', 'transaction count',
                                'date', 'transaction date', 'purchase date', 'order date'].some(
                                    term => column.toLowerCase().includes(term.toLowerCase())
                                );

                            if (isFilterable) {
                                filterableFields.add(columnKey);
                                availableFieldsData[columnKey] = {
                                    displayName: column,
                                    originalColumn: column,
                                    values: uniqueValues,
                                    uniqueValues: uniqueValues.size,
                                    dataType: isNumeric ? 'numeric' : (isDate ? 'date' : 'text'),
                                    isFilterable: true
                                };
                            }
                        }
                    });
                }

                // Ensure our core filterable fields are properly mapped
                const filterableFieldMappings = {
                    category: { displayName: 'Category', values: categories },
                    subcategory: { displayName: 'Subcategory', values: subcategories },
                    businessunit: { displayName: 'Business Unit', values: businessUnits },
                    location: { displayName: 'Location', values: locations },
                    supplier: { displayName: 'Supplier', values: new Set(processedData.map(row => row.supplier)) }
                };

                // Add core filterable fields
                Object.entries(filterableFieldMappings).forEach(([key, data]) => {
                    if (data.values.size > 0) {
                        filterableFields.add(key);
                        availableFieldsData[key] = {
                            ...availableFieldsData[key],
                            displayName: data.displayName,
                            values: data.values,
                            uniqueValues: data.values.size,
                            isFilterable: true,
                            isCore: ['category', 'subcategory', 'supplier', 'location'].includes(key)
                        };
                    }
                });

                // Add spendBand if it exists
                if (spendBands.size > 1) {
                    filterableFields.add('spendband');
                    availableFieldsData.spendband = {
                        displayName: 'Spend Band',
                        values: spendBands,
                        uniqueValues: spendBands.size,
                        isFilterable: true
                    };
                }

                // Store processed data
                rawData = processedData;
                filteredData = [...rawData];

                debugLog('Data processing complete', {
                    totalRows: processedData.length,
                    categories: Array.from(categories),
                    businessUnits: Array.from(businessUnits),
                    locations: Array.from(locations),
                    spendBands: Array.from(spendBands),
                    availableFields: Object.keys(availableFieldsData).map(key => ({
                        key: key,
                        displayName: availableFieldsData[key].displayName,
                        uniqueValues: availableFieldsData[key].uniqueValues,
                        dataType: availableFieldsData[key].dataType || 'text'
                    }))
                });

                // Calculate analytics
                calculateCategoryAnalytics();
                calculateParetoAnalytics();
                calculateSpendbandAnalytics();

                // Load filter configuration first
                loadFilterConfiguration();

                // Use dynamic filter system
                rebuildFilters();
                updateDashboard();

                // Show SpendBand table and insights if SpendBand data exists
                if (spendBands.size > 1) {
                    const spendBandContainer = safeGetElement('spendBandContainer');
                    const spendbandInsights = safeGetElement('spendbandInsights');
                    if (spendBandContainer) {
                        spendBandContainer.style.display = 'block';
                    }
                    if (spendbandInsights) {
                        spendbandInsights.style.display = 'block';
                    }
                    updateSpendBandTable();
                    updateSpendbandInsights();
                }

                updateProgress(100, 'Complete!');

                const categoriesArray = Array.from(categories);
                const spendBandsArray = Array.from(spendBands);
                showStatus(`Successfully loaded ${processedData.length} transactions with ${categoriesArray.length} categories: ${categoriesArray.join(', ')}${spendBandsArray.length > 1 ? ` and ${spendBandsArray.length} spend bands: ${spendBandsArray.join(', ')}` : ''}`, 'success');

                // Hide upload section and show dashboard
                setTimeout(() => {
                    const uploadSection = safeGetElement('uploadSection');
                    const dashboard = safeGetElement('dashboard');
                    const generateReportBtn = document.querySelector('.generate-report-btn');

                    if (uploadSection) uploadSection.classList.add('hidden');
                    if (dashboard) dashboard.style.display = 'block';
                    if (generateReportBtn) generateReportBtn.style.display = 'inline-block';
                }, 1000);

            } catch (error) {
                debugLog('Data processing error', error);
                showStatus('Error processing data: ' + error.message, 'error');
                showProgress(false);
            }
        }

        function findColumn(data, possibleNames) {
            if (data.length === 0) return null;

            const headers = Object.keys(data[0]);
            for (const name of possibleNames) {
                const found = headers.find(h => h.toLowerCase().includes(name.toLowerCase()));
                if (found) return found;
            }
            return null;
        }

        function getColumnValue(row, columnName) {
            if (!columnName) return null;
            return row[columnName];
        }

        function parseAmount(amountStr) {
            if (!amountStr) return 0;

            // Remove currency symbols and formatting
            const cleanStr = amountStr.toString()
                .replace(/[$Â£â‚¬Â¥,\s]/g, '')
                .replace(/[()]/g, '-');

            const amount = parseFloat(cleanStr);
            return isNaN(amount) ? 0 : Math.abs(amount);
        }

        function parseDate(dateStr) {
            if (!dateStr) return new Date(); // Default to current date if no date provided

            // Check if it's a number (Excel serial date)
            if (typeof dateStr === 'number' || (!isNaN(dateStr) && !isNaN(parseFloat(dateStr)))) {
                const excelDate = parseFloat(dateStr);

                // Excel dates start from 1900-01-01 (serial number 1)
                // But Excel incorrectly treats 1900 as a leap year, so we need to adjust
                // Also, Excel serial dates start at 1, not 0

                // Check if it's a valid Excel date (must be positive and reasonable)
                if (excelDate > 0 && excelDate < 100000) {
                    // Excel epoch is December 30, 1899 (due to the 1900 leap year bug)
                    const msPerDay = 24 * 60 * 60 * 1000;
                    const excelEpoch = new Date(1899, 11, 30).getTime();

                    // Convert Excel serial date to JavaScript date
                    const date = new Date(excelEpoch + excelDate * msPerDay);

                    if (!isNaN(date.getTime())) {
                        return date;
                    }
                }
            }

            // Convert to string if it's not already
            const dateString = String(dateStr).trim();

            // First, try MM/DD/YYYY format (most common in US datasets)
            if (dateString.includes('/')) {
                const parts = dateString.split('/');
                if (parts.length === 3) {
                    const month = parseInt(parts[0]) - 1; // Month is 0-indexed in JavaScript
                    const day = parseInt(parts[1]);
                    const year = parseInt(parts[2]);

                    // Validate the parsed values
                    if (!isNaN(month) && !isNaN(day) && !isNaN(year) &&
                        month >= 0 && month <= 11 &&
                        day >= 1 && day <= 31 &&
                        year >= 1900 && year <= 2100) {
                        const parsedDate = new Date(year, month, day);
                        if (!isNaN(parsedDate.getTime())) {
                            return parsedDate;
                        }
                    }
                }
            }

            // Try other common formats with dashes
            if (dateString.includes('-')) {
                const parts = dateString.split('-');
                if (parts.length === 3) {
                    // Try YYYY-MM-DD format
                    if (parts[0].length === 4) {
                        const year = parseInt(parts[0]);
                        const month = parseInt(parts[1]) - 1;
                        const day = parseInt(parts[2]);
                        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                            const parsedDate = new Date(year, month, day);
                            if (!isNaN(parsedDate.getTime())) {
                                return parsedDate;
                            }
                        }
                    }
                    // Try MM-DD-YYYY format
                    else {
                        const month = parseInt(parts[0]) - 1;
                        const day = parseInt(parts[1]);
                        const year = parseInt(parts[2]);
                        if (!isNaN(month) && !isNaN(day) && !isNaN(year)) {
                            const parsedDate = new Date(year, month, day);
                            if (!isNaN(parsedDate.getTime())) {
                                return parsedDate;
                            }
                        }
                    }
                }
            }

            // As a last resort, try the generic Date constructor
            const date = new Date(dateString);
            if (!isNaN(date.getTime())) {
                return date;
            }

            // If all parsing fails, return current date
            console.warn('Could not parse date:', dateString, 'using current date instead');
            return new Date();
        }

        // Enhanced Analytics Calculations
        function calculateCategoryAnalytics() {
            categoryAnalytics = {};

            // Group data by category
            const categoryGroups = {};
            filteredData.forEach(row => {
                if (!categoryGroups[row.category]) {
                    categoryGroups[row.category] = [];
                }
                categoryGroups[row.category].push(row);
            });

            // Calculate analytics for each category
            Object.entries(categoryGroups).forEach(([category, data]) => {
                const subcategoryData = {};
                const supplierData = {};

                data.forEach(row => {
                    // Subcategory analysis
                    if (!subcategoryData[row.subcategory]) {
                        subcategoryData[row.subcategory] = { spend: 0, count: 0 };
                    }
                    subcategoryData[row.subcategory].spend += row.amount;
                    subcategoryData[row.subcategory].count++;

                    // Supplier analysis
                    if (!supplierData[row.supplier]) {
                        supplierData[row.supplier] = 0;
                    }
                    supplierData[row.supplier] += row.amount;
                });

                const totalSpend = data.reduce((sum, r) => sum + r.amount, 0);
                const subcategories = Object.keys(subcategoryData);
                const suppliers = Object.keys(supplierData);

                // Find top subcategory
                const topSubcategory = Object.entries(subcategoryData)
                    .sort((a, b) => b[1].spend - a[1].spend)[0];

                // Calculate concentration (Herfindahl Index for suppliers)
                const supplierShares = Object.values(supplierData).map(spend => spend / totalSpend);
                const concentration = supplierShares.reduce((sum, share) => sum + (share * share), 0);

                // Risk assessment
                let riskLevel = 'Low';
                if (suppliers.length <= 2) riskLevel = 'High';
                else if (suppliers.length <= 5) riskLevel = 'Medium';
                else if (concentration > 0.5) riskLevel = 'Medium';

                categoryAnalytics[category] = {
                    totalSpend,
                    subcategoryCount: subcategories.length,
                    supplierCount: suppliers.length,
                    topSubcategory: topSubcategory ? topSubcategory[0] : 'N/A',
                    topSubcategorySpend: topSubcategory ? topSubcategory[1].spend : 0,
                    concentration: concentration,
                    riskLevel,
                    avgSpendPerSupplier: totalSpend / suppliers.length,
                    subcategoryData,
                    supplierData
                };
            });

            debugLog('Category analytics calculated', categoryAnalytics);
        }

        function calculateParetoAnalytics() {
            // Aggregate by supplier
            const supplierData = {};
            filteredData.forEach(row => {
                if (!supplierData[row.supplier]) {
                    supplierData[row.supplier] = 0;
                }
                supplierData[row.supplier] += row.amount;
            });

            const sortedSuppliers = Object.entries(supplierData)
                .sort((a, b) => b[1] - a[1]);

            const totalSpend = sortedSuppliers.reduce((sum, [, spend]) => sum + spend, 0);
            let cumulativeSpend = 0;

            const paretoData = sortedSuppliers.map(([supplier, spend], index) => {
                cumulativeSpend += spend;
                const cumulativePercentage = (cumulativeSpend / totalSpend) * 100;

                return {
                    rank: index + 1,
                    supplier,
                    spend,
                    cumulativeSpend,
                    cumulativePercentage,
                    percentage: (spend / totalSpend) * 100
                };
            });

            // Find 80% threshold
            const eightyPercentIndex = paretoData.findIndex(d => d.cumulativePercentage >= 80);
            const ninetyPercentIndex = paretoData.findIndex(d => d.cumulativePercentage >= 90);

            paretoAnalytics = {
                totalSuppliers: sortedSuppliers.length,
                totalSpend,
                eightyPercentSuppliers: eightyPercentIndex + 1,
                ninetyPercentSuppliers: ninetyPercentIndex + 1,
                eightyPercentSpend: paretoData[eightyPercentIndex]?.cumulativeSpend || 0,
                ninetyPercentSpend: paretoData[ninetyPercentIndex]?.cumulativeSpend || 0,
                topSupplierSpend: paretoData[0]?.spend || 0,
                topSupplierPercentage: paretoData[0]?.percentage || 0,
                paretoData
            };

            debugLog('Pareto analytics calculated', paretoAnalytics);
        }

        // Enhanced SpendBand Analytics with Procurement Specialist Insights
        function calculateSpendbandAnalytics() {
            const spendBandData = {};
            const suppliersByBand = {};
            const categoriesByBand = {};

            filteredData.forEach(row => {
                if (!spendBandData[row.spendBand]) {
                    spendBandData[row.spendBand] = {
                        spend: 0,
                        suppliers: new Set(),
                        transactions: 0,
                        categories: new Set()
                    };
                    suppliersByBand[row.spendBand] = {};
                    categoriesByBand[row.spendBand] = {};
                }

                spendBandData[row.spendBand].spend += row.amount;
                spendBandData[row.spendBand].suppliers.add(row.supplier);
                spendBandData[row.spendBand].transactions += row.transactions;
                spendBandData[row.spendBand].categories.add(row.category);

                // Track supplier spend within each band
                if (!suppliersByBand[row.spendBand][row.supplier]) {
                    suppliersByBand[row.spendBand][row.supplier] = 0;
                }
                suppliersByBand[row.spendBand][row.supplier] += row.amount;

                // Track category spend within each band
                if (!categoriesByBand[row.spendBand][row.category]) {
                    categoriesByBand[row.spendBand][row.category] = 0;
                }
                categoriesByBand[row.spendBand][row.category] += row.amount;
            });

            const totalSpend = filteredData.reduce((sum, r) => sum + r.amount, 0);
            const totalSuppliers = new Set(filteredData.map(r => r.supplier)).size;

            // Calculate advanced metrics for each spend band
            Object.entries(spendBandData).forEach(([band, data]) => {
                const bandSuppliers = Array.from(data.suppliers);
                const bandCategories = Array.from(data.categories);

                // Calculate concentration within band
                const supplierSpends = Object.values(suppliersByBand[band]);
                const supplierShares = supplierSpends.map(spend => spend / data.spend);
                const herfindahlIndex = supplierShares.reduce((sum, share) => sum + (share * share), 0);

                // Calculate category diversity
                const categorySpends = Object.values(categoriesByBand[band]);
                const categoryShares = categorySpends.map(spend => spend / data.spend);
                const categoryConcentration = categoryShares.reduce((sum, share) => sum + (share * share), 0);

                // Risk assessment
                let riskLevel = 'Low';
                let managementComplexity = 'Simple';
                let strategicImportance = 'Tactical';

                if (data.spend / totalSpend > 0.3) {
                    strategicImportance = 'Critical';
                    riskLevel = 'High';
                } else if (data.spend / totalSpend > 0.15) {
                    strategicImportance = 'Strategic';
                    riskLevel = 'Medium';
                }

                if (bandSuppliers.length > 50) {
                    managementComplexity = 'Complex';
                } else if (bandSuppliers.length > 20) {
                    managementComplexity = 'Moderate';
                }

                if (herfindahlIndex > 0.5) {
                    riskLevel = Math.max(riskLevel, 'Medium');
                }

                spendBandData[band] = {
                    ...data,
                    supplierCount: bandSuppliers.length,
                    categoryCount: bandCategories.length,
                    spendPercentage: (data.spend / totalSpend) * 100,
                    supplierPercentage: (bandSuppliers.length / totalSuppliers) * 100,
                    avgSpendPerSupplier: data.spend / bandSuppliers.length,
                    avgTransactionsPerSupplier: data.transactions / bandSuppliers.length,
                    herfindahlIndex,
                    categoryConcentration,
                    riskLevel,
                    managementComplexity,
                    strategicImportance,
                    topSupplier: Object.entries(suppliersByBand[band])
                        .sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A',
                    topCategory: Object.entries(categoriesByBand[band])
                        .sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A'
                };
            });

            spendbandAnalytics = {
                totalSpendBands: Object.keys(spendBandData).length,
                spendBandData,
                totalSpend,
                totalSuppliers,
                suppliersByBand,
                categoriesByBand
            };

            debugLog('SpendBand analytics calculated', spendbandAnalytics);
        }

        function populateFilters(categories, subcategories, businessUnits, locations) {
            debugLog('Populating filters', {
                categoriesCount: categories.size,
                categoriesList: Array.from(categories),
                subcategoriesCount: subcategories.size,
                businessUnitsCount: businessUnits.size,
                locationsCount: locations.size
            });

            // Populate category filter
            const categoryFilter = safeGetElement('categoryFilter');
            if (categoryFilter) {
                categoryFilter.innerHTML = '<option value="">All Categories</option>';
                const sortedCategories = Array.from(categories).sort();
                sortedCategories.forEach(category => {
                    if (category && category.trim() !== '') {
                        categoryFilter.innerHTML += `<option value="${category}">${category}</option>`;
                    }
                });
                debugLog('Category filter populated', { count: sortedCategories.length, categories: sortedCategories });
            }

            // Initialize subcategory filter - will be populated by updateSubcategoryFilter
            updateSubcategoryFilter();

            // Populate business unit filter
            const businessUnitFilter = safeGetElement('businessUnitFilter');
            if (businessUnitFilter) {
                businessUnitFilter.innerHTML = '<option value="">All Business Units</option>';
                Array.from(businessUnits).sort().forEach(unit => {
                    if (unit && unit.trim() !== '') {
                        businessUnitFilter.innerHTML += `<option value="${unit}">${unit}</option>`;
                    }
                });
            }

            // Populate location filter
            const locationFilter = safeGetElement('locationFilter');
            if (locationFilter) {
                locationFilter.innerHTML = '<option value="">All Locations</option>';
                Array.from(locations).sort().forEach(location => {
                    if (location && location.trim() !== '') {
                        locationFilter.innerHTML += `<option value="${location}">${location}</option>`;
                    }
                });
            }
        }

        function updateSubcategoryFilter() {
            // Check if both category and subcategory are in the current filter configuration
            const fieldsToFilter = selectedFilterFields.length > 0 ? selectedFilterFields : defaultFilterFields;
            if (!fieldsToFilter.includes('category') || !fieldsToFilter.includes('subcategory')) {
                return; // Skip if either filter is not configured
            }

            const categoryFilter = safeGetElement('categoryFilter');
            const subcategoryFilter = safeGetElement('subcategoryFilter');

            if (!categoryFilter || !subcategoryFilter) return;

            const selectedCategory = categoryFilter.value;
            const previousSubcategory = subcategoryFilter.value;

            // Clear subcategory filter
            subcategoryFilter.innerHTML = '<option value="">All Subcategories</option>';

            if (selectedCategory && categorySubcategoryMap[selectedCategory]) {
                // Get subcategories for the selected category
                const subcategories = Array.from(categorySubcategoryMap[selectedCategory]).sort();

                subcategories.forEach(subcategory => {
                    if (subcategory && subcategory.trim() !== '') {
                        subcategoryFilter.innerHTML += `<option value="${subcategory}">${subcategory}</option>`;
                    }
                });

                // Try to restore previous selection if it exists in the new list
                if (previousSubcategory && subcategories.includes(previousSubcategory)) {
                    subcategoryFilter.value = previousSubcategory;
                }
            } else {
                // If no category is selected, show all subcategories
                const allSubcategories = new Set();
                Object.values(categorySubcategoryMap).forEach(subcatSet => {
                    subcatSet.forEach(subcat => allSubcategories.add(subcat));
                });

                Array.from(allSubcategories).sort().forEach(subcategory => {
                    if (subcategory && subcategory.trim() !== '') {
                        subcategoryFilter.innerHTML += `<option value="${subcategory}">${subcategory}</option>`;
                    }
                });
            }

            debugLog('Subcategory filter updated', {
                selectedCategory,
                subcategoriesCount: subcategoryFilter.options.length - 1
            });
        }

        function applyFilters() {
            // Get current filter configuration
            const fieldsToFilter = selectedFilterFields.length > 0 ? selectedFilterFields : defaultFilterFields;
            const filterValues = {};

            // Collect values from all configured filters
            fieldsToFilter.forEach(fieldKey => {
                if (fieldKey === 'supplier') {
                    const supplierFilter = safeGetElement('supplierFilter');
                    filterValues.supplier = supplierFilter ? supplierFilter.value.toLowerCase() : '';
                } else {
                    const filter = safeGetElement(fieldKey + 'Filter');
                    filterValues[fieldKey] = filter ? filter.value : '';
                }
            });

            // Apply filters to data
            filteredData = rawData.filter(row => {
                return fieldsToFilter.every(fieldKey => {
                    const filterValue = filterValues[fieldKey];

                    if (!filterValue) return true; // No filter applied for this field

                    // Special handling for supplier (text search)
                    if (fieldKey === 'supplier') {
                        return row.supplier && row.supplier.toLowerCase().includes(filterValue);
                    }

                    // For core fields that exist in processed data
                    if (row.hasOwnProperty(fieldKey)) {
                        const rowValue = row[fieldKey];
                        return rowValue && rowValue.toString() === filterValue;
                    }

                    // For custom fields from original data
                    if (row._originalData && availableFieldsData[fieldKey]) {
                        const originalColumn = availableFieldsData[fieldKey].originalColumn;
                        const originalValue = row._originalData[originalColumn];

                        // Handle different data types
                        if (originalValue === null || originalValue === undefined || originalValue === '') {
                            return filterValue === '';
                        }

                        return originalValue.toString().trim() === filterValue;
                    }

                    // If field doesn't exist anywhere, don't filter on it
                    return true;
                });
            });

            debugLog('Filters applied', {
                originalCount: rawData.length,
                filteredCount: filteredData.length,
                activeFilters: filterValues,
                fieldsToFilter: fieldsToFilter,
                availableFields: Object.keys(availableFieldsData)
            });

            // Recalculate analytics with filtered data
            calculateCategoryAnalytics();
            calculateParetoAnalytics();
            calculateSpendbandAnalytics();
            updateDashboard();
        }

        function clearFilters() {
            // Get current filter configuration
            const fieldsToFilter = selectedFilterFields.length > 0 ? selectedFilterFields : defaultFilterFields;

            // Clear all configured filters
            fieldsToFilter.forEach(fieldKey => {
                const filter = safeGetElement(fieldKey + 'Filter');
                if (filter) {
                    filter.value = '';
                }
            });

            // Update subcategory filter if category is one of the filters
            if (fieldsToFilter.includes('category') && fieldsToFilter.includes('subcategory')) {
                updateSubcategoryFilter();
            }

            filteredData = [...rawData];
            calculateCategoryAnalytics();
            calculateParetoAnalytics();
            calculateSpendbandAnalytics();
            updateDashboard();
        }

        function updateDashboard() {
            updateStats();
            updateCharts();
            updateTables();
            updateCategoryInsights();
            updateSubcategorySummary();
            updateParetoInsights();
            updateSpendBandTable();
            updateSpendbandInsights();
            updateSeasonalityAnalysis();
            updateTailSpendAnalysis();
            updateVendorConsolidationAnalysis(); // Add consolidation analysis
            updatePredictiveAnalytics(); // Add predictive analytics
            updateMaverickSpendAnalysis(); // Add maverick spend analysis
            updateContractOptimizationAnalysis(); // Add contract optimization analysis
        }

        function updateStats() {
            const totalSpend = filteredData.reduce((sum, r) => sum + r.amount, 0);
            const totalTransactions = filteredData.reduce((sum, r) => sum + r.transactions, 0);
            const uniqueCategories = new Set(filteredData.map(r => r.category)).size;
            const uniqueSuppliers = new Set(filteredData.map(r => r.supplier)).size;
            const avgTransaction = totalTransactions > 0 ? totalSpend / totalTransactions : 0;

            const statsGrid = safeGetElement('statsGrid');
            if (statsGrid) {
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-value">$${totalSpend.toFixed(0).toLocaleString()}</div>
                        <div class="stat-label">Total Spend</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalTransactions.toLocaleString()}</div>
                        <div class="stat-label">Transactions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${uniqueCategories}</div>
                        <div class="stat-label">Categories</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${uniqueSuppliers}</div>
                        <div class="stat-label">Suppliers</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">$${avgTransaction.toFixed(0).toLocaleString()}</div>
                        <div class="stat-label">Avg Transaction</div>
                    </div>
                `;
            }
        }

        // Enhanced Category Insights
        function updateCategoryInsights() {
            const insights = safeGetElement('categoryInsights');
            if (!insights) return;

            const categories = Object.keys(categoryAnalytics);
            const totalSpend = filteredData.reduce((sum, r) => sum + r.amount, 0);

            // Calculate key insights
            const mostComplexCategory = categories.reduce((max, cat) =>
                categoryAnalytics[cat].subcategoryCount > categoryAnalytics[max]?.subcategoryCount ? cat : max, categories[0]);

            const riskiestCategory = categories.reduce((max, cat) =>
                categoryAnalytics[cat].riskLevel === 'High' ? cat : max, null);

            const mostConcentratedCategory = categories.reduce((max, cat) =>
                categoryAnalytics[cat].concentration > categoryAnalytics[max]?.concentration ? cat : max, categories[0]);

            const avgSubcategoriesPerCategory = categories.length > 0 ?
                categories.reduce((sum, cat) => sum + categoryAnalytics[cat].subcategoryCount, 0) / categories.length : 0;

            insights.innerHTML = `
                <div class="insight-card">
                    <div class="insight-value">${categories.length}</div>
                    <div class="insight-label">Total Categories</div>
                    <div class="insight-detail">Across all business units</div>
                </div>
                <div class="insight-card">
                    <div class="insight-value">${mostComplexCategory || 'N/A'}</div>
                    <div class="insight-label">Most Complex Category</div>
                    <div class="insight-detail">${categoryAnalytics[mostComplexCategory]?.subcategoryCount || 0} subcategories</div>
                </div>
                <div class="insight-card">
                    <div class="insight-value">${avgSubcategoriesPerCategory.toFixed(1)}</div>
                    <div class="insight-label">Avg Subcategories</div>
                    <div class="insight-detail">Per category</div>
                </div>
                <div class="insight-card">
                    <div class="insight-value">${riskiestCategory || 'None'}</div>
                    <div class="insight-label">Highest Risk Category</div>
                    <div class="insight-detail">${riskiestCategory ? 'Supplier concentration risk' : 'All categories low risk'}</div>
                </div>
            `;
        }

        // Subcategory Summary
        function updateSubcategorySummary() {
            const summary = safeGetElement('subcategoryGrid');
            if (!summary) return;

            const categories = Object.keys(categoryAnalytics);

            summary.innerHTML = categories.map(category => {
                const analytics = categoryAnalytics[category];
                return `
                    <div class="subcategory-item">
                        <div class="subcategory-category">${category}</div>
                        <div class="subcategory-count">${analytics.subcategoryCount}</div>
                        <div class="subcategory-detail">Subcategories</div>
                        <div class="subcategory-detail">Top: ${analytics.topSubcategory}</div>
                    </div>
                `;
            }).join('');
        }

        // Enhanced Pareto Insights
        function updateParetoInsights() {
            const metrics = safeGetElement('paretoMetrics');
            const interpretation = safeGetElement('paretoInterpretation');

            if (!metrics || !interpretation) return;

            const { totalSuppliers, eightyPercentSuppliers, ninetyPercentSuppliers,
                topSupplierPercentage, paretoData } = paretoAnalytics;

            // Calculate efficiency metrics
            const eightyPercentEfficiency = ((eightyPercentSuppliers / totalSuppliers) * 100).toFixed(1);
            const ninetyPercentEfficiency = ((ninetyPercentSuppliers / totalSuppliers) * 100).toFixed(1);

            metrics.innerHTML = `
                <div class="pareto-metric">
                    <div class="pareto-metric-value">${eightyPercentSuppliers}</div>
                    <div class="pareto-metric-label">Suppliers (80% spend)</div>
                </div>
                <div class="pareto-metric">
                    <div class="pareto-metric-value">${eightyPercentEfficiency}%</div>
                    <div class="pareto-metric-label">Efficiency Ratio</div>
                </div>
                <div class="pareto-metric">
                    <div class="pareto-metric-value">${topSupplierPercentage.toFixed(1)}%</div>
                    <div class="pareto-metric-label">Top Supplier Share</div>
                </div>
                <div class="pareto-metric">
                    <div class="pareto-metric-value">${ninetyPercentSuppliers}</div>
                    <div class="pareto-metric-label">Suppliers (90% spend)</div>
                </div>
            `;

            // Generate interpretation
            let interpretationText = '';
            let strategicRecommendation = '';

            if (eightyPercentEfficiency < 20) {
                interpretationText = `<strong>Excellent Pareto Distribution:</strong> Only ${eightyPercentEfficiency}% of suppliers account for 80% of spend, indicating a highly efficient supplier base with strong concentration among key partners.`;
                strategicRecommendation = 'Focus on deepening partnerships with top suppliers and implementing strategic supplier development programs.';
            } else if (eightyPercentEfficiency < 40) {
                interpretationText = `<strong>Good Pareto Distribution:</strong> ${eightyPercentEfficiency}% of suppliers account for 80% of spend, showing reasonable concentration but with room for optimization.`;
                strategicRecommendation = 'Consider supplier consolidation opportunities and strengthen relationships with top-performing suppliers.';
            } else {
                interpretationText = `<strong>Fragmented Supplier Base:</strong> ${eightyPercentEfficiency}% of suppliers are needed for 80% of spend, indicating a highly fragmented supplier base that may benefit from consolidation.`;
                strategicRecommendation = 'Prioritize supplier consolidation initiatives and evaluate opportunities to reduce supplier base complexity.';
            }

            if (topSupplierPercentage > 30) {
                interpretationText += ` <strong>High Dependency Risk:</strong> The top supplier represents ${topSupplierPercentage.toFixed(1)}% of total spend, creating potential supply chain risk.`;
                strategicRecommendation += ' Develop alternative suppliers to reduce dependency risk.';
            }

            interpretation.innerHTML = `
                <div class="interpretation-title">ðŸ“Š Strategic Analysis & Recommendations</div>
                <div class="interpretation-text">
                    ${interpretationText}
                    <br><br>
                    <strong>Recommended Actions:</strong> ${strategicRecommendation}
                </div>
            `;
        }

        // Enhanced SpendBand Insights with Procurement Specialist Intelligence
        function updateSpendbandInsights() {
            const metrics = safeGetElement('spendbandMetrics');
            const interpretation = safeGetElement('spendbandInterpretation');

            if (!metrics || !interpretation || !spendbandAnalytics.spendBandData) return;

            const { spendBandData, totalSpend, totalSuppliers } = spendbandAnalytics;
            const spendBands = Object.keys(spendBandData);

            // Calculate key metrics
            const highRiskBands = spendBands.filter(band => spendBandData[band].riskLevel === 'High').length;
            const strategicBands = spendBands.filter(band => spendBandData[band].strategicImportance === 'Strategic' || spendBandData[band].strategicImportance === 'Critical').length;
            const complexBands = spendBands.filter(band => spendBandData[band].managementComplexity === 'Complex').length;

            // Find most critical band
            const mostCriticalBand = spendBands.reduce((max, band) =>
                spendBandData[band].spendPercentage > spendBandData[max]?.spendPercentage ? band : max, spendBands[0]);

            // Find most fragmented band
            const mostFragmentedBand = spendBands.reduce((max, band) =>
                spendBandData[band].supplierCount > spendBandData[max]?.supplierCount ? band : max, spendBands[0]);

            metrics.innerHTML = `
                <div class="spendband-metric">
                    <div class="spendband-metric-value">${spendBands.length}</div>
                    <div class="spendband-metric-label">Active SpendBands</div>
                    <div class="spendband-metric-detail">Segmentation complexity</div>
                </div>
                <div class="spendband-metric">
                    <div class="spendband-metric-value">${strategicBands}</div>
                    <div class="spendband-metric-label">Strategic Bands</div>
                    <div class="spendband-metric-detail">Requiring executive attention</div>
                </div>
                <div class="spendband-metric">
                    <div class="spendband-metric-value">${mostCriticalBand || 'N/A'}</div>
                    <div class="spendband-metric-label">Highest Impact Band</div>
                    <div class="spendband-metric-detail">${spendBandData[mostCriticalBand]?.spendPercentage.toFixed(1)}% of total spend</div>
                </div>
                <div class="spendband-metric">
                    <div class="spendband-metric-value">${highRiskBands}</div>
                    <div class="spendband-metric-label">High Risk Bands</div>
                    <div class="spendband-metric-detail">Concentration concerns</div>
                </div>
                <div class="spendband-metric">
                    <div class="spendband-metric-value">${mostFragmentedBand || 'N/A'}</div>
                    <div class="spendband-metric-label">Most Fragmented</div>
                    <div class="spendband-metric-detail">${spendBandData[mostFragmentedBand]?.supplierCount} suppliers</div>
                </div>
                <div class="spendband-metric">
                    <div class="spendband-metric-value">${complexBands}</div>
                    <div class="spendband-metric-label">Complex Bands</div>
                    <div class="spendband-metric-detail">Management intensive</div>
                </div>
            `;

            // Generate comprehensive procurement specialist interpretation
            let interpretationText = '';
            let strategicRecommendations = [];
            let riskAssessment = '';

            // Analyze spend distribution
            const topBandSpend = Math.max(...spendBands.map(band => spendBandData[band].spendPercentage));
            if (topBandSpend > 40) {
                interpretationText += `<strong>ðŸ”´ High Concentration Risk:</strong> The ${mostCriticalBand} band represents ${topBandSpend.toFixed(1)}% of total spend, creating significant exposure. `;
                strategicRecommendations.push('Implement supplier diversification strategy within the dominant spend band');
                riskAssessment = 'HIGH - Concentration risk requires immediate attention';
            } else if (topBandSpend > 25) {
                interpretationText += `<strong>ðŸŸ¡ Moderate Concentration:</strong> The ${mostCriticalBand} band accounts for ${topBandSpend.toFixed(1)}% of spend, indicating balanced but monitored exposure. `;
                riskAssessment = 'MEDIUM - Monitor concentration levels';
            } else {
                interpretationText += `<strong>ðŸŸ¢ Well-Distributed Spend:</strong> Spend is well-balanced across bands with the largest (${mostCriticalBand}) at ${topBandSpend.toFixed(1)}%. `;
                riskAssessment = 'LOW - Healthy spend distribution';
            }

            // Analyze supplier fragmentation
            const avgSuppliersPerBand = spendBands.reduce((sum, band) => sum + spendBandData[band].supplierCount, 0) / spendBands.length;
            if (avgSuppliersPerBand > 30) {
                interpretationText += `<strong>Supplier Base Complexity:</strong> Average of ${avgSuppliersPerBand.toFixed(0)} suppliers per band indicates high management complexity. `;
                strategicRecommendations.push('Evaluate supplier consolidation opportunities to reduce administrative burden');
            }

            // Analyze strategic importance
            if (strategicBands > spendBands.length * 0.6) {
                interpretationText += `<strong>Strategic Portfolio:</strong> ${strategicBands} of ${spendBands.length} bands are strategically important, requiring dedicated relationship management. `;
                strategicRecommendations.push('Establish dedicated category managers for strategic spend bands');
            }

            // Risk band analysis
            if (highRiskBands > 0) {
                interpretationText += `<strong>âš ï¸ Risk Alert:</strong> ${highRiskBands} band(s) show high concentration risk requiring immediate supplier diversification. `;
                strategicRecommendations.push('Develop contingency plans for high-risk spend bands');
            }

            // Generate specific recommendations based on band characteristics
            spendBands.forEach(band => {
                const data = spendBandData[band];
                if (data.strategicImportance === 'Critical' && data.supplierCount < 3) {
                    strategicRecommendations.push(`${band}: Develop alternative suppliers to reduce single-source dependency`);
                }
                if (data.managementComplexity === 'Complex' && data.herfindahlIndex < 0.2) {
                    strategicRecommendations.push(`${band}: Consider supplier consolidation to improve efficiency`);
                }
                if (data.spendPercentage > 20 && data.categoryCount > 5) {
                    strategicRecommendations.push(`${band}: Implement category-specific sourcing strategies`);
                }
            });

            interpretation.innerHTML = `
                <div class="spendband-interpretation-title">
                    ðŸŽ¯ Procurement Specialist Strategic Analysis
                </div>
                <div class="spendband-interpretation-text">
                    ${interpretationText}
                    <br><br>
                    <strong>Overall Risk Assessment:</strong> <span class="risk-indicator risk-${riskAssessment.toLowerCase().split(' ')[0]}">${riskAssessment}</span>
                </div>
                <div class="spendband-recommendations">
                    <div class="spendband-recommendations-title">ðŸš€ Strategic Recommendations</div>
                    ${strategicRecommendations.slice(0, 6).map(rec =>
                `<div class="spendband-recommendation-item">${rec}</div>`
            ).join('')}
                </div>
            `;

            debugLog('SpendBand insights updated', {
                totalBands: spendBands.length,
                strategicBands,
                highRiskBands,
                recommendations: strategicRecommendations.length
            });
        }

        function updateCharts() {
            updateOverviewChart();
            updateCategoryChart();
            updateSupplierChart();
            updateParetoChart();
            updateStratificationChart();
        }

        function updateOverviewChart() {
            const canvas = safeGetElement('overviewChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Aggregate by category
            const categoryData = {};
            filteredData.forEach(row => {
                if (!categoryData[row.category]) {
                    categoryData[row.category] = { spend: 0, count: 0 };
                }
                categoryData[row.category].spend += row.amount;
                categoryData[row.category].count++;
            });

            const sortedCategories = Object.entries(categoryData)
                .sort((a, b) => b[1].spend - a[1].spend);

            debugLog('Overview chart - ALL CATEGORIES', {
                totalCategories: sortedCategories.length,
                categories: sortedCategories.map(([cat, data]) => ({
                    category: cat,
                    spend: data.spend,
                    count: data.count
                }))
            });

            if (charts.overview) charts.overview.destroy();

            const colors = generateColors(sortedCategories.length);

            charts.overview = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedCategories.map(([category]) => category),
                    datasets: [{
                        label: 'Total Spend',
                        data: sortedCategories.map(([, data]) => data.spend),
                        backgroundColor: colors
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `ALL Categories by Spend (${sortedCategories.length} categories found)`,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Spend ($)'
                            },
                            ticks: {
                                callback: function (value) {
                                    return '$' + (value / 1000000).toFixed(1) + 'M';
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateCategoryChart() {
            const canvas = safeGetElement('categoryChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Aggregate by category
            const categoryData = {};
            filteredData.forEach(row => {
                if (!categoryData[row.category]) {
                    categoryData[row.category] = 0;
                }
                categoryData[row.category] += row.amount;
            });

            const sortedCategories = Object.entries(categoryData)
                .sort((a, b) => b[1] - a[1]);

            if (charts.category) charts.category.destroy();

            const colors = generateColors(sortedCategories.length);

            charts.category = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: sortedCategories.map(([category]) => category),
                    datasets: [{
                        data: sortedCategories.map(([, spend]) => spend),
                        backgroundColor: colors
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Category Distribution by Spend',
                            font: { size: 16, weight: 'bold' }
                        }
                    }
                }
            });
        }

        function updateSupplierChart() {
            const canvas = safeGetElement('supplierChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Aggregate by supplier
            const supplierData = {};
            filteredData.forEach(row => {
                if (!supplierData[row.supplier]) {
                    supplierData[row.supplier] = 0;
                }
                supplierData[row.supplier] += row.amount;
            });

            const sortedSuppliers = Object.entries(supplierData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);

            if (charts.supplier) charts.supplier.destroy();

            charts.supplier = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedSuppliers.map(([supplier]) => supplier.length > 20 ? supplier.substring(0, 20) + '...' : supplier),
                    datasets: [{
                        label: 'Total Spend',
                        data: sortedSuppliers.map(([, spend]) => spend),
                        backgroundColor: '#667eea'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top 15 Suppliers by Spend',
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Spend ($)'
                            },
                            ticks: {
                                callback: function (value) {
                                    return '$' + (value / 1000000).toFixed(1) + 'M';
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateParetoChart() {
            const canvas = safeGetElement('paretoChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const { paretoData } = paretoAnalytics;

            if (charts.pareto) charts.pareto.destroy();

            const displayData = paretoData.slice(0, 20);

            charts.pareto = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: displayData.map(d => d.supplier.length > 15 ? d.supplier.substring(0, 15) + '...' : d.supplier),
                    datasets: [
                        {
                            label: 'Spend',
                            data: displayData.map(d => d.spend),
                            backgroundColor: '#667eea',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Cumulative %',
                            data: displayData.map(d => d.cumulativePercentage),
                            type: 'line',
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118, 75, 162, 0.1)',
                            yAxisID: 'y1',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Pareto Analysis - Top 20 Suppliers (80/20 Rule)',
                            font: { size: 16, weight: 'bold' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Spend ($)'
                            },
                            ticks: {
                                callback: function (value) {
                                    return '$' + (value / 1000000).toFixed(1) + 'M';
                                }
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Cumulative %'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                callback: function (value) {
                                    return value.toFixed(0) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Update Pareto table
            updateParetoTable();
        }

        function updateStratificationChart() {
            const canvas = safeGetElement('stratificationChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Stratify suppliers by spend levels
            const stratification = {
                strategic: { spend: 0, count: 0, range: '>$1M' },
                leverage: { spend: 0, count: 0, range: '$100K-$1M' },
                routine: { spend: 0, count: 0, range: '$10K-$100K' },
                tactical: { spend: 0, count: 0, range: '<$10K' }
            };

            const supplierData = {};
            filteredData.forEach(row => {
                if (!supplierData[row.supplier]) {
                    supplierData[row.supplier] = 0;
                }
                supplierData[row.supplier] += row.amount;
            });

            Object.entries(supplierData).forEach(([supplier, spend]) => {
                if (spend > 1000000) {
                    stratification.strategic.spend += spend;
                    stratification.strategic.count++;
                } else if (spend > 100000) {
                    stratification.leverage.spend += spend;
                    stratification.leverage.count++;
                } else if (spend > 10000) {
                    stratification.routine.spend += spend;
                    stratification.routine.count++;
                } else {
                    stratification.tactical.spend += spend;
                    stratification.tactical.count++;
                }
            });

            if (charts.stratification) charts.stratification.destroy();

            charts.stratification = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Strategic (>$1M)', 'Leverage ($100K-$1M)', 'Routine ($10K-$100K)', 'Tactical (<$10K)'],
                    datasets: [{
                        data: [
                            stratification.strategic.spend,
                            stratification.leverage.spend,
                            stratification.routine.spend,
                            stratification.tactical.spend
                        ],
                        backgroundColor: ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Spend Stratification by Supplier Segments',
                            font: { size: 16, weight: 'bold' }
                        }
                    }
                }
            });

            // Update stratification table
            updateStratificationTable(stratification);
        }

        function updateTables() {
            updateCategoryTable();
            updateSupplierTable();
        }

        // Enhanced Category Table
        function updateCategoryTable() {
            const totalSpend = filteredData.reduce((sum, r) => sum + r.amount, 0);
            const categories = Object.keys(categoryAnalytics);

            const tableBody = safeGetElement('categoryTableBody');
            if (tableBody) {
                tableBody.innerHTML = categories.map(category => {
                    const analytics = categoryAnalytics[category];
                    const percentage = (analytics.totalSpend / totalSpend * 100).toFixed(2);
                    const concentrationLevel = analytics.concentration > 0.5 ? 'High' :
                        analytics.concentration > 0.25 ? 'Medium' : 'Low';

                    return `
                        <tr class="clickable-row" onclick="openSubcategoryModal('${category}')" style="cursor: pointer;">
                            <td><strong>${category}</strong></td>
                            <td>$${analytics.totalSpend.toFixed(0).toLocaleString()}</td>
                            <td>${percentage}%</td>
                            <td>${analytics.subcategoryCount}</td>
                            <td>${analytics.topSubcategory}</td>
                            <td>${concentrationLevel}</td>
                            <td>${analytics.supplierCount}</td>
                            <td>$${analytics.avgSpendPerSupplier.toFixed(0).toLocaleString()}</td>
                            <td><span style="color: ${analytics.riskLevel === 'High' ? '#e74c3c' : analytics.riskLevel === 'Medium' ? '#f39c12' : '#2ecc71'};">${analytics.riskLevel}</span></td>
                            <td><span style="color: #667eea; font-weight: bold;">ðŸ‘† View Details</span></td>
                        </tr>
                    `;
                }).join('');
            }

            debugLog('Enhanced category table updated', {
                totalCategories: categories.length,
                analytics: categoryAnalytics
            });
        }

        function updateSupplierTable() {
            const supplierData = {};
            filteredData.forEach(row => {
                if (!supplierData[row.supplier]) {
                    supplierData[row.supplier] = {
                        spend: 0,
                        count: 0,
                        categories: new Set()
                    };
                }
                supplierData[row.supplier].spend += row.amount;
                supplierData[row.supplier].count++;
                supplierData[row.supplier].categories.add(row.category);
            });

            const sortedSuppliers = Object.entries(supplierData)
                .sort((a, b) => b[1].spend - a[1].spend);

            const totalSpend = filteredData.reduce((sum, r) => sum + r.amount, 0);

            const tableBody = safeGetElement('supplierTableBody');
            if (tableBody) {
                tableBody.innerHTML = sortedSuppliers.map(([supplier, data]) => {
                    const percentage = (data.spend / totalSpend * 100).toFixed(2);

                    return `
                        <tr>
                            <td><strong>${supplier}</strong></td>
                            <td>$${data.spend.toFixed(0).toLocaleString()}</td>
                            <td>${percentage}%</td>
                            <td>${data.count.toLocaleString()}</td>
                            <td>${data.categories.size}</td>
                        </tr>
                    `;
                }).join('');
            }
        }

        // Enhanced Pareto Table
        function updateParetoTable() {
            const { paretoData } = paretoAnalytics;
            const tableBody = safeGetElement('paretoTableBody');

            if (tableBody) {
                tableBody.innerHTML = paretoData.map((data, index) => {
                    let classification = '';
                    let priority = '';
                    let action = '';

                    if (data.cumulativePercentage <= 80) {
                        classification = 'ðŸ”´ Critical (80%)';
                        priority = 'Strategic';
                        action = 'Partnership Development';
                    } else if (data.cumulativePercentage <= 95) {
                        classification = 'ðŸŸ¡ Important (95%)';
                        priority = 'Tactical';
                        action = 'Performance Monitoring';
                    } else {
                        classification = 'ðŸŸ¢ Standard';
                        priority = 'Operational';
                        action = 'Routine Management';
                    }

                    return `
                        <tr>
                            <td><strong>#${data.rank}</strong></td>
                            <td><strong>${data.supplier}</strong></td>
                            <td>$${data.spend.toFixed(0).toLocaleString()}</td>
                            <td>${data.cumulativePercentage.toFixed(2)}%</td>
                            <td>${classification}</td>
                            <td>${priority}</td>
                            <td>${action}</td>
                        </tr>
                    `;
                }).join('');
            }
        }

        function updateStratificationTable(stratification) {
            const totalSpend = Object.values(stratification).reduce((sum, s) => sum + s.spend, 0);

            const tableBody = safeGetElement('stratificationTableBody');
            if (tableBody) {
                const strategies = {
                    strategic: 'Partnership & Innovation',
                    leverage: 'Competitive Bidding',
                    routine: 'Efficiency & Automation',
                    tactical: 'Consolidation'
                };

                tableBody.innerHTML = Object.entries(stratification).map(([segment, data]) => {
                    const percentage = totalSpend > 0 ? (data.spend / totalSpend * 100).toFixed(2) : '0.00';
                    const segmentName = segment.charAt(0).toUpperCase() + segment.slice(1);

                    return `
                        <tr>
                            <td><strong>${segmentName}</strong></td>
                            <td>${data.range}</td>
                            <td>$${data.spend.toFixed(0).toLocaleString()}</td>
                            <td>${percentage}%</td>
                            <td>${data.count}</td>
                            <td>${strategies[segment]}</td>
                        </tr>
                    `;
                }).join('');
            }
        }

        // Enhanced SpendBand Analysis Table with Improved Sorting
        function updateSpendBandTable() {
            const spendBandData = {};
            filteredData.forEach(row => {
                if (!spendBandData[row.spendBand]) {
                    spendBandData[row.spendBand] = {
                        spend: 0,
                        suppliers: new Set(),
                        transactions: 0
                    };
                }
                spendBandData[row.spendBand].spend += row.amount;
                spendBandData[row.spendBand].suppliers.add(row.supplier);
                spendBandData[row.spendBand].transactions += row.transactions;
            });

            // Enhanced SpendBand sorting function
            function sortSpendBands(spendBands) {
                return spendBands.sort((a, b) => {
                    const [bandA] = a;
                    const [bandB] = b;

                    // Handle common SpendBand patterns
                    const extractValue = (band) => {
                        // Handle ranges like "0-10K", "10K-100K", "100K-1M", "1M+"
                        const match = band.match(/(\d+(?:\.\d+)?)\s*([KMB]?)/i);
                        if (match) {
                            let value = parseFloat(match[1]);
                            const unit = match[2].toUpperCase();
                            if (unit === 'K') value *= 1000;
                            else if (unit === 'M') value *= 1000000;
                            else if (unit === 'B') value *= 1000000000;
                            return value;
                        }

                        // Handle tier-based naming like "Tier 1", "Tier 2"
                        const tierMatch = band.match(/tier\s*(\d+)/i);
                        if (tierMatch) {
                            return parseInt(tierMatch[1]);
                        }

                        // Handle level-based naming like "Level A", "Level B"
                        const levelMatch = band.match(/level\s*([A-Z])/i);
                        if (levelMatch) {
                            return levelMatch[1].charCodeAt(0);
                        }

                        // Default: alphabetical
                        return band.toLowerCase();
                    };

                    const valueA = extractValue(bandA);
                    const valueB = extractValue(bandB);

                    if (typeof valueA === 'number' && typeof valueB === 'number') {
                        return valueA - valueB;
                    }

                    return String(valueA).localeCompare(String(valueB));
                });
            }

            const sortedSpendBands = sortSpendBands(Object.entries(spendBandData));
            const totalSpend = filteredData.reduce((sum, r) => sum + r.amount, 0);

            const tableBody = safeGetElement('spendBandTableBody');
            if (tableBody) {
                tableBody.innerHTML = sortedSpendBands.map(([spendBand, data]) => {
                    const percentage = totalSpend > 0 ? (data.spend / totalSpend * 100).toFixed(2) : '0.00';
                    const avgSpendPerSupplier = data.suppliers.size > 0 ? data.spend / data.suppliers.size : 0;

                    return `
                        <tr>
                            <td><strong>${spendBand}</strong></td>
                            <td>$${data.spend.toFixed(0).toLocaleString()}</td>
                            <td>${percentage}%</td>
                            <td>${data.suppliers.size}</td>
                            <td>${data.transactions.toLocaleString()}</td>
                            <td>$${avgSpendPerSupplier.toFixed(0).toLocaleString()}</td>
                        </tr>
                    `;
                }).join('');
            }

            debugLog('SpendBand table updated with improved sorting', {
                totalSpendBands: sortedSpendBands.length,
                spendBands: sortedSpendBands.map(([band, data]) => ({
                    spendBand: band,
                    spend: data.spend,
                    suppliers: data.suppliers.size
                }))
            });
        }

        // Enhanced Subcategory Modal
        function openSubcategoryModal(category) {
            debugLog('Opening enhanced subcategory modal for category:', category);

            const categoryData = filteredData.filter(row => row.category === category);

            if (categoryData.length === 0) {
                alert('No data found for this category');
                return;
            }

            const analytics = categoryAnalytics[category];
            const subcategoryData = analytics.subcategoryData;
            const sortedSubcategories = Object.entries(subcategoryData)
                .sort((a, b) => b[1].spend - a[1].spend);

            const totalCategorySpend = analytics.totalSpend;

            // Update modal title
            const modalTitle = safeGetElement('modalTitle');
            if (modalTitle) {
                modalTitle.textContent = `${category} - Detailed Subcategory Analysis`;
            }

            // Update modal insights
            const modalInsights = safeGetElement('modalInsights');
            if (modalInsights) {
                const topSubcategory = sortedSubcategories[0];
                const topSubcategoryPercentage = topSubcategory ? (topSubcategory[1].spend / totalCategorySpend * 100).toFixed(1) : 0;

                modalInsights.innerHTML = `
                    <div class="insight-card">
                        <div class="insight-value">${sortedSubcategories.length}</div>
                        <div class="insight-label">Total Subcategories</div>
                        <div class="insight-detail">In ${category}</div>
                    </div>
                    <div class="insight-card">
                        <div class="insight-value">${topSubcategory ? topSubcategory[0] : 'N/A'}</div>
                        <div class="insight-label">Largest Subcategory</div>
                        <div class="insight-detail">${topSubcategoryPercentage}% of category spend</div>
                    </div>
                    <div class="insight-card">
                        <div class="insight-value">${analytics.supplierCount}</div>
                        <div class="insight-label">Total Suppliers</div>
                        <div class="insight-detail">Across all subcategories</div>
                    </div>
                    <div class="insight-card">
                        <div class="insight-value">${analytics.riskLevel}</div>
                        <div class="insight-label">Risk Level</div>
                        <div class="insight-detail">Based on supplier concentration</div>
                    </div>
                `;
            }

            // Update subcategory chart
            const canvas = safeGetElement('subcategoryChart');
            if (canvas) {
                const ctx = canvas.getContext('2d');

                if (charts.subcategory) charts.subcategory.destroy();

                const colors = generateColors(sortedSubcategories.length);

                charts.subcategory = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: sortedSubcategories.map(([subcategory]) => subcategory),
                        datasets: [{
                            data: sortedSubcategories.map(([, data]) => data.spend),
                            backgroundColor: colors
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${category} Subcategory Distribution`,
                                font: { size: 14, weight: 'bold' }
                            }
                        }
                    }
                });
            }

            // Update enhanced subcategory table
            const tableBody = safeGetElement('subcategoryTableBody');
            if (tableBody) {
                tableBody.innerHTML = sortedSubcategories.map(([subcategory, data]) => {
                    const percentage = (data.spend / totalCategorySpend * 100).toFixed(2);
                    const avgPerTransaction = data.count > 0 ? data.spend / data.count : 0;

                    // Calculate subcategory supplier concentration
                    const subcategorySuppliers = categoryData
                        .filter(row => row.subcategory === subcategory)
                        .reduce((acc, row) => {
                            acc[row.supplier] = (acc[row.supplier] || 0) + row.amount;
                            return acc;
                        }, {});

                    const supplierCount = Object.keys(subcategorySuppliers).length;
                    const supplierShares = Object.values(subcategorySuppliers).map(spend => spend / data.spend);
                    const concentration = supplierShares.reduce((sum, share) => sum + (share * share), 0);
                    const concentrationLevel = concentration > 0.5 ? 'High' : concentration > 0.25 ? 'Medium' : 'Low';

                    return `
                        <tr>
                            <td><strong>${subcategory}</strong></td>
                            <td>$${data.spend.toFixed(0).toLocaleString()}</td>
                            <td>${percentage}%</td>
                            <td>${data.count.toLocaleString()}</td>
                            <td>${supplierCount}</td>
                            <td>$${avgPerTransaction.toFixed(0).toLocaleString()}</td>
                            <td><span style="color: ${concentration > 0.5 ? '#e74c3c' : concentration > 0.25 ? '#f39c12' : '#2ecc71'};">${concentrationLevel}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            const modal = safeGetElement('subcategoryModal');
            if (modal) {
                modal.classList.add('show');
            }
        }

        function closeModal() {
            const modal = safeGetElement('subcategoryModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = safeGetElement('subcategoryModal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Navigation functions
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all nav tabs
            const navTabs = document.querySelectorAll('.nav-tab');
            navTabs.forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            const selectedTab = safeGetElement(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }

            // Add active class to clicked nav tab
            event.target.classList.add('active');
        }

        // Alert tab switching function for maverick spend
        function showAlertTab(tabName) {
            // Remove active class from all alert tabs and content
            document.querySelectorAll('.alert-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.alert-tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to selected tab and content
            const selectedBtn = document.querySelector(`[onclick="showAlertTab('${tabName}')"]`);
            const selectedContent = document.getElementById(`${tabName}-alert`);

            if (selectedBtn) selectedBtn.classList.add('active');
            if (selectedContent) selectedContent.classList.add('active');
        }

        // Utility functions
        function generateColors(count) {
            const colors = [];
            const baseColors = [
                '#667eea', '#764ba2', '#f093fb', '#f5576c',
                '#4facfe', '#00f2fe', '#43e97b', '#38f9d7',
                '#ffecd2', '#fcb69f', '#a8edea', '#fed6e3',
                '#ff9a9e', '#fecfef', '#ffeaa7', '#fab1a0'
            ];

            for (let i = 0; i < count; i++) {
                if (i < baseColors.length) {
                    colors.push(baseColors[i]);
                } else {
                    // Generate additional colors
                    const hue = (i * 137.508) % 360;
                    colors.push(`hsl(${hue}, 70%, 60%)`);
                }
            }
            return colors;
        }

        // Seasonality Analysis Functions
        function updateSeasonalityAnalysis() {
            if (filteredData.length === 0) {
                showSeasonalityMessage();
                return;
            }

            // Perform seasonality analysis
            seasonalityAnalytics = seasonalityAnalyzer.analyzeSeasonality(filteredData);

            if (seasonalityAnalytics.opportunities.length > 0) {
                displaySeasonalityResults();
            } else {
                showSeasonalityMessage();
            }
        }

        function showSeasonalityMessage() {
            const elements = ['seasonalityIntelligence', 'seasonalityCharts', 'opportunityCards'];
            elements.forEach(id => {
                const element = safeGetElement(id);
                if (element) element.style.display = 'none';
            });

            const messageElement = safeGetElement('noSeasonalityMessage');
            if (messageElement) messageElement.style.display = 'block';
        }

        function displaySeasonalityResults() {
            const messageElement = safeGetElement('noSeasonalityMessage');
            if (messageElement) messageElement.style.display = 'none';

            displaySeasonalityMetrics();
            displaySeasonalityChart();
            displayOpportunityCards();
        }

        function displaySeasonalityMetrics() {
            const intelligence = safeGetElement('seasonalityIntelligence');
            const metrics = safeGetElement('seasonalityMetrics');
            const insights = safeGetElement('seasonalityInsightsPanel');

            if (!intelligence || !metrics || !insights) return;

            intelligence.style.display = 'block';

            const summary = seasonalityAnalytics.summary;

            metrics.innerHTML = `
                <div class="seasonality-metric">
                    <div class="seasonality-metric-value">${summary.totalCategories}</div>
                    <div class="seasonality-metric-label">Categories Analyzed</div>
                </div>
                <div class="seasonality-metric">
                    <div class="seasonality-metric-value">${summary.totalOpportunities}</div>
                    <div class="seasonality-metric-label">Opportunities Found</div>
                </div>
                <div class="seasonality-metric">
                    <div class="seasonality-metric-value">${summary.highImpactOpportunities}</div>
                    <div class="seasonality-metric-label">High Impact</div>
                </div>
                <div class="seasonality-metric">
                    <div class="seasonality-metric-value">$${summary.totalSavingsPotential.toFixed(0).toLocaleString()}</div>
                    <div class="seasonality-metric-label">Savings Potential</div>
                </div>
            `;

            insights.innerHTML = `
                <div class="seasonality-insights-title">
                    ðŸŽ¯ Key Insights
                </div>
                <div class="seasonality-insights-text">
                    Analysis of ${summary.totalCategories} categories revealed ${summary.totalOpportunities} optimization opportunities 
                    with potential savings of $${summary.totalSavingsPotential.toFixed(0).toLocaleString()}. 
                    ${summary.highImpactOpportunities} high-impact opportunities identified for immediate action.
                </div>
            `;
        }

        function displaySeasonalityChart() {
            const chartContainer = safeGetElement('seasonalityCharts');
            const canvas = safeGetElement('seasonalityChart');

            if (!chartContainer || !canvas) return;

            chartContainer.style.display = 'block';

            const ctx = canvas.getContext('2d');
            if (charts.seasonality) charts.seasonality.destroy();

            // Prepare data for the chart
            const categories = Object.keys(seasonalityAnalytics.categoryResults);
            const monthlyData = {};

            // Initialize monthly data
            for (let month = 1; month <= 12; month++) {
                monthlyData[month] = 0;
            }

            // Aggregate monthly spend across all categories
            filteredData.forEach(row => {
                const month = new Date(row.date).getMonth() + 1;
                // Ensure month is valid (1-12) before accessing monthlyData
                if (month >= 1 && month <= 12) {
                    monthlyData[month] += row.amount;
                }
            });

            const labels = seasonalityAnalyzer.monthNames;
            const data = labels.map((_, index) => monthlyData[index + 1]);

            charts.seasonality = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Monthly Spend',
                        data: data,
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function (value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }

        function displayOpportunityCards() {
            const container = safeGetElement('opportunityCards');
            if (!container) return;

            container.style.display = 'block';

            const opportunities = seasonalityAnalytics.opportunities.slice(0, 6); // Show top 6

            container.innerHTML = opportunities.map(opp => `
                <div class="opportunity-card">
                    <div class="opportunity-title">
                        ${opp.category} - ${opp.type}
                    </div>
                    <div class="opportunity-description">
                        Peak spending in ${opp.peakMonthName}, low in ${opp.lowMonthName}. 
                        Seasonality strength: ${opp.seasonalityStrength.toFixed(1)}%
                    </div>
                    <div class="opportunity-metrics">
                        <div class="opportunity-metric">
                            <div class="opportunity-metric-value">$${opp.optimisticSavings.toFixed(0).toLocaleString()}</div>
                            <div class="opportunity-metric-label">Savings Potential</div>
                        </div>
                        <div class="opportunity-metric">
                            <div class="opportunity-metric-value">${opp.impact}</div>
                            <div class="opportunity-metric-label">Impact Level</div>
                        </div>
                        <div class="opportunity-metric">
                            <div class="opportunity-metric-value">${opp.timeline}</div>
                            <div class="opportunity-metric-label">Timeline</div>
                        </div>
                    </div>
                    <div class="opportunity-recommendation">
                        ðŸ’¡ Contract during ${opp.lowMonthName} (low demand) for ${opp.peakMonthName} (peak demand) services to optimize costs.
                    </div>
                </div>
            `).join('');
        }

        // Tail Spend Analysis Functions
        function updateTailSpendAnalysis() {
            if (filteredData.length === 0) {
                showTailSpendMessage();
                return;
            }

            try {
                // Initialize tail spend analyzer
                const tailSpendAnalyzer = new TailSpendAnalyzer();

                // Perform comprehensive analysis
                tailSpendAnalytics = tailSpendAnalyzer.performComprehensiveAnalysis(filteredData, seasonalityAnalytics);

                if (tailSpendAnalytics.summary.tailVendors > 0) {
                    displayTailSpendResults();
                    // Add vendor consolidation analysis
                    updateVendorConsolidationAnalysis();
                } else {
                    showTailSpendMessage();
                }
            } catch (error) {
                console.error('Error in tail spend analysis:', error);
                showTailSpendMessage();
            }
        }

        function showTailSpendMessage() {
            const container = safeGetElement('tailSpendContainer');
            const message = safeGetElement('noTailSpendMessage');

            if (container) container.style.display = 'none';
            if (message) message.style.display = 'block';
        }

        function displayTailSpendResults() {
            const container = safeGetElement('tailSpendContainer');
            const message = safeGetElement('noTailSpendMessage');

            if (!container || !tailSpendAnalytics) return;

            container.style.display = 'block';
            if (message) message.style.display = 'none';

            // Update executive summary metrics
            updateTailSpendMetrics();

            // Display Pareto chart
            displayParetoChart();

            // Display tail segmentation
            displayTailSegmentation();

            // Display savings opportunities
            displaySavingsOpportunities();

            // Display vendor risk table
            displayVendorRiskTable();

            // Display category analysis
            displayCategoryTailAnalysis();
        }

        function updateTailSpendMetrics() {
            const summary = tailSpendAnalytics.summary;

            const totalVendorsElement = safeGetElement('totalVendorsCount');
            const tailVendorsElement = safeGetElement('tailVendorsCount');
            const tailSpendAmountElement = safeGetElement('tailSpendAmount');
            const tailSpendPercentageElement = safeGetElement('tailSpendPercentage');
            const totalSavingsElement = safeGetElement('totalSavingsOpportunity');

            if (totalVendorsElement) totalVendorsElement.textContent = summary.totalVendors.toLocaleString();
            if (tailVendorsElement) tailVendorsElement.textContent = summary.tailVendors.toLocaleString();
            if (tailSpendAmountElement) tailSpendAmountElement.textContent = `$${summary.tailSpend.toFixed(0).toLocaleString()}`;
            if (tailSpendPercentageElement) tailSpendPercentageElement.textContent = `${summary.tailSpendPercentage.toFixed(1)}%`;
            if (totalSavingsElement) totalSavingsElement.textContent = `$${summary.totalSavingsOpportunity.toFixed(0).toLocaleString()}`;
        }

        function displayParetoChart() {
            const canvas = safeGetElement('tailParetoChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (charts.tailPareto) charts.tailPareto.destroy();

            // Prepare data for Pareto chart
            const vendors = tailSpendAnalytics.paretoData.vendors.slice(0, 20); // Top 20 vendors
            const labels = vendors.map(v => v.vendor.length > 15 ? v.vendor.substring(0, 15) + '...' : v.vendor);
            const spendData = vendors.map(v => v.spend);
            const cumulativeData = vendors.map(v => v.cumulativePercentage);

            charts.tailPareto = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Vendor Spend',
                        data: spendData,
                        backgroundColor: vendors.map(v => v.classification === 'Core' ? '#3498db' : '#e74c3c'),
                        borderColor: vendors.map(v => v.classification === 'Core' ? '#2980b9' : '#c0392b'),
                        borderWidth: 1,
                        yAxisID: 'y'
                    }, {
                        label: 'Cumulative %',
                        data: cumulativeData,
                        type: 'line',
                        borderColor: '#f39c12',
                        backgroundColor: 'rgba(243, 156, 18, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Vendor Pareto Analysis (80/20 Rule)'
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Vendors (Ranked by Spend)'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Annual Spend ($)'
                            },
                            ticks: {
                                callback: function (value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Cumulative Percentage (%)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                callback: function (value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        function displayTailSegmentation() {
            const container = safeGetElement('tailSegmentation');
            if (!container) return;

            const segments = tailSpendAnalytics.segments;

            container.innerHTML = `
                <!-- Segment Definitions Header -->
                <div class="segment-definitions">
                    <h4 style="color: #2c3e50; margin-bottom: 15px; text-align: center;">ðŸ“‹ Tail Vendor Segmentation Definitions</h4>
                    <div class="definition-cards">
                        <div class="definition-card">
                            <span class="definition-icon">ðŸ”´</span>
                            <span class="definition-text"><strong>Micro:</strong> &lt; $10,000 annual spend</span>
                        </div>
                        <div class="definition-card">
                            <span class="definition-icon">ðŸŸ¡</span>
                            <span class="definition-text"><strong>Small:</strong> $10,000 - $50,000 annual spend</span>
                        </div>
                        <div class="definition-card">
                            <span class="definition-icon">ðŸŸ¢</span>
                            <span class="definition-text"><strong>Mid-tail:</strong> &gt; $50,000 annual spend</span>
                        </div>
                    </div>
                </div>

                <div class="tail-segment-cards">
                    <div class="tail-segment-card">
                        <div class="tail-segment-header">
                            <h4>ðŸ”´ Micro Vendors</h4>
                            <span class="tail-segment-threshold">&lt; $10K</span>
                        </div>
                        <div class="tail-segment-metrics">
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">${segments.micro.vendors.length}</span>
                                <span class="tail-segment-label">Vendors</span>
                            </div>
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">$${segments.micro.totalSpend.toFixed(0).toLocaleString()}</span>
                                <span class="tail-segment-label">Total Spend</span>
                            </div>
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">${segments.micro.totalTransactions}</span>
                                <span class="tail-segment-label">Transactions</span>
                            </div>
                        </div>
                        <div class="tail-segment-recommendation">
                            ðŸ’¡ <strong>Recommendation:</strong> Consolidate or eliminate to reduce administrative overhead
                        </div>
                    </div>
                    
                    <div class="tail-segment-card">
                        <div class="tail-segment-header">
                            <h4>ðŸŸ¡ Small Vendors</h4>
                            <span class="tail-segment-threshold">$10K - $50K</span>
                        </div>
                        <div class="tail-segment-metrics">
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">${segments.small.vendors.length}</span>
                                <span class="tail-segment-label">Vendors</span>
                            </div>
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">$${segments.small.totalSpend.toFixed(0).toLocaleString()}</span>
                                <span class="tail-segment-label">Total Spend</span>
                            </div>
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">${segments.small.totalTransactions}</span>
                                <span class="tail-segment-label">Transactions</span>
                            </div>
                        </div>
                        <div class="tail-segment-recommendation">
                            ðŸ’¡ <strong>Recommendation:</strong> Negotiate better terms and implement process improvements
                        </div>
                    </div>
                    
                    <div class="tail-segment-card">
                        <div class="tail-segment-header">
                            <h4>ðŸŸ¢ Mid-Tail Vendors</h4>
                            <span class="tail-segment-threshold">&gt; $50K</span>
                        </div>
                        <div class="tail-segment-metrics">
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">${segments.midTail.vendors.length}</span>
                                <span class="tail-segment-label">Vendors</span>
                            </div>
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">$${segments.midTail.totalSpend.toFixed(0).toLocaleString()}</span>
                                <span class="tail-segment-label">Total Spend</span>
                            </div>
                            <div class="tail-segment-metric">
                                <span class="tail-segment-value">${segments.midTail.totalTransactions}</span>
                                <span class="tail-segment-label">Transactions</span>
                            </div>
                        </div>
                        <div class="tail-segment-recommendation">
                            ðŸ’¡ <strong>Recommendation:</strong> Strategic partnerships and volume consolidation
                        </div>
                    </div>
                </div>
            `;
        }

        function displaySavingsOpportunities() {
            const container = safeGetElement('savingsStrategies');
            const timelineContainer = safeGetElement('implementationTimeline');
            if (!container) return;

            const opportunities = tailSpendAnalytics.savingsOpportunities;

            container.innerHTML = Object.values(opportunities).map(opp => `
                <div class="savings-strategy-card">
                    <div class="savings-strategy-header">
                        <h4>${opp.name}</h4>
                        <span class="savings-strategy-timeline">${opp.timeline}</span>
                    </div>
                    <div class="savings-strategy-description">
                        ${opp.description}
                    </div>
                    <div class="savings-strategy-metrics">
                        <div class="savings-strategy-metric">
                            <span class="savings-strategy-value">$${opp.conservativeSavings.toFixed(0).toLocaleString()}</span>
                            <span class="savings-strategy-label">Conservative Savings</span>
                        </div>
                        <div class="savings-strategy-metric">
                            <span class="savings-strategy-value">$${opp.optimisticSavings.toFixed(0).toLocaleString()}</span>
                            <span class="savings-strategy-label">Optimistic Savings</span>
                        </div>
                        <div class="savings-strategy-metric">
                            <span class="savings-strategy-value">${opp.vendorsAffected}</span>
                            <span class="savings-strategy-label">Vendors Affected</span>
                        </div>
                    </div>
                </div>
            `).join('');

            // Implementation timeline
            if (timelineContainer) {
                timelineContainer.innerHTML = `
                    <div class="timeline-phases">
                        <div class="timeline-phase">
                            <div class="timeline-phase-header">Phase 1: Quick Wins (0-3 months)</div>
                            <div class="timeline-phase-content">
                                â€¢ Identify micro vendors for immediate consolidation<br>
                                â€¢ Implement basic process improvements<br>
                                â€¢ Begin P-Card pilot program
                            </div>
                        </div>
                        <div class="timeline-phase">
                            <div class="timeline-phase-header">Phase 2: Strategic Implementation (3-6 months)</div>
                            <div class="timeline-phase-content">
                                â€¢ Execute vendor consolidation strategy<br>
                                â€¢ Negotiate improved contracts with small vendors<br>
                                â€¢ Expand P-Card implementation
                            </div>
                        </div>
                        <div class="timeline-phase">
                            <div class="timeline-phase-header">Phase 3: Optimization (6-12 months)</div>
                            <div class="timeline-phase-content">
                                â€¢ Monitor and optimize new processes<br>
                                â€¢ Measure savings realization<br>
                                â€¢ Continuous improvement initiatives
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        function displayVendorRiskTable() {
            const tableBody = safeGetElement('vendorRiskTableBody');
            if (!tableBody) return;

            // Get top 20 tail vendors for risk assessment
            const tailVendors = tailSpendAnalytics.paretoData.vendors
                .filter(v => v.classification === 'Tail')
                .slice(0, 20);

            tableBody.innerHTML = tailVendors.map(vendor => {
                // Simple risk scoring based on spend and transactions
                let riskScore = 0;
                let riskLevel, priority, action;

                if (vendor.spend < 5000) riskScore += 0.3;
                if (vendor.transactions < 3) riskScore += 0.4;
                if (vendor.spendPercentage < 0.1) riskScore += 0.3;

                if (riskScore >= 0.7) {
                    riskLevel = 'High';
                    priority = 'Immediate';
                    action = 'Consolidate/Eliminate';
                } else if (riskScore >= 0.4) {
                    riskLevel = 'Medium';
                    priority = 'Short-term';
                    action = 'Review & Optimize';
                } else {
                    riskLevel = 'Low';
                    priority = 'Long-term';
                    action = 'Monitor';
                }

                return `
                    <tr>
                        <td>${vendor.vendor}</td>
                        <td>$${vendor.spend.toFixed(0).toLocaleString()}</td>
                        <td>${vendor.transactions}</td>
                        <td><span class="risk-score risk-${riskLevel.toLowerCase()}">${riskLevel}</span></td>
                        <td><span class="priority-${priority.toLowerCase()}">${priority}</span></td>
                        <td>${action}</td>
                    </tr>
                `;
            }).join('');
        }

        function displayCategoryTailAnalysis() {
            const container = safeGetElement('categoryTailAnalysis');
            if (!container) return;

            // Analyze tail spend by category
            const categoryData = {};
            const tailVendors = new Set(tailSpendAnalytics.paretoData.vendors
                .filter(v => v.classification === 'Tail')
                .map(v => v.vendor));

            filteredData.forEach(row => {
                const category = row.category || 'Unknown';
                const vendor = row.supplier || row.vendor || 'Unknown';
                const amount = row.amount || 0;

                if (!categoryData[category]) {
                    categoryData[category] = {
                        totalSpend: 0,
                        tailSpend: 0,
                        totalVendors: new Set(),
                        tailVendors: new Set()
                    };
                }

                categoryData[category].totalSpend += amount;
                categoryData[category].totalVendors.add(vendor);

                if (tailVendors.has(vendor)) {
                    categoryData[category].tailSpend += amount;
                    categoryData[category].tailVendors.add(vendor);
                }
            });

            // Sort categories by tail spend percentage
            const sortedCategories = Object.entries(categoryData)
                .map(([category, data]) => ({
                    category,
                    ...data,
                    totalVendorCount: data.totalVendors.size,
                    tailVendorCount: data.tailVendors.size,
                    tailSpendPercentage: (data.tailSpend / data.totalSpend) * 100,
                    tailVendorPercentage: (data.tailVendors.size / data.totalVendors.size) * 100
                }))
                .sort((a, b) => b.tailSpendPercentage - a.tailSpendPercentage)
                .slice(0, 10);

            container.innerHTML = `
                <div class="category-tail-cards">
                    ${sortedCategories.map(cat => `
                        <div class="category-tail-card">
                            <div class="category-tail-header">
                                <h4>${cat.category}</h4>
                                <span class="category-tail-percentage">${cat.tailSpendPercentage.toFixed(1)}% Tail</span>
                            </div>
                            <div class="category-tail-metrics">
                                <div class="category-tail-metric">
                                    <span class="category-tail-value">$${cat.tailSpend.toFixed(0).toLocaleString()}</span>
                                    <span class="category-tail-label">Tail Spend</span>
                                </div>
                                <div class="category-tail-metric">
                                    <span class="category-tail-value">${cat.tailVendorCount}</span>
                                    <span class="category-tail-label">Tail Vendors</span>
                                </div>
                                <div class="category-tail-metric">
                                    <span class="category-tail-value">${cat.tailVendorPercentage.toFixed(0)}%</span>
                                    <span class="category-tail-label">Vendor %</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Vendor Consolidation Analysis Display Function
        function updateVendorConsolidationAnalysis() {
            if (!filteredData || filteredData.length === 0) return;

            try {
                // Perform consolidation analysis
                const consolidationResults = vendorConsolidationAnalyzer.performConsolidationAnalysis(filteredData);

                // Store results globally for access from other functions
                window.consolidationAnalytics = consolidationResults;

                // Update the Tail Spend Analysis tab with consolidation insights
                displayConsolidationOpportunities(consolidationResults);

                debugLog('Vendor consolidation analysis completed', consolidationResults);
            } catch (error) {
                debugLog('Error in vendor consolidation analysis', error);
            }
        }

        // Display consolidation opportunities in the Tail Spend Analysis tab
        function displayConsolidationOpportunities(results) {
            const container = safeGetElement('tailSpendContainer');
            if (!container) return;

            // Find the existing category analysis section and add consolidation section after it
            const existingContent = container.innerHTML;

            // Check if consolidation section already exists
            if (existingContent.includes('vendor-consolidation-section')) {
                // Update existing section
                const consolidationSection = container.querySelector('.vendor-consolidation-section');
                if (consolidationSection) {
                    consolidationSection.innerHTML = generateConsolidationHTML(results);
                }
            } else {
                // Add new consolidation section
                const consolidationHTML = `
                    <div class="vendor-consolidation-section">
                        ${generateConsolidationHTML(results)}
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', consolidationHTML);
            }
        }

        // Generate HTML for consolidation opportunities
        function generateConsolidationHTML(results) {
            const { summary, crossCategoryOpportunities, categoryOpportunities, geographicOpportunities } = results;

            return `
                <div class="consolidation-header">
                    <h3>ðŸ”— Intelligent Vendor Consolidation Opportunities</h3>
                    <div class="consolidation-summary">
                        <div class="consolidation-metric">
                            <span class="metric-value">${summary.totalOpportunities}</span>
                            <span class="metric-label">Total Opportunities</span>
                        </div>
                        <div class="consolidation-metric">
                            <span class="metric-value">$${summary.totalSavingsPotential.toFixed(0).toLocaleString()}</span>
                            <span class="metric-label">Total Savings Potential</span>
                        </div>
                        <div class="consolidation-metric">
                            <span class="metric-value">${summary.topOpportunity ? summary.topOpportunity.type : 'N/A'}</span>
                            <span class="metric-label">Top Opportunity Type</span>
                        </div>
                    </div>
                </div>

                <div class="consolidation-tabs">
                    <button class="consolidation-tab-btn active" onclick="showConsolidationTab('cross-category')" title="Vendors serving multiple categories - opportunities for strategic partnerships">
                        Multi-Category Vendors (${crossCategoryOpportunities.length})
                    </button>
                    <button class="consolidation-tab-btn" onclick="showConsolidationTab('category')" title="Reduce vendor count within specific categories for better pricing">
                        Category Consolidation (${categoryOpportunities.length})
                    </button>
                    <button class="consolidation-tab-btn" onclick="showConsolidationTab('geographic')" title="Consolidate vendors by location for operational efficiency">
                        Geographic Consolidation (${geographicOpportunities.length})
                    </button>
                </div>

                <div class="consolidation-content">
                    <div id="cross-category-tab" class="consolidation-tab-content active">
                        ${generateCrossCategoryHTML(crossCategoryOpportunities)}
                    </div>
                    <div id="category-tab" class="consolidation-tab-content">
                        ${generateCategoryConsolidationHTML(categoryOpportunities)}
                    </div>
                    <div id="geographic-tab" class="consolidation-tab-content">
                        ${generateGeographicConsolidationHTML(geographicOpportunities)}
                    </div>
                </div>
            `;
        }

        // Generate cross-category opportunities HTML
        function generateCrossCategoryHTML(opportunities) {
            if (opportunities.length === 0) {
                return '<div class="no-opportunities">No multi-category vendor opportunities identified.</div>';
            }

            return `
                <div class="section-definition">
                    <h4>ðŸ“‹ Multi-Category Vendors</h4>
                    <p>Individual suppliers currently serving multiple product/service categories. Consolidating more spend with these versatile vendors can unlock volume discounts and strategic partnerships.</p>
                </div>
                <div class="opportunities-grid">
                    ${opportunities.slice(0, 6).map(opp => `
                        <div class="opportunity-card ${opp.consolidationPotential.strategicValue.toLowerCase()}">
                            <div class="opportunity-header">
                                <h4>${opp.vendor}</h4>
                                <span class="strategic-value ${opp.consolidationPotential.strategicValue.toLowerCase()}">${opp.consolidationPotential.strategicValue} Value</span>
                            </div>
                            <div class="opportunity-metrics">
                                <div class="metric-row">
                                    <span class="metric-label">Categories:</span>
                                    <span class="metric-value">${opp.categoryCount}</span>
                                </div>
                                <div class="metric-row">
                                    <span class="metric-label">Total Spend:</span>
                                    <span class="metric-value">$${opp.totalSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="metric-row">
                                    <span class="metric-label">Savings Potential:</span>
                                    <span class="metric-value savings">$${opp.consolidationPotential.totalSavings.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="metric-row">
                                    <span class="metric-label">Savings Rate:</span>
                                    <span class="metric-value">${(opp.consolidationPotential.savingsRate * 100).toFixed(1)}%</span>
                                </div>
                            </div>
                            <div class="category-breakdown">
                                <strong>Categories:</strong> ${opp.categories.join(', ')}
                            </div>
                            <div class="recommendation">
                                <strong>Recommendation:</strong> Consolidate spend across ${opp.categoryCount} categories for enhanced negotiation power and streamlined management.
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Generate category consolidation HTML
        function generateCategoryConsolidationHTML(opportunities) {
            if (opportunities.length === 0) {
                return '<div class="no-opportunities">No category consolidation opportunities identified.</div>';
            }

            return `
                <div class="section-definition">
                    <h4>ðŸ“Š Category Consolidation</h4>
                    <p>Reduce vendor count within specific categories by consolidating tail spend with top performers. Streamlines procurement and improves negotiation power.</p>
                </div>
                <div class="category-opportunities">
                    ${opportunities.slice(0, 8).map(opp => `
                        <div class="category-opportunity-card">
                            <div class="category-opportunity-header">
                                <h4>${opp.category}</h4>
                                <span class="savings-badge">$${opp.totalSavings.toFixed(0).toLocaleString()}</span>
                            </div>
                            <div class="category-metrics">
                                <div class="metric-grid">
                                    <div class="metric-item">
                                        <span class="metric-value">${opp.totalVendors}</span>
                                        <span class="metric-label">Total Vendors</span>
                                    </div>
                                    <div class="metric-item">
                                        <span class="metric-value">${opp.tailVendorCount}</span>
                                        <span class="metric-label">Tail Vendors</span>
                                    </div>
                                    <div class="metric-item">
                                        <span class="metric-value">$${opp.tailSpend.toFixed(0).toLocaleString()}</span>
                                        <span class="metric-label">Tail Spend</span>
                                    </div>
                                    <div class="metric-item">
                                        <span class="metric-value">${opp.topVendor}</span>
                                        <span class="metric-label">Top Vendor</span>
                                    </div>
                                </div>
                            </div>
                            <div class="recommendation-text">
                                ${opp.recommendation}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Generate geographic consolidation HTML
        function generateGeographicConsolidationHTML(opportunities) {
            if (opportunities.length === 0) {
                return '<div class="no-opportunities">No geographic consolidation opportunities identified.</div>';
            }

            return `
                <div class="section-definition">
                    <h4>ðŸŒ Geographic Consolidation</h4>
                    <p>Optimize vendor relationships by location to reduce logistics costs, improve service delivery, and simplify regional operations management.</p>
                </div>
                <div class="geographic-opportunities">
                    ${opportunities.slice(0, 6).map(opp => `
                        <div class="geographic-opportunity-card">
                            <div class="geographic-header">
                                <h4>ðŸ“ ${opp.location}</h4>
                                <span class="savings-potential">$${opp.consolidationSavings.toFixed(0).toLocaleString()}</span>
                            </div>
                            <div class="geographic-metrics">
                                <div class="metric-pair">
                                    <span class="metric-label">Vendors:</span>
                                    <span class="metric-value">${opp.vendorCount}</span>
                                </div>
                                <div class="metric-pair">
                                    <span class="metric-label">Total Spend:</span>
                                    <span class="metric-value">$${opp.totalSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="metric-pair">
                                    <span class="metric-label">Top Vendor:</span>
                                    <span class="metric-value">${opp.topVendor}</span>
                                </div>
                            </div>
                            <div class="geographic-recommendation">
                                ${opp.recommendation}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Predictive Analytics Display Functions
        function updatePredictiveAnalytics() {
            try {
                console.log('=== PREDICTIVE ANALYTICS DEBUG START ===');
                console.log('filteredData length:', filteredData ? filteredData.length : 'null/undefined');
                console.log('filteredData sample:', filteredData ? filteredData.slice(0, 3) : 'no data');

                // Show/hide appropriate containers
                const predictiveContainer = safeGetElement('predictiveContainer');
                const noPredictiveMessage = safeGetElement('noPredictiveMessage');

                if (!filteredData || filteredData.length === 0) {
                    console.log('No filtered data available for predictive analytics');
                    if (predictiveContainer) predictiveContainer.style.display = 'none';
                    if (noPredictiveMessage) noPredictiveMessage.style.display = 'block';
                    return;
                }

                // Perform predictive analytics
                const seasonalityData = seasonalityAnalytics?.categoryResults || null;
                console.log('seasonalityData available:', seasonalityData ? 'yes' : 'no');
                console.log('Calling predictiveAnalyticsAnalyzer.performForecastingAnalysis...');

                const predictiveResults = predictiveAnalyticsAnalyzer.performForecastingAnalysis(filteredData, seasonalityData);

                console.log('predictiveResults:', predictiveResults);
                console.log('predictiveResults is null?', predictiveResults === null);

                if (!predictiveResults) {
                    console.log('Predictive results is null - showing no data message');
                    if (predictiveContainer) predictiveContainer.style.display = 'none';
                    if (noPredictiveMessage) noPredictiveMessage.style.display = 'block';
                    return;
                }

                console.log('Predictive results received, showing container');
                // Show predictive container and hide no data message
                if (predictiveContainer) predictiveContainer.style.display = 'block';
                if (noPredictiveMessage) noPredictiveMessage.style.display = 'none';

                console.log('Calling display functions...');
                // Display all sections
                displayForecastSummary(predictiveResults.summary);
                displayTotalSpendForecast(predictiveResults.totalSpendForecast);
                displayCategoryForecasts(predictiveResults.categoryForecasts);
                displaySupplierForecasts(predictiveResults.supplierForecasts);
                displayScenarioAnalysis(predictiveResults.scenarioAnalysis);
                displayForecastAccuracy(predictiveResults.accuracyMetrics);

                console.log('=== PREDICTIVE ANALYTICS DEBUG END ===');

            } catch (error) {
                console.error('Error updating predictive analytics:', error);
                console.error('Error stack:', error.stack);
                const predictiveContainer = safeGetElement('predictiveContainer');
                const noPredictiveMessage = safeGetElement('noPredictiveMessage');
                if (predictiveContainer) predictiveContainer.style.display = 'none';
                if (noPredictiveMessage) noPredictiveMessage.style.display = 'block';
            }
        }

        // Maverick Spend Analysis Display Functions
        function updateMaverickSpendAnalysis() {
            try {
                console.log('=== MAVERICK SPEND ANALYSIS DEBUG START ===');
                console.log('filteredData length:', filteredData ? filteredData.length : 'null/undefined');

                const maverickContainer = safeGetElement('maverickContainer');
                const noMaverickMessage = safeGetElement('noMaverickMessage');

                if (!filteredData || filteredData.length === 0) {
                    console.log('No filtered data available for maverick spend analysis');
                    if (maverickContainer) maverickContainer.style.display = 'none';
                    if (noMaverickMessage) noMaverickMessage.style.display = 'block';
                    return;
                }

                // Perform maverick spend analysis
                console.log('Calling maverickSpendAnalyzer.performMaverickAnalysis...');
                const maverickResults = maverickSpendAnalyzer.performMaverickAnalysis(filteredData);

                console.log('maverickResults:', maverickResults);
                console.log('maverickResults is null?', maverickResults === null);

                if (!maverickResults || maverickResults.error) {
                    console.log('Maverick results is null or has error - showing no data message');
                    if (maverickContainer) maverickContainer.style.display = 'none';
                    if (noMaverickMessage) noMaverickMessage.style.display = 'block';
                    return;
                }

                // Show maverick container and hide no data message
                if (maverickContainer) maverickContainer.style.display = 'block';
                if (noMaverickMessage) noMaverickMessage.style.display = 'none';

                // Display all maverick components
                displayComplianceOverview(maverickResults.summary);
                displayComplianceScores(maverickResults.complianceScores);
                displayComplianceAlerts(maverickResults.alerts);
                displayComplianceRecommendations(maverickResults.recommendations);
                displaySupplierRiskMatrix(maverickResults.supplierProfiles);

                console.log('=== MAVERICK SPEND ANALYSIS DEBUG END ===');

            } catch (error) {
                console.error('Error updating maverick spend analysis:', error);
                console.error('Error stack:', error.stack);
                const maverickContainer = safeGetElement('maverickContainer');
                const noMaverickMessage = safeGetElement('noMaverickMessage');
                if (maverickContainer) maverickContainer.style.display = 'none';
                if (noMaverickMessage) noMaverickMessage.style.display = 'block';
            }
        }

        // Display compliance overview
        function displayComplianceOverview(summary) {
            const complianceOverview = safeGetElement('complianceOverview');
            if (!complianceOverview || !summary) return;

            const complianceColor = maverickSpendAnalyzer.getComplianceColor(summary.overallComplianceScore);
            const riskIcon = summary.riskLevel === 'High' ? 'ðŸ”´' : summary.riskLevel === 'Medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';

            complianceOverview.innerHTML = `
                <div class="compliance-score-grid">
                    <div class="compliance-score-card compliance-level-${summary.complianceLevel.toLowerCase()}">
                        <div class="compliance-score-value" style="color: ${complianceColor}">
                            ${summary.overallComplianceScore}%
                        </div>
                        <div class="compliance-score-label">Overall Compliance Score</div>
                        <div style="margin-top: 10px; font-weight: 600; color: ${complianceColor}">
                            ${summary.complianceLevel}
                        </div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: #2c3e50">
                            ${summary.totalAlerts}
                        </div>
                        <div class="compliance-score-label">Total Alerts</div>
                        <div style="margin-top: 10px; font-weight: 600; color: #666">
                            Compliance Violations
                        </div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: #2c3e50">
                            ${riskIcon} ${summary.riskLevel}
                        </div>
                        <div class="compliance-score-label">Risk Level</div>
                        <div style="margin-top: 10px; font-weight: 600; color: #666">
                            Overall Assessment
                        </div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: #2c3e50">
                            $${summary.totalSpend.toLocaleString()}
                        </div>
                        <div class="compliance-score-label">Total Spend Analyzed</div>
                        <div style="margin-top: 10px; font-weight: 600; color: #666">
                            ${summary.totalTransactions.toLocaleString()} Transactions
                        </div>
                    </div>
                </div>
            `;
        }

        // Display compliance scores breakdown
        function displayComplianceScores(complianceScores) {
            const complianceScoresElement = safeGetElement('complianceScores');
            if (!complianceScoresElement || !complianceScores) return;

            const breakdown = complianceScores.breakdown;

            complianceScoresElement.innerHTML = `
                <div class="compliance-score-grid">
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: ${breakdown.newSupplierCompliance >= 80 ? '#28a745' : breakdown.newSupplierCompliance >= 60 ? '#ffc107' : '#dc3545'}">
                            ${breakdown.newSupplierCompliance}%
                        </div>
                        <div class="compliance-score-label">New Supplier Compliance</div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: ${breakdown.spendPatternCompliance >= 80 ? '#28a745' : breakdown.spendPatternCompliance >= 60 ? '#ffc107' : '#dc3545'}">
                            ${breakdown.spendPatternCompliance}%
                        </div>
                        <div class="compliance-score-label">Spend Pattern Compliance</div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: ${breakdown.concentrationCompliance >= 80 ? '#28a745' : breakdown.concentrationCompliance >= 60 ? '#ffc107' : '#dc3545'}">
                            ${breakdown.concentrationCompliance}%
                        </div>
                        <div class="compliance-score-label">Concentration Risk Compliance</div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: ${breakdown.transactionCompliance >= 80 ? '#28a745' : breakdown.transactionCompliance >= 60 ? '#ffc107' : '#dc3545'}">
                            ${breakdown.transactionCompliance}%
                        </div>
                        <div class="compliance-score-label">Transaction Compliance</div>
                    </div>
                    
                    <div class="compliance-score-card">
                        <div class="compliance-score-value" style="color: ${breakdown.contractCompliance >= 80 ? '#28a745' : breakdown.contractCompliance >= 60 ? '#ffc107' : '#dc3545'}">
                            ${breakdown.contractCompliance}%
                        </div>
                        <div class="compliance-score-label">Contract Compliance</div>
                    </div>
                </div>
            `;
        }

        // Display compliance alerts
        function displayComplianceAlerts(alerts) {
            // Display new suppliers alerts
            const newSuppliersAlert = safeGetElement('newSuppliers-alert');
            if (newSuppliersAlert) {
                newSuppliersAlert.innerHTML = generateAlertCards(alerts.newSuppliers, 'New Supplier');
            }

            // Display spend anomalies alerts
            const spendAnomaliesAlert = safeGetElement('spendAnomalies-alert');
            if (spendAnomaliesAlert) {
                spendAnomaliesAlert.innerHTML = generateAlertCards(alerts.spendAnomalies, 'Spend Anomaly');
            }

            // Display concentration risks alerts
            const concentrationRisksAlert = safeGetElement('concentrationRisks-alert');
            if (concentrationRisksAlert) {
                concentrationRisksAlert.innerHTML = generateAlertCards(alerts.concentrationRisks, 'Concentration Risk');
            }

            // Display unusual transactions alerts
            const unusualTransactionsAlert = safeGetElement('unusualTransactions-alert');
            if (unusualTransactionsAlert) {
                unusualTransactionsAlert.innerHTML = generateAlertCards(alerts.unusualTransactions, 'Unusual Transaction');
            }

            // Display off-contract spend alerts
            const offContractAlert = safeGetElement('offContract-alert');
            if (offContractAlert) {
                offContractAlert.innerHTML = generateAlertCards(alerts.offContractSpend, 'Off-Contract Spend');
            }
        }

        // Generate alert cards HTML
        function generateAlertCards(alertList, alertType) {
            if (!alertList || alertList.length === 0) {
                return `
                    <div style="text-align: center; padding: 40px; color: #28a745;">
                        <div style="font-size: 3rem; margin-bottom: 15px;">âœ…</div>
                        <h3>No ${alertType} Issues Detected</h3>
                        <p>Your procurement practices are compliant in this area.</p>
                    </div>
                `;
            }

            return alertList.map(alert => {
                const riskClass = `risk-${alert.riskLevel.toLowerCase()}`;

                let detailsHTML = '';
                if (alertType === 'New Supplier') {
                    detailsHTML = `
                        <div class="alert-details">
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.totalSpend.toLocaleString()}</div>
                                <div class="alert-detail-label">Total Spend</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.transactionCount}</div>
                                <div class="alert-detail-label">Transactions</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.categories.join(', ')}</div>
                                <div class="alert-detail-label">Categories</div>
                            </div>
                        </div>
                    `;
                } else if (alertType === 'Spend Anomaly') {
                    detailsHTML = `
                        <div class="alert-details">
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.recentSpend.toLocaleString()}</div>
                                <div class="alert-detail-label">Recent Spend</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.historicalAverage.toLocaleString()}</div>
                                <div class="alert-detail-label">Historical Average</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.deviationMultiple.toFixed(1)}x</div>
                                <div class="alert-detail-label">Deviation Multiple</div>
                            </div>
                        </div>
                    `;
                } else if (alertType === 'Concentration Risk') {
                    detailsHTML = `
                        <div class="alert-details">
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.concentration.toFixed(1)}%</div>
                                <div class="alert-detail-label">Concentration</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.spend.toLocaleString()}</div>
                                <div class="alert-detail-label">Supplier Spend</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.category}</div>
                                <div class="alert-detail-label">Category</div>
                            </div>
                        </div>
                    `;
                } else if (alertType === 'Unusual Transaction') {
                    detailsHTML = `
                        <div class="alert-details">
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.amount.toLocaleString()}</div>
                                <div class="alert-detail-label">Transaction Amount</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.categoryAverage.toLocaleString()}</div>
                                <div class="alert-detail-label">Category Average</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.multiple.toFixed(1)}x</div>
                                <div class="alert-detail-label">Size Multiple</div>
                            </div>
                        </div>
                    `;
                } else if (alertType === 'Off-Contract Spend') {
                    detailsHTML = `
                        <div class="alert-details">
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.totalSpend.toLocaleString()}</div>
                                <div class="alert-detail-label">Total Spend</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">${alert.transactionCount}</div>
                                <div class="alert-detail-label">Transactions</div>
                            </div>
                            <div class="alert-detail">
                                <div class="alert-detail-value">$${alert.avgTransactionSize.toLocaleString()}</div>
                                <div class="alert-detail-label">Avg Transaction</div>
                            </div>
                        </div>
                    `;
                }

                return `
                    <div class="alert-card ${riskClass}">
                        <div class="alert-header">
                            <div class="alert-title">${alert.supplier || alert.category || 'Alert'}</div>
                            <div class="alert-risk-badge ${riskClass}">${alert.riskLevel} Risk</div>
                        </div>
                        ${detailsHTML}
                        <div class="alert-recommendation">
                            ðŸ’¡ <strong>Recommendation:</strong> ${alert.recommendation}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Display compliance recommendations
        function displayComplianceRecommendations(recommendations) {
            const complianceRecommendations = safeGetElement('complianceRecommendations');
            if (!complianceRecommendations || !recommendations) return;

            if (recommendations.length === 0) {
                complianceRecommendations.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #28a745;">
                        <div style="font-size: 3rem; margin-bottom: 15px;">ðŸŽ‰</div>
                        <h3>Excellent Compliance!</h3>
                        <p>No immediate recommendations. Your procurement practices are well-managed.</p>
                    </div>
                `;
                return;
            }

            complianceRecommendations.innerHTML = recommendations.map(rec => `
                <div class="recommendation-card">
                    <div class="recommendation-header">
                        <div class="recommendation-title">${rec.title}</div>
                        <div class="priority-badge priority-${rec.priority.toLowerCase()}">${rec.priority} Priority</div>
                    </div>
                    <div style="margin-bottom: 15px; color: #666; line-height: 1.6;">
                        ${rec.description}
                    </div>
                    <div class="recommendation-meta">
                        <div class="recommendation-meta-item">
                            <div class="recommendation-meta-value">${rec.category}</div>
                            <div class="recommendation-meta-label">Category</div>
                        </div>
                        <div class="recommendation-meta-item">
                            <div class="recommendation-meta-value">${rec.impact}</div>
                            <div class="recommendation-meta-label">Impact</div>
                        </div>
                        <div class="recommendation-meta-item">
                            <div class="recommendation-meta-value">${rec.timeline}</div>
                            <div class="recommendation-meta-label">Timeline</div>
                        </div>
                        <div class="recommendation-meta-item">
                            <div class="recommendation-meta-value">${rec.effort}</div>
                            <div class="recommendation-meta-label">Effort</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Display supplier risk matrix
        function displaySupplierRiskMatrix(supplierProfiles) {
            const supplierRiskMatrix = safeGetElement('supplierRiskMatrix');
            if (!supplierRiskMatrix || !supplierProfiles) return;

            // Get top 10 suppliers by spend for risk matrix
            const topSuppliers = Object.values(supplierProfiles)
                .sort((a, b) => b.totalSpend - a.totalSpend)
                .slice(0, 10);

            if (topSuppliers.length === 0) {
                supplierRiskMatrix.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <div style="font-size: 3rem; margin-bottom: 15px;">ðŸ“Š</div>
                        <h3>No Supplier Data Available</h3>
                        <p>Upload data to see supplier risk analysis.</p>
                    </div>
                `;
                return;
            }

            supplierRiskMatrix.innerHTML = `
                <div class="risk-matrix">
                    ${topSuppliers.map(supplier => {
                const riskScore = Math.min(100, Math.max(0,
                    (supplier.spendVolatility * 30) +
                    (supplier.categories.length > 3 ? 20 : 0) +
                    (supplier.totalSpend > 100000 ? 25 : 0) +
                    (supplier.transactionCount < 10 ? 25 : 0)
                ));

                const riskLevel = riskScore >= 70 ? 'High' : riskScore >= 40 ? 'Medium' : 'Low';
                const riskColor = riskScore >= 70 ? '#dc3545' : riskScore >= 40 ? '#ffc107' : '#28a745';

                return `
                            <div class="risk-matrix-item" style="border-color: ${riskColor}">
                                <div class="risk-matrix-supplier">${supplier.name}</div>
                                <div class="risk-matrix-score" style="color: ${riskColor}">
                                    ${Math.round(riskScore)}
                                </div>
                                <div style="font-size: 14px; color: ${riskColor}; font-weight: 600; margin-bottom: 10px;">
                                    ${riskLevel} Risk
                                </div>
                                <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
                                    $${supplier.totalSpend.toLocaleString()} | ${supplier.transactionCount} transactions
                                </div>
                                <div class="risk-matrix-categories">
                                    ${supplier.categories.slice(0, 3).map(cat =>
                    `<span class="risk-matrix-category">${cat}</span>`
                ).join('')}
                                    ${supplier.categories.length > 3 ? `<span class="risk-matrix-category">+${supplier.categories.length - 3} more</span>` : ''}
                                </div>
                            </div>
                        `;
            }).join('')}
                </div>
            `;
        }

        // Contract Optimization Analysis Display Functions
        function updateContractOptimizationAnalysis() {
            try {
                console.log('=== CONTRACT OPTIMIZATION ANALYSIS DEBUG START ===');
                console.log('filteredData length:', filteredData ? filteredData.length : 'null/undefined');

                const contractsContainer = safeGetElement('contractsContainer');
                const noContractsMessage = safeGetElement('noContractsMessage');

                if (!filteredData || filteredData.length === 0) {
                    console.log('No filtered data available for contract optimization analysis');
                    if (contractsContainer) contractsContainer.style.display = 'none';
                    if (noContractsMessage) noContractsMessage.style.display = 'block';
                    return;
                }

                // Perform contract optimization analysis
                console.log('Calling contractOptimizationAnalyzer.performContractAnalysis...');
                const contractResults = contractOptimizationAnalyzer.performContractAnalysis(filteredData);

                console.log('contractResults:', contractResults);
                console.log('contractResults is null?', contractResults === null);

                if (!contractResults || contractResults.error) {
                    console.log('Contract results is null or has error - showing no data message');
                    if (contractsContainer) contractsContainer.style.display = 'none';
                    if (noContractsMessage) noContractsMessage.style.display = 'block';
                    return;
                }

                // Show contracts container and hide no data message
                if (contractsContainer) contractsContainer.style.display = 'block';
                if (noContractsMessage) noContractsMessage.style.display = 'none';

                // Display all contract optimization components
                displayContractPortfolioOverview(contractResults.portfolioOverview);
                displayContractRenewalPipeline(contractResults.renewalPipeline);
                displayContractPerformanceMetrics(contractResults.performanceMetrics);
                displayContractVolumeCommitments(contractResults.volumeCommitments);
                displayContractOptimizationOpportunities(contractResults.optimizationOpportunities);
                displayContractRiskAssessment(contractResults.riskAssessment);
                displayContractRecommendations(contractResults.recommendations);

                console.log('=== CONTRACT OPTIMIZATION ANALYSIS DEBUG END ===');

            } catch (error) {
                console.error('Error updating contract optimization analysis:', error);
                console.error('Error stack:', error.stack);
                const contractsContainer = safeGetElement('contractsContainer');
                const noContractsMessage = safeGetElement('noContractsMessage');
                if (contractsContainer) contractsContainer.style.display = 'none';
                if (noContractsMessage) noContractsMessage.style.display = 'block';
            }
        }

        // Display contract portfolio overview
        function displayContractPortfolioOverview(portfolioOverview) {
            const contractPortfolioOverview = safeGetElement('contractPortfolioOverview');
            if (!contractPortfolioOverview || !portfolioOverview) return;

            contractPortfolioOverview.innerHTML = `
                <div class="portfolio-overview-grid">
                    <div class="portfolio-metric-card">
                        <div class="portfolio-metric-value">${portfolioOverview.totalContracts}</div>
                        <div class="portfolio-metric-label">Total Contracts</div>
                    </div>
                    <div class="portfolio-metric-card">
                        <div class="portfolio-metric-value">$${Math.round(portfolioOverview.totalValue / 1000)}K</div>
                        <div class="portfolio-metric-label">Total Annual Value</div>
                    </div>
                    <div class="portfolio-metric-card">
                        <div class="portfolio-metric-value">${portfolioOverview.healthScore}%</div>
                        <div class="portfolio-metric-label">Portfolio Health</div>
                    </div>
                    <div class="portfolio-metric-card">
                        <div class="portfolio-metric-value">${portfolioOverview.categoryDiversification}%</div>
                        <div class="portfolio-metric-label">Diversification</div>
                    </div>
                </div>
            `;
        }

        // Display contract renewal pipeline
        function displayContractRenewalPipeline(renewalPipeline) {
            const contractRenewalPipeline = safeGetElement('contractRenewalPipeline');
            if (!contractRenewalPipeline) return;

            if (!renewalPipeline || renewalPipeline.length === 0) {
                contractRenewalPipeline.innerHTML = `
                    <div class="no-data-message">
                        <p>No contract renewals due within the next 90 days.</p>
                    </div>
                `;
                return;
            }

            contractRenewalPipeline.innerHTML = `
                <div class="renewal-pipeline-grid">
                    ${renewalPipeline.map(renewal => `
                        <div class="renewal-item priority-${renewal.priority.toLowerCase()}">
                            <div class="renewal-header">
                                <div class="renewal-supplier">${renewal.supplier}</div>
                                <div class="renewal-priority ${renewal.priority.toLowerCase()}">${renewal.priority}</div>
                            </div>
                            <div class="renewal-details">
                                <div class="renewal-detail">
                                    <strong>Renewal Date:</strong> ${new Date(renewal.renewalDate).toLocaleDateString()}
                                </div>
                                <div class="renewal-detail">
                                    <strong>Days to Renewal:</strong> ${renewal.daysToRenewal}
                                </div>
                                <div class="renewal-detail">
                                    <strong>Annual Value:</strong> $${Math.round(renewal.annualValue).toLocaleString()}
                                </div>
                                <div class="renewal-detail">
                                    <strong>Categories:</strong> ${renewal.categories.join(', ')}
                                </div>
                            </div>
                            ${renewal.riskFactors && renewal.riskFactors.length > 0 ? `
                                <div class="renewal-risks">
                                    <strong>Risk Factors:</strong>
                                    <ul>
                                        ${renewal.riskFactors.map(risk => `<li>${risk}</li>`).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display contract performance metrics
        function displayContractPerformanceMetrics(performanceMetrics) {
            const contractPerformanceMetrics = safeGetElement('contractPerformanceMetrics');
            if (!contractPerformanceMetrics || !performanceMetrics) return;

            const getPerformanceClass = (score) => {
                if (score >= 85) return 'excellent';
                if (score >= 70) return 'good';
                if (score >= 55) return 'fair';
                return 'poor';
            };

            contractPerformanceMetrics.innerHTML = `
                <div class="performance-metrics-grid">
                    <div class="performance-score-card">
                        <div class="performance-score-value">${performanceMetrics.overallScore}</div>
                        <div class="performance-score-label">Overall Performance Score</div>
                        <div style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">
                            Based on ${performanceMetrics.scoredContracts} of ${performanceMetrics.totalContracts} contracts
                        </div>
                    </div>
                    <div class="performance-breakdown">
                        <div class="performance-breakdown-title">Performance Breakdown</div>
                        ${Object.entries(performanceMetrics.performanceBreakdown || {}).map(([category, score]) => `
                            <div class="performance-category">
                                <div class="performance-category-name">${category.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</div>
                                <div class="performance-category-score ${getPerformanceClass(score)}">${Math.round(score)}%</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ${Object.keys(performanceMetrics.categoryPerformance || {}).length > 0 ? `
                    <div class="category-performance" style="margin-top: 20px;">
                        <h4>Category Performance</h4>
                        <div class="performance-breakdown">
                            ${Object.entries(performanceMetrics.categoryPerformance).map(([category, score]) => `
                                <div class="performance-category">
                                    <div class="performance-category-name">${category}</div>
                                    <div class="performance-category-score ${getPerformanceClass(score)}">${Math.round(score)}%</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;
        }

        // Display contract volume commitments
        function displayContractVolumeCommitments(volumeCommitments) {
            const contractVolumeCommitments = safeGetElement('contractVolumeCommitments');
            if (!contractVolumeCommitments || !volumeCommitments) return;

            const { commitments, summary } = volumeCommitments;

            contractVolumeCommitments.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div class="performance-breakdown">
                        <div class="performance-breakdown-title">Commitment Summary</div>
                        <div class="performance-category">
                            <div class="performance-category-name">Total Commitments</div>
                            <div class="performance-category-score">${summary.totalCommitments}</div>
                        </div>
                        <div class="performance-category">
                            <div class="performance-category-name">Compliant Contracts</div>
                            <div class="performance-category-score">${summary.compliantCount}</div>
                        </div>
                        <div class="performance-category">
                            <div class="performance-category-name">Compliance Rate</div>
                            <div class="performance-category-score ${summary.complianceRate >= 80 ? 'excellent' : summary.complianceRate >= 60 ? 'good' : 'fair'}">${summary.complianceRate}%</div>
                        </div>
                    </div>
                </div>
                ${commitments && commitments.length > 0 ? `
                    <div class="volume-commitments-grid">
                        ${commitments.map(commitment => `
                            <div class="volume-commitment-item ${commitment.status.toLowerCase().replace('-', '-')}">
                                <div class="volume-commitment-header">
                                    <div class="volume-commitment-supplier">${commitment.supplier}</div>
                                    <div class="volume-commitment-status ${commitment.status.toLowerCase().replace('-', '-')}">${commitment.status}</div>
                                </div>
                                <div class="renewal-details">
                                    <div class="renewal-detail">
                                        <strong>Estimated Commitment:</strong> $${Math.round(commitment.estimatedCommitment).toLocaleString()}
                                    </div>
                                    <div class="renewal-detail">
                                        <strong>Actual Spend:</strong> $${Math.round(commitment.actualSpend).toLocaleString()}
                                    </div>
                                    <div class="renewal-detail">
                                        <strong>Variance:</strong> ${Math.round(commitment.variance * 100)}%
                                    </div>
                                    <div class="renewal-detail">
                                        <strong>Categories:</strong> ${commitment.categories.join(', ')}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : '<div class="no-data-message"><p>No volume commitment data available.</p></div>'}
            `;
        }

        // Display contract optimization opportunities
        function displayContractOptimizationOpportunities(opportunities) {
            const contractOptimizationOpportunities = safeGetElement('contractOptimizationOpportunities');
            if (!contractOptimizationOpportunities) return;

            if (!opportunities || opportunities.length === 0) {
                contractOptimizationOpportunities.innerHTML = `
                    <div class="no-data-message">
                        <p>No optimization opportunities identified at this time.</p>
                    </div>
                `;
                return;
            }

            contractOptimizationOpportunities.innerHTML = `
                <div class="optimization-opportunities-grid">
                    ${opportunities.map(opportunity => `
                        <div class="optimization-opportunity priority-${opportunity.priority.toLowerCase()}">
                            <div class="optimization-header">
                                <div class="optimization-type">${opportunity.type}</div>
                                <div class="optimization-savings">$${Math.round(opportunity.savingsPotential).toLocaleString()}</div>
                            </div>
                            <div class="optimization-description">
                                ${opportunity.description}
                            </div>
                            <div class="optimization-details">
                                <div class="optimization-detail">
                                    <strong>Category:</strong> ${opportunity.category}
                                </div>
                                <div class="optimization-detail">
                                    <strong>Current Value:</strong> $${Math.round(opportunity.currentValue).toLocaleString()}
                                </div>
                                <div class="optimization-detail">
                                    <strong>Priority:</strong> ${opportunity.priority}
                                </div>
                                <div class="optimization-detail">
                                    <strong>Implementation:</strong> ${opportunity.implementation}
                                </div>
                                <div class="optimization-detail">
                                    <strong>Effort:</strong> ${opportunity.effort}
                                </div>
                                <div class="optimization-detail">
                                    <strong>Suppliers:</strong> ${opportunity.suppliers.join(', ')}
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display contract risk assessment
        function displayContractRiskAssessment(riskAssessment) {
            const contractRiskAssessment = safeGetElement('contractRiskAssessment');
            if (!contractRiskAssessment || !riskAssessment) return;

            contractRiskAssessment.innerHTML = `
                <div class="risk-assessment-grid">
                    <div class="risk-score-card">
                        <div class="risk-score-value">${riskAssessment.overallRiskScore}</div>
                        <div class="risk-score-label">Overall Risk Score</div>
                        <div style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">
                            ${riskAssessment.overallRiskScore >= 70 ? 'High Risk' : riskAssessment.overallRiskScore >= 40 ? 'Medium Risk' : 'Low Risk'}
                        </div>
                    </div>
                    <div class="risk-factors">
                        <div class="risk-factors-title">Risk Distribution</div>
                        <div class="risk-factor">
                            <div class="risk-factor-name">High Risk Contracts</div>
                            <div class="risk-factor-level high">${riskAssessment.riskDistribution.high}</div>
                        </div>
                        <div class="risk-factor">
                            <div class="risk-factor-name">Medium Risk Contracts</div>
                            <div class="risk-factor-level medium">${riskAssessment.riskDistribution.medium}</div>
                        </div>
                        <div class="risk-factor">
                            <div class="risk-factor-name">Low Risk Contracts</div>
                            <div class="risk-factor-level low">${riskAssessment.riskDistribution.low}</div>
                        </div>
                    </div>
                </div>
                ${riskAssessment.riskFactors && riskAssessment.riskFactors.length > 0 ? `
                    <div style="margin-top: 20px;">
                        <h4>Portfolio Risk Factors</h4>
                        <div class="risk-factors">
                            ${riskAssessment.riskFactors.map(factor => `
                                <div class="risk-factor">
                                    <div class="risk-factor-name">${factor.factor}</div>
                                    <div class="risk-factor-level ${factor.severity.toLowerCase()}">${factor.severity}</div>
                                </div>
                                <div style="font-size: 0.9rem; color: #6c757d; margin-top: 5px;">
                                    ${factor.description}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
                ${riskAssessment.highRiskContracts && riskAssessment.highRiskContracts.length > 0 ? `
                    <div style="margin-top: 20px;">
                        <h4>High Risk Contracts</h4>
                        <div class="renewal-pipeline-grid">
                            ${riskAssessment.highRiskContracts.map(contract => `
                                <div class="renewal-item priority-high">
                                    <div class="renewal-header">
                                        <div class="renewal-supplier">${contract.supplier}</div>
                                        <div class="renewal-priority high">Risk: ${contract.riskScore}</div>
                                    </div>
                                    <div class="renewal-details">
                                        <div class="renewal-detail">
                                            <strong>Annual Value:</strong> $${Math.round(contract.annualValue).toLocaleString()}
                                        </div>
                                        <div class="renewal-detail">
                                            <strong>Risk Factors:</strong> ${contract.riskFactors.join(', ')}
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;
        }

        // Display contract recommendations
        function displayContractRecommendations(recommendations) {
            const contractRecommendations = safeGetElement('contractRecommendations');
            if (!contractRecommendations) return;

            if (!recommendations || recommendations.length === 0) {
                contractRecommendations.innerHTML = `
                    <div class="no-data-message">
                        <p>No strategic recommendations available at this time.</p>
                    </div>
                `;
                return;
            }

            contractRecommendations.innerHTML = `
                <div class="recommendations-grid">
                    ${recommendations.map(recommendation => `
                        <div class="recommendation-card priority-${recommendation.priority.toLowerCase()}">
                            <div class="recommendation-header">
                                <div class="recommendation-title">${recommendation.title}</div>
                                <div class="recommendation-priority ${recommendation.priority.toLowerCase()}">${recommendation.priority}</div>
                            </div>
                            <div class="recommendation-description">
                                ${recommendation.description}
                            </div>
                            <div class="recommendation-meta">
                                <div class="recommendation-meta-item">
                                    <strong>Category:</strong> ${recommendation.category}
                                </div>
                                <div class="recommendation-meta-item">
                                    <strong>Impact:</strong> ${recommendation.impact}
                                </div>
                                <div class="recommendation-meta-item">
                                    <strong>Timeline:</strong> ${recommendation.timeline}
                                </div>
                                <div class="recommendation-meta-item">
                                    <strong>Effort:</strong> ${recommendation.effort}
                                </div>
                                <div class="recommendation-meta-item">
                                    <strong>Owner:</strong> ${recommendation.owner}
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display forecast summary
        function displayForecastSummary(summary) {
            const forecastSummary = safeGetElement('forecastSummary');
            if (!forecastSummary || !summary) return;

            const growthDirection = summary.projectedGrowthPercentage >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';
            const growthColor = summary.projectedGrowthPercentage >= 0 ? '#28a745' : '#dc3545';

            forecastSummary.innerHTML = `
                <div class="forecast-summary-grid">
                    <div class="forecast-summary-card primary">
                        <div class="forecast-card-header">
                            <h4>ðŸ’° Total Projected Spend</h4>
                            <span class="forecast-period">(Next ${summary.forecastPeriod} Months)</span>
                        </div>
                        <div class="forecast-value">$${summary.totalProjectedSpend.toFixed(0).toLocaleString()}</div>
                        <div class="forecast-change" style="color: ${growthColor}">
                            ${growthDirection} ${Math.abs(summary.projectedGrowthPercentage).toFixed(1)}% vs Historical
                        </div>
                    </div>
                    
                    <div class="forecast-summary-card">
                        <div class="forecast-card-header">
                            <h4>ðŸ“Š Historical Baseline</h4>
                        </div>
                        <div class="forecast-value">$${summary.totalHistoricalSpend.toFixed(0).toLocaleString()}</div>
                        <div class="forecast-subtitle">Average Annual Spend</div>
                    </div>
                    
                    <div class="forecast-summary-card">
                        <div class="forecast-card-header">
                            <h4>ðŸ“ˆ Highest Growth Category</h4>
                        </div>
                        <div class="forecast-category">${summary.highestGrowthCategory}</div>
                        <div class="forecast-growth">+${summary.highestGrowthRate.toFixed(1)}% Growth</div>
                    </div>
                    
                    <div class="forecast-summary-card">
                        <div class="forecast-card-header">
                            <h4>ðŸ“‰ Lowest Growth Category</h4>
                        </div>
                        <div class="forecast-category">${summary.lowestGrowthCategory}</div>
                        <div class="forecast-decline">${summary.lowestGrowthRate.toFixed(1)}% Growth</div>
                    </div>
                    
                    <div class="forecast-summary-card">
                        <div class="forecast-card-header">
                            <h4>ðŸŽ¯ Categories Forecasted</h4>
                        </div>
                        <div class="forecast-value">${summary.categoryCount}</div>
                        <div class="forecast-subtitle">With Reliable Data</div>
                    </div>
                    
                    ${summary.scenarioRange ? `
                    <div class="forecast-summary-card">
                        <div class="forecast-card-header">
                            <h4>ðŸ”„ Scenario Range</h4>
                        </div>
                        <div class="forecast-range">
                            $${summary.scenarioRange.min.toFixed(0).toLocaleString()} - 
                            $${summary.scenarioRange.max.toFixed(0).toLocaleString()}
                        </div>
                        <div class="forecast-subtitle">Conservative to Optimistic</div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // Display total spend forecast with chart
        function displayTotalSpendForecast(totalSpendForecast) {
            const totalForecastMetrics = safeGetElement('totalForecastMetrics');
            if (!totalForecastMetrics || !totalSpendForecast) return;

            // Display metrics
            totalForecastMetrics.innerHTML = `
                <div class="forecast-metrics-grid">
                    <div class="forecast-metric">
                        <div class="metric-label">Projected Annual Growth</div>
                        <div class="metric-value growth">${totalSpendForecast.growthRate.toFixed(1)}%</div>
                    </div>
                    <div class="forecast-metric">
                        <div class="metric-label">Forecast Confidence</div>
                        <div class="metric-value confidence">${(totalSpendForecast.confidence * 100).toFixed(0)}%</div>
                    </div>
                    <div class="forecast-metric">
                        <div class="metric-label">Historical Data Points</div>
                        <div class="metric-value">${totalSpendForecast.historical.length} Months</div>
                    </div>
                    <div class="forecast-metric">
                        <div class="metric-label">Projected Change</div>
                        <div class="metric-value ${totalSpendForecast.projectedAnnualSpend > totalSpendForecast.totalHistoricalSpend ? 'positive' : 'negative'}">
                            $${Math.abs(totalSpendForecast.projectedAnnualSpend - totalSpendForecast.totalHistoricalSpend).toFixed(0).toLocaleString()}
                        </div>
                    </div>
                </div>
            `;

            // Create forecast chart
            createTotalForecastChart(totalSpendForecast);
        }

        // Create total spend forecast chart
        function createTotalForecastChart(totalSpendForecast) {
            const canvas = safeGetElement('totalForecastChart');
            if (!canvas || !totalSpendForecast) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart if it exists
            if (charts.totalForecast) {
                charts.totalForecast.destroy();
            }

            // Prepare data
            const historicalData = totalSpendForecast.historical.map(d => ({
                x: d.month,
                y: d.spend
            }));

            const forecastData = totalSpendForecast.forecast.map(d => ({
                x: d.month,
                y: d.spend
            }));

            const upperBoundData = totalSpendForecast.forecast.map(d => ({
                x: d.month,
                y: d.upperBound
            }));

            const lowerBoundData = totalSpendForecast.forecast.map(d => ({
                x: d.month,
                y: d.lowerBound
            }));

            charts.totalForecast = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Historical Spend',
                            data: historicalData,
                            borderColor: '#2196f3',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4
                        },
                        {
                            label: 'Forecast',
                            data: forecastData,
                            borderColor: '#ff9800',
                            backgroundColor: 'rgba(255, 152, 0, 0.1)',
                            borderWidth: 3,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.4
                        },
                        {
                            label: 'Upper Bound (95% CI)',
                            data: upperBoundData,
                            borderColor: 'rgba(255, 152, 0, 0.3)',
                            backgroundColor: 'rgba(255, 152, 0, 0.05)',
                            borderWidth: 1,
                            fill: '+1',
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'Lower Bound (95% CI)',
                            data: lowerBoundData,
                            borderColor: 'rgba(255, 152, 0, 0.3)',
                            backgroundColor: 'rgba(255, 152, 0, 0.05)',
                            borderWidth: 1,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Total Spend Forecast with Confidence Intervals',
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function (context) {
                                    return context.dataset.label + ': $' + context.parsed.y.toFixed(0).toLocaleString();
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            title: {
                                display: true,
                                text: 'Month'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Spend ($)'
                            },
                            ticks: {
                                callback: function (value) {
                                    return '$' + value.toFixed(0).toLocaleString();
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        // Display category forecasts
        function displayCategoryForecasts(categoryForecasts) {
            const categoryForecastsElement = safeGetElement('categoryForecasts');
            if (!categoryForecastsElement || !categoryForecasts) return;

            const categories = Object.entries(categoryForecasts)
                .sort(([, a], [, b]) => b.projectedAnnualSpend - a.projectedAnnualSpend)
                .slice(0, 8); // Show top 8 categories

            if (categories.length === 0) {
                categoryForecastsElement.innerHTML = '<div class="no-forecast-data">Insufficient data for category forecasting</div>';
                return;
            }

            categoryForecastsElement.innerHTML = `
                <div class="category-forecasts-grid">
                    ${categories.map(([category, forecast]) => `
                        <div class="category-forecast-card">
                            <div class="category-forecast-header">
                                <h4>${category}</h4>
                                <span class="confidence-badge">${(forecast.confidence * 100).toFixed(0)}% Confidence</span>
                            </div>
                            <div class="category-forecast-metrics">
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Projected Annual:</span>
                                    <span class="metric-value">$${forecast.projectedAnnualSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Historical Average:</span>
                                    <span class="metric-value">$${forecast.totalHistoricalSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Growth Rate:</span>
                                    <span class="metric-value ${forecast.growthRate >= 0 ? 'positive' : 'negative'}">
                                        ${forecast.growthRate >= 0 ? '+' : ''}${forecast.growthRate.toFixed(1)}%
                                    </span>
                                </div>
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Data Points:</span>
                                    <span class="metric-value">${forecast.historical.length} months</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display supplier forecasts
        function displaySupplierForecasts(supplierForecasts) {
            const supplierForecastsElement = safeGetElement('supplierForecasts');
            if (!supplierForecastsElement || !supplierForecasts) return;

            const suppliers = Object.entries(supplierForecasts)
                .sort(([, a], [, b]) => b.projectedAnnualSpend - a.projectedAnnualSpend);

            if (suppliers.length === 0) {
                supplierForecastsElement.innerHTML = '<div class="no-forecast-data">Insufficient data for supplier forecasting</div>';
                return;
            }

            supplierForecastsElement.innerHTML = `
                <div class="supplier-forecasts-grid">
                    ${suppliers.map(([supplier, forecast]) => `
                        <div class="supplier-forecast-card">
                            <div class="supplier-forecast-header">
                                <h4>${supplier}</h4>
                                <span class="risk-badge ${forecast.riskLevel.toLowerCase()}">${forecast.riskLevel} Risk</span>
                            </div>
                            <div class="supplier-forecast-metrics">
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Projected Annual:</span>
                                    <span class="metric-value">$${forecast.projectedAnnualSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Historical Average:</span>
                                    <span class="metric-value">$${forecast.totalHistoricalSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Growth Rate:</span>
                                    <span class="metric-value ${forecast.growthRate >= 0 ? 'positive' : 'negative'}">
                                        ${forecast.growthRate >= 0 ? '+' : ''}${forecast.growthRate.toFixed(1)}%
                                    </span>
                                </div>
                                <div class="forecast-metric-row">
                                    <span class="metric-label">Data Quality:</span>
                                    <span class="metric-value">${forecast.historical.length} months</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display scenario analysis
        function displayScenarioAnalysis(scenarioAnalysis) {
            const scenarioAnalysisElement = safeGetElement('scenarioAnalysis');
            if (!scenarioAnalysisElement || !scenarioAnalysis) return;

            const scenarios = Object.entries(scenarioAnalysis);

            scenarioAnalysisElement.innerHTML = `
                <div class="scenario-analysis-grid">
                    ${scenarios.map(([key, scenario]) => `
                        <div class="scenario-card ${key}">
                            <div class="scenario-header">
                                <h4>${scenario.name}</h4>
                                <span class="risk-indicator ${scenario.riskLevel.toLowerCase()}">${scenario.riskLevel} Risk</span>
                            </div>
                            <div class="scenario-description">${scenario.description}</div>
                            <div class="scenario-metrics">
                                <div class="scenario-metric-row primary">
                                    <span class="metric-label">Projected Spend:</span>
                                    <span class="metric-value">$${scenario.projectedSpend.toFixed(0).toLocaleString()}</span>
                                </div>
                                <div class="scenario-metric-row">
                                    <span class="metric-label">Change from Baseline:</span>
                                    <span class="metric-value ${scenario.spendChange >= 0 ? 'negative' : 'positive'}">
                                        ${scenario.spendChange >= 0 ? '+' : ''}$${scenario.spendChange.toFixed(0).toLocaleString()}
                                    </span>
                                </div>
                                <div class="scenario-metric-row">
                                    <span class="metric-label">Percentage Change:</span>
                                    <span class="metric-value ${scenario.percentageChange >= 0 ? 'negative' : 'positive'}">
                                        ${scenario.percentageChange >= 0 ? '+' : ''}${scenario.percentageChange.toFixed(1)}%
                                    </span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display forecast accuracy and data quality
        function displayForecastAccuracy(accuracyMetrics) {
            const forecastAccuracyElement = safeGetElement('forecastAccuracy');
            if (!forecastAccuracyElement || !accuracyMetrics) return;

            forecastAccuracyElement.innerHTML = `
                <div class="accuracy-metrics-grid">
                    <div class="accuracy-card">
                        <div class="accuracy-header">
                            <h4>ðŸ“Š Forecast Accuracy</h4>
                        </div>
                        <div class="accuracy-value">${accuracyMetrics.forecastAccuracy.toFixed(1)}%</div>
                        <div class="accuracy-subtitle">Overall Accuracy</div>
                    </div>
                    
                    <div class="accuracy-card">
                        <div class="accuracy-header">
                            <h4>ðŸ“ˆ Mean Absolute Error</h4>
                        </div>
                        <div class="accuracy-value">${accuracyMetrics.meanAbsolutePercentageError.toFixed(1)}%</div>
                        <div class="accuracy-subtitle">MAPE</div>
                    </div>
                    
                    <div class="accuracy-card">
                        <div class="accuracy-header">
                            <h4>ðŸŽ¯ Confidence Level</h4>
                        </div>
                        <div class="accuracy-value">${accuracyMetrics.confidenceLevel}%</div>
                        <div class="accuracy-subtitle">Statistical Confidence</div>
                    </div>
                    
                    <div class="accuracy-card">
                        <div class="accuracy-header">
                            <h4>ðŸ“‹ Data Quality</h4>
                        </div>
                        <div class="accuracy-value quality-${accuracyMetrics.dataQuality.toLowerCase()}">${accuracyMetrics.dataQuality}</div>
                        <div class="accuracy-subtitle">Overall Assessment</div>
                    </div>
                </div>
                
                <div class="forecast-methodology">
                    <h4>ðŸ”¬ Forecasting Methodology</h4>
                    <div class="methodology-content">
                        <div class="methodology-item">
                            <strong>Algorithm:</strong> Exponential Smoothing with Trend and Seasonality
                        </div>
                        <div class="methodology-item">
                            <strong>Confidence Intervals:</strong> 95% statistical confidence bands
                        </div>
                        <div class="methodology-item">
                            <strong>Seasonality Integration:</strong> Leverages existing seasonality analysis for enhanced accuracy
                        </div>
                        <div class="methodology-item">
                            <strong>Forecast Horizon:</strong> 12 months with monthly granularity
                        </div>
                        <div class="methodology-item">
                            <strong>Data Requirements:</strong> Minimum 6 months of historical data for reliable forecasting
                        </div>
                    </div>
                </div>
            `;
        }

        // Tab switching function for consolidation opportunities
        function showConsolidationTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.consolidation-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.consolidation-tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to selected tab and content
            const selectedBtn = document.querySelector(`[onclick="showConsolidationTab('${tabName}')"]`);
            const selectedContent = document.getElementById(`${tabName}-tab`);

            if (selectedBtn) selectedBtn.classList.add('active');
            if (selectedContent) selectedContent.classList.add('active');
        }

        // Filter Customization Functions
        function showFilterCustomizer() {
            const modal = document.getElementById('filterCustomizerModal');
            if (modal) {
                modal.classList.add('show');
                populateFieldSelector();
            }
        }

        function closeFilterCustomizer() {
            const modal = document.getElementById('filterCustomizerModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        function populateFieldSelector() {
            const availableFieldsDiv = document.getElementById('availableFields');
            const selectedFieldsDiv = document.getElementById('selectedFields');

            if (!availableFieldsDiv || !selectedFieldsDiv) return;

            // Clear existing content
            availableFieldsDiv.innerHTML = '';
            selectedFieldsDiv.innerHTML = '';

            // Get current selected fields or use defaults
            const currentSelected = selectedFilterFields.length > 0 ? selectedFilterFields : defaultFilterFields;

            // Populate available fields - only show filterable fields
            Object.entries(availableFieldsData).forEach(([field, data]) => {
                if (data.isFilterable) {
                    const fieldItem = createFieldItem(field, data.displayName, data.uniqueValues, data.isCore);

                    if (currentSelected.includes(field)) {
                        fieldItem.classList.add('selected');
                        selectedFieldsDiv.appendChild(fieldItem);
                    } else {
                        availableFieldsDiv.appendChild(fieldItem);
                    }
                }
            });

            // Add instruction messages if empty
            if (availableFieldsDiv.children.length === 0) {
                availableFieldsDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">All fields are selected</div>';
            }
            if (selectedFieldsDiv.children.length === 0) {
                selectedFieldsDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No fields selected</div>';
            }
        }

        function createFieldItem(fieldKey, displayName, uniqueCount, isCore) {
            const div = document.createElement('div');
            div.className = 'field-item';
            div.dataset.field = fieldKey;
            div.onclick = () => toggleFieldSelection(fieldKey);

            div.innerHTML = `
                <span class="field-name">${displayName} ${isCore ? '<span style="color: #667eea; font-size: 0.8rem;">(core)</span>' : ''}</span>
                <span class="field-count">${uniqueCount} unique</span>
            `;

            return div;
        }

        function toggleFieldSelection(fieldKey) {
            const availableFieldsDiv = document.getElementById('availableFields');
            const selectedFieldsDiv = document.getElementById('selectedFields');
            const fieldItem = document.querySelector(`[data-field="${fieldKey}"]`);

            if (!fieldItem) return;

            if (fieldItem.parentElement.id === 'availableFields') {
                selectedFieldsDiv.appendChild(fieldItem);
                fieldItem.classList.add('selected');
            } else {
                availableFieldsDiv.appendChild(fieldItem);
                fieldItem.classList.remove('selected');
            }

            // Clear empty messages
            [availableFieldsDiv, selectedFieldsDiv].forEach(div => {
                if (div.querySelector('div[style*="color: #999"]')) {
                    div.innerHTML = '';
                }
            });

            // Add empty messages if needed
            if (availableFieldsDiv.children.length === 0) {
                availableFieldsDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">All fields are selected</div>';
            }
            if (selectedFieldsDiv.children.length === 0) {
                selectedFieldsDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No fields selected</div>';
            }
        }

        function addSelectedFields() {
            const availableFieldsDiv = document.getElementById('availableFields');
            const selectedItems = availableFieldsDiv.querySelectorAll('.field-item.selected');

            selectedItems.forEach(item => {
                toggleFieldSelection(item.dataset.field);
            });
        }

        function removeSelectedFields() {
            const selectedFieldsDiv = document.getElementById('selectedFields');
            const selectedItems = selectedFieldsDiv.querySelectorAll('.field-item.selected');

            selectedItems.forEach(item => {
                toggleFieldSelection(item.dataset.field);
            });
        }

        function resetToDefaults() {
            const availableFieldsDiv = document.getElementById('availableFields');
            const selectedFieldsDiv = document.getElementById('selectedFields');

            // Move all to available first
            const allSelected = selectedFieldsDiv.querySelectorAll('.field-item');
            allSelected.forEach(item => {
                availableFieldsDiv.appendChild(item);
                item.classList.remove('selected');
            });

            // Then move defaults to selected
            defaultFilterFields.forEach(field => {
                const fieldItem = document.querySelector(`[data-field="${field}"]`);
                if (fieldItem) {
                    selectedFieldsDiv.appendChild(fieldItem);
                    fieldItem.classList.add('selected');
                }
            });

            // Update empty messages
            populateFieldSelector();
        }

        function clearAllFilters() {
            const availableFieldsDiv = document.getElementById('availableFields');
            const selectedFieldsDiv = document.getElementById('selectedFields');

            const allSelected = selectedFieldsDiv.querySelectorAll('.field-item');
            allSelected.forEach(item => {
                availableFieldsDiv.appendChild(item);
                item.classList.remove('selected');
            });

            // Update empty messages
            if (selectedFieldsDiv.children.length === 0) {
                selectedFieldsDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No fields selected</div>';
            }
            if (availableFieldsDiv.querySelector('div[style*="color: #999"]')) {
                availableFieldsDiv.innerHTML = '';
                Object.entries(availableFieldsData).forEach(([field, data]) => {
                    if (data.isFilterable) {
                        const fieldItem = createFieldItem(field, data.displayName, data.uniqueValues, data.isCore);
                        availableFieldsDiv.appendChild(fieldItem);
                    }
                });
            }
        }

        function cancelFilterCustomization() {
            closeFilterCustomizer();
        }

        function applyFilterCustomization() {
            const selectedFieldsDiv = document.getElementById('selectedFields');
            const selectedItems = selectedFieldsDiv.querySelectorAll('.field-item');

            // Update selected filter fields
            selectedFilterFields = Array.from(selectedItems).map(item => item.dataset.field);

            // Save to localStorage
            localStorage.setItem('vstx-selected-filters', JSON.stringify(selectedFilterFields));

            // Rebuild filters with new configuration
            rebuildFilters();

            // Close modal
            closeFilterCustomizer();

            // Show success message
            showStatus('Filter configuration updated successfully', 'success');
        }

        function rebuildFilters() {
            const filterRow = document.getElementById('filterRow');
            if (!filterRow) return;

            // Clear existing filters except the Clear All button
            const clearButton = filterRow.querySelector('button[onclick="clearFilters()"]');
            filterRow.innerHTML = '';

            // Use selected fields or defaults
            const fieldsToShow = selectedFilterFields.length > 0 ? selectedFilterFields : defaultFilterFields;

            // Create filter elements for each selected field
            fieldsToShow.forEach(fieldKey => {
                if (availableFieldsData[fieldKey]) {
                    const filterGroup = createFilterGroup(fieldKey, availableFieldsData[fieldKey]);
                    filterRow.appendChild(filterGroup);
                }
            });

            // Special handling for supplier filter (always text input)
            if (fieldsToShow.includes('supplier')) {
                const supplierGroup = createSupplierFilterGroup();
                filterRow.appendChild(supplierGroup);
            }

            // Re-add the Clear All button
            filterRow.appendChild(clearButton);

            // Populate the new filters with data
            populateDynamicFilters();
        }

        function createFilterGroup(fieldKey, fieldData) {
            const div = document.createElement('div');
            div.className = 'filter-group';

            const label = document.createElement('label');
            label.className = 'filter-label';
            label.textContent = fieldData.displayName;

            const select = document.createElement('select');
            select.className = 'filter-input';
            select.id = fieldKey + 'Filter';
            select.onchange = () => {
                if (fieldKey === 'category') {
                    updateSubcategoryFilter();
                }
                applyFilters();
            };

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = `All ${fieldData.displayName}s`;
            select.appendChild(defaultOption);

            div.appendChild(label);
            div.appendChild(select);

            return div;
        }

        function createSupplierFilterGroup() {
            const div = document.createElement('div');
            div.className = 'filter-group';

            const label = document.createElement('label');
            label.className = 'filter-label';
            label.textContent = 'Supplier';

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'filter-input';
            input.id = 'supplierFilter';
            input.placeholder = 'Search suppliers...';
            input.onkeyup = applyFilters;

            div.appendChild(label);
            div.appendChild(input);

            return div;
        }

        function populateDynamicFilters() {
            const fieldsToShow = selectedFilterFields.length > 0 ? selectedFilterFields : defaultFilterFields;

            fieldsToShow.forEach(fieldKey => {
                if (fieldKey === 'supplier') return; // Skip supplier as it's a text input

                const filter = document.getElementById(fieldKey + 'Filter');
                if (filter && availableFieldsData[fieldKey]) {
                    // Clear existing options except the first one
                    while (filter.options.length > 1) {
                        filter.remove(1);
                    }

                    // Add sorted options
                    const values = Array.from(availableFieldsData[fieldKey].values).sort();
                    values.forEach(value => {
                        if (value && value.trim() !== '') {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            filter.appendChild(option);
                        }
                    });
                }
            });

            // Update subcategory filter if category is selected
            if (fieldsToShow.includes('category') && fieldsToShow.includes('subcategory')) {
                updateSubcategoryFilter();
            }
        }

        // Load saved filter configuration on startup
        function loadFilterConfiguration() {
            const saved = localStorage.getItem('vstx-selected-filters');
            if (saved) {
                try {
                    selectedFilterFields = JSON.parse(saved);
                } catch (e) {
                    selectedFilterFields = [];
                }
            }
        }

        // Smart Search Functions
        function handleNLQKeyPress(event) {
            if (event.key === 'Enter') {
                processNLQuery();
            }
        }
        
        function setNLQuery(query) {
            const input = document.getElementById('nlqInput');
            if (input) {
                input.value = query;
                processNLQuery();
            }
        }
        
        function processNLQuery() {
            const input = document.getElementById('nlqInput');
            if (!input || !input.value.trim()) return;
            
            const query = input.value.trim();
            console.log('Processing Smart Search:', query);
            
            // Process the search query
            const results = aiInsightsEngine.processSmartSearch(query, currentInsights);
            
            // Update the display with filtered results
            filteredInsights = results;
            displayInsights();
            
            // Show feedback
            const insightsList = document.getElementById('insightsList');
            if (results.length === 0) {
                insightsList.innerHTML = `
                    <div class="no-insights">
                        <p>No insights found matching: <strong>"${query}"</strong></p>
                        <p>Try different keywords or <button onclick="clearNLQuery()" style="color: var(--accent-gradient-start); background: none; border: none; cursor: pointer; text-decoration: underline;">clear the search</button></p>
                    </div>
                `;
            } else {
                // Add a header showing the search results
                const header = document.createElement('div');
                header.className = 'nlq-results-header';
                header.innerHTML = `
                    <p style="padding: 10px; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 15px;">
                        Found <strong>${results.length}</strong> insights matching: <strong>"${query}"</strong>
                        <button onclick="clearNLQuery()" style="float: right; color: var(--accent-gradient-start); background: none; border: none; cursor: pointer;">Clear</button>
                    </p>
                `;
                insightsList.insertBefore(header, insightsList.firstChild);
            }
            
            // Update tab counts if in tab view
            if (insightsViewMode === 'tab') {
                updateInsightTabs();
            }
        }
        
        function clearNLQuery() {
            const input = document.getElementById('nlqInput');
            if (input) {
                input.value = '';
            }
            
            // Reset to show all insights
            filteredInsights = currentInsights;
            filterInsights();
        }
        
        // AI Assistant Functions
        function setAIQuery(query) {
            const textarea = document.getElementById('aiAssistantInput');
            if (textarea) {
                textarea.value = query;
                processAIQuery();
            }
        }
        
        async function processAIQuery() {
            const textarea = document.getElementById('aiAssistantInput');
            const responseDiv = document.getElementById('aiAssistantResponse');
            const button = document.querySelector('.ai-assistant-button');
            const buttonText = button.querySelector('.ai-button-text');
            const buttonSpinner = button.querySelector('.ai-button-spinner');
            
            if (!textarea || !textarea.value.trim()) return;
            
            const query = textarea.value.trim();
            
            // Check if API key is configured
            if (!aiAssistantConfig.apiKey) {
                showAIResponse('error', 'Please configure your API key first by clicking the settings button.');
                return;
            }
            
            // Show loading state
            button.disabled = true;
            buttonText.style.display = 'none';
            buttonSpinner.style.display = 'inline';
            responseDiv.style.display = 'block';
            responseDiv.innerHTML = `
                <div class="ai-loading">
                    <div class="ai-loading-spinner"></div>
                    <span>AI is analyzing your data and preparing a response...</span>
                </div>
            `;
            
            try {
                // Prepare context data
                const context = prepareDataContext();
                
                // Call the appropriate AI API
                let response;
                if (aiAssistantConfig.provider === 'openai') {
                    response = await callOpenAI(query, context);
                } else if (aiAssistantConfig.provider === 'anthropic') {
                    response = await callAnthropic(query, context);
                }
                
                // Display the response
                showAIResponse('success', response);
                
            } catch (error) {
                console.error('AI Assistant Error:', error);
                showAIResponse('error', `Error: ${error.message}`);
            } finally {
                // Reset button state
                button.disabled = false;
                buttonText.style.display = 'inline';
                buttonSpinner.style.display = 'none';
            }
        }
        
        function prepareDataContext() {
            const data = filteredData || processedData || [];
            
            // Prepare a summary of the current data
            const summary = {
                totalRecords: data.length,
                totalSpend: data.reduce((sum, row) => sum + row.amount, 0),
                categories: [...new Set(data.map(row => row.category))],
                suppliers: [...new Set(data.map(row => row.supplier))],
                dateRange: {
                    start: data.length > 0 ? new Date(Math.min(...data.map(row => new Date(row.date)))).toISOString() : null,
                    end: data.length > 0 ? new Date(Math.max(...data.map(row => new Date(row.date)))).toISOString() : null
                }
            };
            
            // Include current insights
            const insightsSummary = currentInsights.map(insight => ({
                type: insight.type,
                severity: insight.severity,
                title: insight.title,
                summary: insight.summary
            }));
            
            // Category breakdown
            const categoryBreakdown = {};
            data.forEach(row => {
                if (!categoryBreakdown[row.category]) {
                    categoryBreakdown[row.category] = {
                        spend: 0,
                        transactions: 0,
                        suppliers: new Set()
                    };
                }
                categoryBreakdown[row.category].spend += row.amount;
                categoryBreakdown[row.category].transactions++;
                categoryBreakdown[row.category].suppliers.add(row.supplier);
            });
            
            // Convert sets to counts
            Object.keys(categoryBreakdown).forEach(cat => {
                categoryBreakdown[cat].supplierCount = categoryBreakdown[cat].suppliers.size;
                delete categoryBreakdown[cat].suppliers;
            });
            
            return {
                summary,
                insights: insightsSummary,
                categoryBreakdown,
                recentTransactions: data.slice(-10).map(row => ({
                    date: row.date,
                    supplier: row.supplier,
                    category: row.category,
                    amount: row.amount
                }))
            };
        }
        
        async function callOpenAI(query, context) {
            const messages = [
                {
                    role: 'system',
                    content: `You are an expert procurement analyst AI assistant. You have access to procurement data and insights. 
                             Analyze the data and provide actionable insights. Be specific, data-driven, and provide concrete recommendations.
                             Format your responses with clear sections and bullet points where appropriate.`
                },
                {
                    role: 'user',
                    content: `Context Data: ${JSON.stringify(context, null, 2)}\n\nQuestion: ${query}`
                }
            ];
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${aiAssistantConfig.apiKey}`
                },
                body: JSON.stringify({
                    model: aiAssistantConfig.model,
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 1000
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'OpenAI API request failed');
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        async function callAnthropic(query, context) {
            const prompt = `Context Data: ${JSON.stringify(context, null, 2)}\n\nQuestion: ${query}`;
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': aiAssistantConfig.apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-opus-20240229',
                    max_tokens: 1000,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    system: `You are an expert procurement analyst AI assistant. You have access to procurement data and insights. 
                            Analyze the data and provide actionable insights. Be specific, data-driven, and provide concrete recommendations.
                            Format your responses with clear sections and bullet points where appropriate.`
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'Anthropic API request failed');
            }
            
            const data = await response.json();
            return data.content[0].text;
        }
        
        function showAIResponse(type, content) {
            const responseDiv = document.getElementById('aiAssistantResponse');
            if (!responseDiv) return;
            
            if (type === 'error') {
                responseDiv.innerHTML = `
                    <div class="ai-response-header">
                        <span style="font-size: 1.5rem;">âŒ</span>
                        <h3 style="color: var(--status-error-text); margin: 0;">Error</h3>
                    </div>
                    <div class="ai-response-content">
                        <p>${content}</p>
                    </div>
                `;
            } else {
                // Convert markdown-like formatting to HTML
                const formattedContent = content
                    .replace(/### (.*)/g, '<h3>$1</h3>')
                    .replace(/## (.*)/g, '<h3>$1</h3>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/- (.*)/g, '<li>$1</li>')
                    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/^/, '<p>')
                    .replace(/$/, '</p>');
                
                responseDiv.innerHTML = `
                    <div class="ai-response-header">
                        <span style="font-size: 1.5rem;">ðŸ¤–</span>
                        <h3 style="margin: 0;">AI Analysis</h3>
                        <span style="margin-left: auto; font-size: 0.9rem; color: var(--text-secondary);">
                            ${new Date().toLocaleTimeString()}
                        </span>
                    </div>
                    <div class="ai-response-content">
                        ${formattedContent}
                    </div>
                `;
            }
        }
        
        function configureAIAssistant() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h2>AI Assistant Configuration</h2>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>AI Provider:</label>
                            <select id="aiProvider" class="form-control" onchange="updateModelOptions()">
                                <option value="openai" ${aiAssistantConfig.provider === 'openai' ? 'selected' : ''}>OpenAI</option>
                                <option value="anthropic" ${aiAssistantConfig.provider === 'anthropic' ? 'selected' : ''}>Anthropic (Claude)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>API Key:</label>
                            <input type="password" id="aiApiKey" class="form-control" 
                                   value="${aiAssistantConfig.apiKey}" 
                                   placeholder="Enter your API key">
                            <small style="color: var(--text-secondary);">Your API key is stored locally and never sent to our servers.</small>
                        </div>
                        <div class="form-group" id="modelGroup">
                            <label>Model:</label>
                            <select id="aiModel" class="form-control">
                                ${aiAssistantConfig.provider === 'openai' ? `
                                    <option value="gpt-4-turbo-preview" ${aiAssistantConfig.model === 'gpt-4-turbo-preview' ? 'selected' : ''}>GPT-4 Turbo</option>
                                    <option value="gpt-4" ${aiAssistantConfig.model === 'gpt-4' ? 'selected' : ''}>GPT-4</option>
                                    <option value="gpt-3.5-turbo" ${aiAssistantConfig.model === 'gpt-3.5-turbo' ? 'selected' : ''}>GPT-3.5 Turbo</option>
                                ` : `
                                    <option value="claude-3-opus-20240229" ${aiAssistantConfig.model === 'claude-3-opus-20240229' ? 'selected' : ''}>Claude 3 Opus</option>
                                    <option value="claude-3-sonnet-20240229" ${aiAssistantConfig.model === 'claude-3-sonnet-20240229' ? 'selected' : ''}>Claude 3 Sonnet</option>
                                `}
                            </select>
                        </div>
                        <div class="form-group">
                            <h4>Getting an API Key:</h4>
                            <p style="font-size: 0.9rem; color: var(--text-secondary);">
                                <strong>OpenAI:</strong> Visit <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a><br>
                                <strong>Anthropic:</strong> Visit <a href="https://console.anthropic.com/settings/keys" target="_blank">console.anthropic.com/settings/keys</a>
                            </p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="saveAIAssistantConfig(this.closest('.modal'))">Save Configuration</button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add the updateModelOptions function to window
            window.updateModelOptions = function() {
                const provider = document.getElementById('aiProvider').value;
                const modelSelect = document.getElementById('aiModel');
                
                if (provider === 'openai') {
                    modelSelect.innerHTML = `
                        <option value="gpt-4-turbo-preview">GPT-4 Turbo</option>
                        <option value="gpt-4">GPT-4</option>
                        <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                    `;
                } else {
                    modelSelect.innerHTML = `
                        <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                        <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                    `;
                }
            };
        }
        
        function saveAIAssistantConfig(modal) {
            const provider = document.getElementById('aiProvider').value;
            const apiKey = document.getElementById('aiApiKey').value;
            const model = document.getElementById('aiModel').value;
            
            if (!apiKey) {
                alert('Please enter an API key');
                return;
            }
            
            // Save configuration
            aiAssistantConfig = { provider, apiKey, model };
            localStorage.setItem('ai-assistant-provider', provider);
            localStorage.setItem('ai-assistant-api-key', apiKey);
            localStorage.setItem('ai-assistant-model', model);
            
            // Close modal
            modal.remove();
            
            // Show success message
            showStatus('AI Assistant configured successfully', 'success');
        }

        // AI Insights Functions
        async function refreshAIInsights() {
            const insightsList = document.getElementById('insightsList');
            if (!insightsList) return;
            
            // Show loading state
            insightsList.innerHTML = `
                <div class="insights-loading">
                    <div class="spinner"></div>
                    <p>Analyzing your data...</p>
                </div>
            `;
            
            try {
                // Analyze the current data
                const dataToAnalyze = filteredData || processedData || [];
                currentInsights = await aiInsightsEngine.analyzeData(dataToAnalyze);
                
                // Update summary
                updateInsightsSummary();
                
                // Apply current filters
                filterInsights();
                
                // Update last updated time
                const lastUpdatedEl = document.getElementById('lastUpdated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = new Date().toLocaleTimeString();
                }
            } catch (error) {
                console.error('Error generating insights:', error);
                insightsList.innerHTML = `
                    <div class="error-message">
                        <p>Failed to generate insights. Please try again.</p>
                    </div>
                `;
            }
        }
        
        function updateInsightsSummary() {
            const totalInsightsEl = document.getElementById('totalInsights');
            const highPriorityEl = document.getElementById('highPriorityCount');
            const potentialSavingsEl = document.getElementById('potentialSavings');
            
            if (totalInsightsEl) {
                totalInsightsEl.textContent = currentInsights.length;
            }
            
            if (highPriorityEl) {
                const highPriorityCount = currentInsights.filter(i => i.severity === 'high').length;
                highPriorityEl.textContent = highPriorityCount;
            }
            
            if (potentialSavingsEl) {
                const totalSavings = currentInsights
                    .filter(i => i.type === 'savings' && i.savingsAmount)
                    .reduce((sum, i) => sum + i.savingsAmount, 0);
                potentialSavingsEl.textContent = aiInsightsEngine.formatCurrency(totalSavings);
            }
        }
        
        function filterInsights() {
            const typeFilter = document.getElementById('insightTypeFilter')?.value || 'all';
            const severityFilter = document.getElementById('insightSeverityFilter')?.value || 'all';
            
            filteredInsights = currentInsights.filter(insight => {
                const typeMatch = typeFilter === 'all' || insight.type === typeFilter;
                const severityMatch = severityFilter === 'all' || insight.severity === severityFilter;
                return typeMatch && severityMatch;
            });
            
            displayInsights();
        }
        
        function displayInsights() {
            const insightsList = document.getElementById('insightsList');
            if (!insightsList) return;
            
            if (filteredInsights.length === 0) {
                insightsList.innerHTML = `
                    <div class="no-insights">
                        <p>No insights match your current filters.</p>
                        <button onclick="document.getElementById('insightTypeFilter').value='all'; document.getElementById('insightSeverityFilter').value='all'; filterInsights();">Clear Filters</button>
                    </div>
                `;
                return;
            }
            
            insightsList.innerHTML = filteredInsights.map(insight => `
                <div class="insight-card ${insight.type} ${insight.severity}" data-insight-id="${insight.id}">
                    <div class="insight-header">
                        <span class="insight-icon">${getInsightIcon(insight)}</span>
                        <h3 class="insight-title">${insight.title}</h3>
                        <span class="insight-badge ${insight.severity}">${insight.severity}</span>
                    </div>
                    
                    <div class="insight-body">
                        <p class="insight-summary">${insight.summary}</p>
                        
                        ${insight.metrics ? `
                            <div class="insight-metrics">
                                ${Object.entries(insight.metrics).map(([key, value]) => `
                                    <div class="metric">
                                        <span class="metric-label">${formatMetricLabel(key)}:</span>
                                        <span class="metric-value">${value}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        <div class="insight-actions">
                            <h4>Recommended Actions:</h4>
                            <ul>
                                ${insight.actions.map(action => `
                                    <li class="action-item">
                                        <span class="action-priority ${action.priority}">${action.priority}</span>
                                        ${action.action}
                                        <span class="action-owner">(${action.owner})</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                </div>
            `).join('');
            
            // If in tab view mode, update tabs as well
            if (insightsViewMode === 'tab') {
                updateInsightTabs();
            }
        }
        
        function getInsightIcon(insight) {
            const icons = {
                anomaly: 'âš ï¸',
                trend: 'ðŸ“ˆ',
                savings: 'ðŸ’°',
                pattern: 'ðŸ”',
                risk: 'ðŸš¨'
            };
            return icons[insight.type] || 'ðŸ’¡';
        }
        
        function formatMetricLabel(key) {
            return key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        }
        
        function exportAIInsights() {
            if (currentInsights.length === 0) {
                alert('No insights to export. Please refresh insights first.');
                return;
            }
            
            // Create report content
            const report = {
                generatedAt: new Date().toISOString(),
                totalInsights: currentInsights.length,
                highPriority: currentInsights.filter(i => i.severity === 'high').length,
                insights: currentInsights.map(insight => ({
                    id: insight.id,
                    type: insight.type,
                    severity: insight.severity,
                    title: insight.title,
                    summary: insight.summary,
                    metrics: insight.metrics,
                    actions: insight.actions
                }))
            };
            
            // Convert to JSON and download
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-insights-report-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function configureAISettings() {
            // Create a simple settings modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2>AI Insights Configuration</h2>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>Sensitivity Level:</label>
                            <select id="aiSensitivity" class="form-control">
                                <option value="low" ${aiInsightsEngine.config.sensitivity === 'low' ? 'selected' : ''}>Low - Fewer insights, higher confidence</option>
                                <option value="medium" ${aiInsightsEngine.config.sensitivity === 'medium' ? 'selected' : ''}>Medium - Balanced insights</option>
                                <option value="high" ${aiInsightsEngine.config.sensitivity === 'high' ? 'selected' : ''}>High - More insights, lower threshold</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Maximum Insights:</label>
                            <input type="number" id="aiMaxInsights" class="form-control" value="${aiInsightsEngine.config.maxInsights}" min="5" max="50">
                        </div>
                        <div class="form-group">
                            <label>Anomaly Threshold (Standard Deviations):</label>
                            <input type="number" id="aiAnomalyThreshold" class="form-control" value="${aiInsightsEngine.config.anomalyThreshold}" min="2" max="5" step="0.5">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="saveAISettings(this.closest('.modal'))">Save Settings</button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function saveAISettings(modal) {
            const sensitivity = document.getElementById('aiSensitivity').value;
            const maxInsights = parseInt(document.getElementById('aiMaxInsights').value);
            const anomalyThreshold = parseFloat(document.getElementById('aiAnomalyThreshold').value);
            
            // Update configuration
            aiInsightsEngine.config.sensitivity = sensitivity;
            aiInsightsEngine.config.maxInsights = maxInsights;
            aiInsightsEngine.config.anomalyThreshold = anomalyThreshold;
            
            // Adjust thresholds based on sensitivity
            if (sensitivity === 'low') {
                aiInsightsEngine.config.anomalyThreshold = 4;
                aiInsightsEngine.config.trendMinDataPoints = 6;
            } else if (sensitivity === 'high') {
                aiInsightsEngine.config.anomalyThreshold = 2;
                aiInsightsEngine.config.trendMinDataPoints = 2;
            }
            
            // Save to localStorage
            localStorage.setItem('ai-insights-config', JSON.stringify(aiInsightsEngine.config));
            
            // Close modal
            modal.remove();
            
            // Refresh insights with new settings
            refreshAIInsights();
        }
        
        // Load AI configuration on startup
        const savedAIConfig = localStorage.getItem('ai-insights-config');
        if (savedAIConfig) {
            try {
                Object.assign(aiInsightsEngine.config, JSON.parse(savedAIConfig));
            } catch (e) {
                console.error('Error loading AI config:', e);
            }
        }
        
        // Helper function for formatting currency
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(amount);
        }
        
        // PDF Report Generation Function
        async function generatePDFReport() {
            if (!filteredData || filteredData.length === 0) {
                alert('No data available. Please upload and process data first.');
                return;
            }
            
            try {
                // Show loading indicator
                const button = document.querySelector('.generate-report-btn');
                const originalText = button.innerHTML;
                button.innerHTML = 'â³ Generating...';
                button.disabled = true;
                
                // Initialize jsPDF
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                let yPosition = 20;
                const pageHeight = doc.internal.pageSize.height;
                const margin = 20;
                
                // Helper function to check if new page is needed
                function checkNewPage(requiredSpace = 20) {
                    if (yPosition + requiredSpace > pageHeight - margin) {
                        doc.addPage();
                        yPosition = 20;
                        return true;
                    }
                    return false;
                }
                
                // Title Page
                doc.setFontSize(24);
                doc.setTextColor(44, 62, 80);
                doc.text('Procurement Analytics Report', 105, yPosition, { align: 'center' });
                yPosition += 15;
                
                doc.setFontSize(14);
                doc.setTextColor(52, 73, 94);
                doc.text('VSTX Analytics Dashboard', 105, yPosition, { align: 'center' });
                yPosition += 10;
                
                doc.setFontSize(10);
                doc.setTextColor(127, 140, 141);
                doc.text(`Generated on: ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`, 105, yPosition, { align: 'center' });
                yPosition += 20;
                
                // Executive Summary
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text('Executive Summary', margin, yPosition);
                yPosition += 10;
                
                // Calculate key metrics from filtered data
                const totalSpend = filteredData.reduce((sum, row) => sum + (row.amount || 0), 0);
                const totalTransactions = filteredData.reduce((sum, row) => sum + (row.transactions || 1), 0);
                const uniqueSuppliers = new Set(filteredData.map(row => row.supplier || row.vendor || 'Unknown')).size;
                const uniqueCategories = new Set(filteredData.map(row => row.category || 'Unknown')).size;
                
                doc.setFontSize(10);
                doc.setTextColor(52, 73, 94);
                const summaryData = [
                    ['Total Spend', formatCurrency(totalSpend)],
                    ['Total Transactions', totalTransactions.toLocaleString()],
                    ['Unique Suppliers', uniqueSuppliers.toLocaleString()],
                    ['Categories', uniqueCategories.toLocaleString()],
                    ['Date Range', getDateRange()],
                    ['Data Points', filteredData.length.toLocaleString()]
                ];
                
                doc.autoTable({
                    startY: yPosition,
                    head: [['Metric', 'Value']],
                    body: summaryData,
                    theme: 'grid',
                    headStyles: { fillColor: [74, 85, 104] },
                    margin: { left: margin, right: margin },
                    styles: { fontSize: 10 }
                });
                
                yPosition = doc.lastAutoTable.finalY + 15;
                
                // Category Analysis Section - Calculate fresh from filtered data
                checkNewPage(60);
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text('Category Analysis', margin, yPosition);
                yPosition += 10;
                
                // Calculate category data directly from filtered data
                const categoryMap = {};
                filteredData.forEach(row => {
                    const category = row.category || 'Unknown';
                    if (!categoryMap[category]) {
                        categoryMap[category] = {
                            spend: 0,
                            suppliers: new Set(),
                            transactions: 0
                        };
                    }
                    categoryMap[category].spend += row.amount || 0;
                    categoryMap[category].suppliers.add(row.supplier || row.vendor || 'Unknown');
                    categoryMap[category].transactions += row.transactions || 1;
                });
                
                // Convert to array and calculate percentages
                const categoryData = Object.entries(categoryMap)
                    .map(([category, data]) => ({
                        category,
                        spend: data.spend,
                        percentage: totalSpend > 0 ? (data.spend / totalSpend) * 100 : 0,
                        supplierCount: data.suppliers.size,
                        transactionCount: data.transactions
                    }))
                    .sort((a, b) => b.spend - a.spend)
                    .slice(0, 10) // Top 10
                    .map(cat => [
                        cat.category,
                        formatCurrency(cat.spend),
                        `${cat.percentage.toFixed(1)}%`,
                        cat.supplierCount.toLocaleString(),
                        cat.transactionCount.toLocaleString()
                    ]);
                
                if (categoryData.length > 0) {
                    doc.autoTable({
                        startY: yPosition,
                        head: [['Category', 'Total Spend', '% of Total', 'Suppliers', 'Transactions']],
                        body: categoryData,
                        theme: 'striped',
                        headStyles: { fillColor: [74, 85, 104] },
                        margin: { left: margin, right: margin },
                        styles: { fontSize: 9 }
                    });
                    
                    yPosition = doc.lastAutoTable.finalY + 15;
                } else {
                    doc.setFontSize(10);
                    doc.setTextColor(127, 140, 141);
                    doc.text('No category data available', margin, yPosition);
                    yPosition += 10;
                }
                
                // Top Suppliers Section
                checkNewPage(60);
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text('Top Suppliers', margin, yPosition);
                yPosition += 10;
                
                // Prepare supplier data
                const supplierMap = {};
                filteredData.forEach(row => {
                    const supplier = row.supplier || row.vendor || 'Unknown';
                    if (!supplierMap[supplier]) {
                        supplierMap[supplier] = { spend: 0, transactions: 0, categories: new Set() };
                    }
                    supplierMap[supplier].spend += row.amount || 0;
                    supplierMap[supplier].transactions += row.transactions || 1;
                    supplierMap[supplier].categories.add(row.category);
                });
                
                const supplierData = Object.entries(supplierMap)
                    .map(([supplier, data]) => ({
                        supplier,
                        spend: data.spend,
                        transactions: data.transactions,
                        categories: data.categories.size
                    }))
                    .sort((a, b) => b.spend - a.spend)
                    .slice(0, 10)
                    .map(s => [
                        s.supplier,
                        formatCurrency(s.spend),
                        s.transactions.toLocaleString(),
                        s.categories
                    ]);
                
                doc.autoTable({
                    startY: yPosition,
                    head: [['Supplier', 'Total Spend', 'Transactions', 'Categories']],
                    body: supplierData,
                    theme: 'striped',
                    headStyles: { fillColor: [74, 85, 104] },
                    margin: { left: margin, right: margin },
                    styles: { fontSize: 9 }
                });
                
                yPosition = doc.lastAutoTable.finalY + 15;
                
                // AI Insights Section (if available)
                if (currentInsights && currentInsights.length > 0) {
                    checkNewPage(60);
                    doc.setFontSize(16);
                    doc.setTextColor(44, 62, 80);
                    doc.text('AI-Generated Insights', margin, yPosition);
                    yPosition += 10;
                    
                    // Summary of insights
                    const highPriorityInsights = currentInsights.filter(i => i.severity === 'high').length;
                    const savingsInsights = currentInsights.filter(i => i.type === 'savings');
                    const totalSavings = savingsInsights.reduce((sum, i) => sum + (i.savingsAmount || 0), 0);
                    
                    doc.setFontSize(10);
                    doc.setTextColor(52, 73, 94);
                    doc.text(`Total Insights: ${currentInsights.length} | High Priority: ${highPriorityInsights} | Potential Savings: ${formatCurrency(totalSavings)}`, margin, yPosition);
                    yPosition += 10;
                    
                    // Group insights by type for better organization
                    const insightsByType = {
                        savings: currentInsights.filter(i => i.type === 'savings'),
                        anomaly: currentInsights.filter(i => i.type === 'anomaly'),
                        pattern: currentInsights.filter(i => i.type === 'pattern'),
                        trend: currentInsights.filter(i => i.type === 'trend')
                    };
                    
                    // Display insights by type, prioritizing savings opportunities
                    const typeOrder = ['savings', 'anomaly', 'pattern', 'trend'];
                    let insightCount = 0;
                    
                    for (const type of typeOrder) {
                        const insights = insightsByType[type];
                        if (insights.length > 0 && insightCount < 8) {
                            // Type header
                            checkNewPage(20);
                            doc.setFontSize(11);
                            doc.setFont(undefined, 'bold');
                            doc.setTextColor(44, 62, 80);
                            const typeTitle = type.charAt(0).toUpperCase() + type.slice(1) + ' Insights';
                            doc.text(typeTitle, margin, yPosition);
                            yPosition += 8;
                            
                            // Display up to 2 insights per type
                            const typeInsights = insights.slice(0, 2);
                            typeInsights.forEach((insight, index) => {
                                if (insightCount >= 8) return;
                                checkNewPage(30);
                                
                                // Insight header
                                doc.setFont(undefined, 'bold');
                                doc.setFontSize(10);
                                const color = getInsightColor(insight.severity);
                                doc.setTextColor(color[0], color[1], color[2]);
                                doc.text(`â€¢ ${insight.title}`, margin + 5, yPosition);
                                yPosition += 6;
                                
                                // Insight summary
                                doc.setFont(undefined, 'normal');
                                doc.setFontSize(9);
                                doc.setTextColor(52, 73, 94);
                                const summaryLines = doc.splitTextToSize(insight.summary, 165);
                                summaryLines.forEach(line => {
                                    doc.text(line, margin + 5, yPosition);
                                    yPosition += 5;
                                });
                                
                                // Show savings amount if available
                                if (insight.savingsAmount) {
                                    doc.setFont(undefined, 'italic');
                                    doc.setTextColor(40, 167, 69);
                                    doc.text(`Potential Savings: ${formatCurrency(insight.savingsAmount)}`, margin + 5, yPosition);
                                    yPosition += 5;
                                }
                                
                                yPosition += 3;
                                insightCount++;
                            });
                        }
                    }
                } else {
                    // No insights available message
                    checkNewPage(20);
                    doc.setFontSize(16);
                    doc.setTextColor(44, 62, 80);
                    doc.text('AI-Generated Insights', margin, yPosition);
                    yPosition += 10;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(127, 140, 141);
                    doc.text('No AI insights have been generated yet. Please click "Refresh Insights" in the dashboard.', margin, yPosition);
                    yPosition += 10;
                }
                
                // Visual Analytics Section
                checkNewPage(100);
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text('Visual Analytics', margin, yPosition);
                yPosition += 10;
                
                // Capture and add charts - prioritize visible/active charts
                const chartConfigs = [
                    { id: 'categoryChart', title: 'Category Distribution', tabName: 'categories' },
                    { id: 'paretoChart', title: 'Pareto Analysis (80/20 Rule)', tabName: 'pareto' },
                    { id: 'stratificationChart', title: 'Spend Stratification', tabName: 'stratification' }
                ];
                
                let chartsAdded = 0;
                
                // Store original active tab
                const originalActiveTab = document.querySelector('.nav-tab.active');
                const originalActiveTabName = originalActiveTab ? originalActiveTab.textContent : '';
                
                for (const chartConfig of chartConfigs) {
                    try {
                        // Activate the tab to make chart visible
                        // Direct tab activation without event
                        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                        
                        const selectedTab = document.getElementById(chartConfig.tabName);
                        if (selectedTab) {
                            selectedTab.classList.add('active');
                        }
                        
                        // Find and activate the corresponding nav tab
                        const navTabs = document.querySelectorAll('.nav-tab');
                        navTabs.forEach(tab => {
                            if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(chartConfig.tabName)) {
                                tab.classList.add('active');
                            }
                        });
                        
                        // Wait for chart to render and stabilize
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const chartCanvas = document.getElementById(chartConfig.id);
                        
                        if (!chartCanvas) {
                            console.warn(`Chart canvas ${chartConfig.id} not found`);
                            continue;
                        }
                        
                        console.log(`Chart ${chartConfig.id} dimensions: ${chartCanvas.width}x${chartCanvas.height}`);
                        
                        // Verify chart is rendered
                        if (chartCanvas.width === 0 || chartCanvas.height === 0) {
                            console.warn(`Chart ${chartConfig.id} not rendered (width: ${chartCanvas.width}, height: ${chartCanvas.height})`);
                            continue;
                        }
                        
                        // Capture the chart directly from canvas
                        checkNewPage(100);
                        
                        doc.setFontSize(12);
                        doc.setTextColor(44, 62, 80);
                        doc.text(chartConfig.title, margin, yPosition);
                        yPosition += 8;
                        
                        // Get chart instance and convert to image
                        const chart = Chart.getChart(chartConfig.id);
                        if (chart) {
                            // Use Chart.js built-in toBase64Image method
                            const imgData = chart.toBase64Image();
                            
                            const imgWidth = 170;
                            const aspectRatio = chartCanvas.height / chartCanvas.width;
                            const imgHeight = imgWidth * aspectRatio;
                            
                            // Ensure the image fits on the page
                            const maxHeight = 100;
                            const finalHeight = Math.min(imgHeight, maxHeight);
                            const finalWidth = finalHeight === maxHeight ? (finalHeight / aspectRatio) : imgWidth;
                            
                            doc.addImage(imgData, 'PNG', margin, yPosition, finalWidth, finalHeight);
                            yPosition += finalHeight + 10;
                            chartsAdded++;
                        } else {
                            // Fallback: try to capture canvas directly
                            const imgData = chartCanvas.toDataURL('image/png');
                            
                            const imgWidth = 170;
                            const aspectRatio = chartCanvas.height / chartCanvas.width;
                            const imgHeight = imgWidth * aspectRatio;
                            
                            const maxHeight = 100;
                            const finalHeight = Math.min(imgHeight, maxHeight);
                            const finalWidth = finalHeight === maxHeight ? (finalHeight / aspectRatio) : imgWidth;
                            
                            doc.addImage(imgData, 'PNG', margin, yPosition, finalWidth, finalHeight);
                            yPosition += finalHeight + 10;
                            chartsAdded++;
                        }
                    } catch (error) {
                        console.error(`Error capturing ${chartConfig.title}:`, error);
                        doc.setFontSize(9);
                        doc.setTextColor(127, 140, 141);
                        doc.text(`Unable to capture ${chartConfig.title} chart`, margin, yPosition);
                        yPosition += 8;
                    }
                }
                
                // Restore original active tab
                if (originalActiveTab) {
                    // Remove active from all tabs
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                    
                    // Restore the original active tab
                    originalActiveTab.classList.add('active');
                    
                    // Find and activate the corresponding content
                    const onclick = originalActiveTab.getAttribute('onclick');
                    if (onclick) {
                        const match = onclick.match(/showTab\('([^']+)'\)/);
                        if (match) {
                            const tabContent = document.getElementById(match[1]);
                            if (tabContent) {
                                tabContent.classList.add('active');
                            }
                        }
                    }
                }
                
                if (chartsAdded === 0) {
                    doc.setFontSize(10);
                    doc.setTextColor(127, 140, 141);
                    doc.text('No charts available for export. Please ensure charts are visible in the dashboard.', margin, yPosition);
                    yPosition += 10;
                }
                
                // Detailed Analytics Insights Section
                checkNewPage(80);
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text('Detailed Analytics Insights', margin, yPosition);
                yPosition += 10;
                
                // Pareto Analysis Insights
                if (paretoAnalytics && paretoAnalytics.totalSuppliers > 0) {
                    checkNewPage(60);
                    doc.setFontSize(14);
                    doc.setTextColor(44, 62, 80);
                    doc.text('Pareto Analysis: Insights and Interpretation', margin, yPosition);
                    yPosition += 8;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(52, 73, 94);
                    
                    // Key findings
                    const paretoRatio = ((paretoAnalytics.eightyPercentSuppliers / paretoAnalytics.totalSuppliers) * 100).toFixed(1);
                    const tailSuppliers = paretoAnalytics.totalSuppliers - paretoAnalytics.eightyPercentSuppliers;
                    const tailRatio = ((tailSuppliers / paretoAnalytics.totalSuppliers) * 100).toFixed(1);
                    
                    const paretoInsights = [
                        `â€¢ ${paretoAnalytics.eightyPercentSuppliers} suppliers (${paretoRatio}%) account for 80% of total spend`,
                        `â€¢ Top supplier represents ${paretoAnalytics.topSupplierPercentage.toFixed(1)}% of total spend (${formatCurrency(paretoAnalytics.topSupplierSpend)})`,
                        `â€¢ ${tailSuppliers} suppliers (${tailRatio}%) represent the tail spend (20% of total)`,
                        `â€¢ ${paretoAnalytics.ninetyPercentSuppliers} suppliers account for 90% of spend`
                    ];
                    
                    paretoInsights.forEach(insight => {
                        const lines = doc.splitTextToSize(insight, 170);
                        lines.forEach(line => {
                            doc.text(line, margin, yPosition);
                            yPosition += 5;
                        });
                    });
                    
                    yPosition += 5;
                    
                    // Strategic recommendations for Pareto
                    doc.setFont(undefined, 'bold');
                    doc.text('Strategic Recommendations:', margin, yPosition);
                    yPosition += 6;
                    doc.setFont(undefined, 'normal');
                    
                    const paretoRecommendations = generateParetoRecommendations();
                    paretoRecommendations.forEach((rec, index) => {
                        checkNewPage(15);
                        const recText = `${index + 1}. ${rec}`;
                        const lines = doc.splitTextToSize(recText, 170);
                        lines.forEach(line => {
                            doc.text(line, margin, yPosition);
                            yPosition += 5;
                        });
                        yPosition += 2;
                    });
                }
                
                // Tail Spend Analysis Insights
                if (tailSpendAnalytics && tailSpendAnalytics.totalSuppliers > 0) {
                    checkNewPage(50);
                    yPosition += 5;
                    doc.setFontSize(14);
                    doc.setTextColor(44, 62, 80);
                    doc.text('Tail Spend Analysis Insights', margin, yPosition);
                    yPosition += 8;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(52, 73, 94);
                    
                    const tailInsights = [
                        `â€¢ Tail spend represents ${tailSpendAnalytics.percentage.toFixed(1)}% of total spend (${formatCurrency(tailSpendAnalytics.totalSpend)})`,
                        `â€¢ ${tailSpendAnalytics.totalSuppliers} suppliers in tail spend segment`,
                        `â€¢ Average transaction size: ${formatCurrency(tailSpendAnalytics.avgTransactionSize)}`,
                        `â€¢ ${tailSpendAnalytics.onePurchaseSuppliers} suppliers with only one transaction`,
                        `â€¢ Top tail spend category: ${tailSpendAnalytics.topCategory} (${((tailSpendAnalytics.categoryBreakdown[tailSpendAnalytics.topCategory] / tailSpendAnalytics.totalSpend) * 100).toFixed(1)}%)`
                    ];
                    
                    tailInsights.forEach(insight => {
                        doc.text(insight, margin, yPosition);
                        yPosition += 5;
                    });
                }
                
                // Category Deep Dive
                if (categoryAnalytics && Object.keys(categoryAnalytics).length > 0) {
                    checkNewPage(50);
                    yPosition += 5;
                    doc.setFontSize(14);
                    doc.setTextColor(44, 62, 80);
                    doc.text('Category Analysis Deep Dive', margin, yPosition);
                    yPosition += 8;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(52, 73, 94);
                    
                    // Find categories with opportunities
                    const categories = Object.entries(categoryAnalytics)
                        .sort((a, b) => b[1].totalSpend - a[1].totalSpend)
                        .slice(0, 3);
                    
                    categories.forEach(([category, analytics]) => {
                        checkNewPage(25);
                        doc.setFont(undefined, 'bold');
                        doc.text(`${category}:`, margin, yPosition);
                        yPosition += 5;
                        doc.setFont(undefined, 'normal');
                        
                        const insights = [
                            `Spend: ${formatCurrency(analytics.totalSpend)} | Suppliers: ${analytics.supplierCount} | Risk: ${analytics.riskLevel}`,
                            `Supplier concentration: ${(analytics.concentration * 100).toFixed(1)}%`,
                            `Top subcategory: ${analytics.topSubcategory} (${formatCurrency(analytics.topSubcategorySpend)})`
                        ];
                        
                        insights.forEach(insight => {
                            doc.text(`  â€¢ ${insight}`, margin, yPosition);
                            yPosition += 5;
                        });
                        yPosition += 3;
                    });
                }
                
                // Spend Stratification Insights
                if (spendbandAnalytics && spendbandAnalytics.spendBandData && Object.keys(spendbandAnalytics.spendBandData).length > 0) {
                    checkNewPage(50);
                    yPosition += 5;
                    doc.setFontSize(14);
                    doc.setTextColor(44, 62, 80);
                    doc.text('Spend Stratification Analysis', margin, yPosition);
                    yPosition += 8;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(52, 73, 94);
                    
                    // Get spend bands data
                    const bands = Object.entries(spendbandAnalytics.spendBandData)
                        .sort((a, b) => {
                            const order = { 'Very High': 0, 'High': 1, 'Medium': 2, 'Low': 3 };
                            return order[a[0]] - order[b[0]];
                        });
                    
                    bands.forEach(([band, data]) => {
                        const supplierCount = data.suppliers ? data.suppliers.size : 0;
                        const categoryCount = data.categories ? data.categories.size : 0;
                        const totalSpend = data.spend || 0;
                        const percentage = spendbandAnalytics.totalSpend > 0 ? (totalSpend / spendbandAnalytics.totalSpend) * 100 : 0;
                        
                        if (supplierCount > 0) {
                            checkNewPage(20);
                            doc.setFont(undefined, 'bold');
                            doc.text(`${band} Spend Band:`, margin, yPosition);
                            yPosition += 5;
                            doc.setFont(undefined, 'normal');
                            
                            const avgSpendPerSupplier = supplierCount > 0 ? totalSpend / supplierCount : 0;
                            
                            const bandInsights = [
                                `Total: ${formatCurrency(totalSpend)} (${percentage.toFixed(1)}% of total)`,
                                `Suppliers: ${supplierCount} | Avg per supplier: ${formatCurrency(avgSpendPerSupplier)}`,
                                `Categories: ${categoryCount} | Transactions: ${data.transactions || 0}`
                            ];
                            
                            // Add strategy based on spend band
                            let strategy = '';
                            switch(band) {
                                case 'Very High':
                                    strategy = 'Strategic partnerships and long-term contracts';
                                    break;
                                case 'High':
                                    strategy = 'Volume consolidation and negotiated rates';
                                    break;
                                case 'Medium':
                                    strategy = 'Competitive bidding and catalog solutions';
                                    break;
                                case 'Low':
                                    strategy = 'Automated purchasing and P-cards';
                                    break;
                            }
                            if (strategy) {
                                bandInsights.push(`Strategy: ${strategy}`);
                            }
                            
                            bandInsights.forEach(insight => {
                                const lines = doc.splitTextToSize(`  â€¢ ${insight}`, 170);
                                lines.forEach(line => {
                                    doc.text(line, margin, yPosition);
                                    yPosition += 5;
                                });
                            });
                            yPosition += 3;
                        }
                    });
                }
                
                // Recommendations Section
                checkNewPage(80);
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text('Strategic Recommendations', margin, yPosition);
                yPosition += 10;
                
                // Generate recommendations based on data analysis
                const recommendations = generateRecommendations();
                
                if (recommendations.length > 0) {
                    doc.setFontSize(10);
                    recommendations.forEach((rec, index) => {
                        checkNewPage(30);
                        
                        // Recommendation title
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(44, 62, 80);
                        doc.text(`${index + 1}. ${rec.title}`, margin, yPosition);
                        yPosition += 6;
                        
                        // Recommendation description
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(52, 73, 94);
                        const descLines = doc.splitTextToSize(rec.description, 170);
                        descLines.forEach(line => {
                            doc.text(line, margin, yPosition);
                            yPosition += 5;
                        });
                        
                        // Impact
                        if (rec.impact) {
                            doc.setFont(undefined, 'italic');
                            doc.setTextColor(40, 167, 69);
                            doc.text(`Expected Impact: ${rec.impact}`, margin, yPosition);
                            yPosition += 8;
                        }
                    });
                } else {
                    doc.setFontSize(10);
                    doc.setTextColor(127, 140, 141);
                    doc.text('No specific recommendations available at this time.', margin, yPosition);
                    yPosition += 10;
                }
                
                // Footer on all pages
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(8);
                    doc.setTextColor(127, 140, 141);
                    doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
                    doc.text('Generated by VSTX Analytics Dashboard', 105, 290, { align: 'center' });
                }
                
                // Save the PDF
                doc.save(`VSTX-Analytics-Report-${new Date().toISOString().split('T')[0]}.pdf`);
                
                // Restore button
                button.innerHTML = originalText;
                button.disabled = false;
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Error generating PDF report. Please check the console for details.');
                
                // Restore button
                const button = document.querySelector('.generate-report-btn');
                if (button) {
                    button.innerHTML = 'ðŸ“„ Generate Report';
                    button.disabled = false;
                }
            }
        }
        
        // Helper function for PDF generation
        function getInsightColor(severity) {
            switch(severity) {
                case 'high': return [220, 53, 69];
                case 'medium': return [255, 193, 7];
                case 'low': return [40, 167, 69];
                default: return [52, 73, 94];
            }
        }
        
        // Helper function to get date range
        function getDateRange() {
            if (!filteredData || filteredData.length === 0) return 'N/A';
            
            const dates = filteredData
                .map(row => parseDate(row.date))
                .filter(date => date && !isNaN(date))
                .sort((a, b) => a - b);
            
            if (dates.length === 0) return 'N/A';
            
            const startDate = dates[0].toLocaleDateString();
            const endDate = dates[dates.length - 1].toLocaleDateString();
            
            return `${startDate} - ${endDate}`;
        }
        
        // Generate Pareto-specific recommendations
        function generateParetoRecommendations() {
            const recommendations = [];
            
            if (!paretoAnalytics || paretoAnalytics.totalSuppliers === 0) return recommendations;
            
            const paretoRatio = paretoAnalytics.eightyPercentSuppliers / paretoAnalytics.totalSuppliers;
            const tailSuppliers = paretoAnalytics.totalSuppliers - paretoAnalytics.eightyPercentSuppliers;
            
            // Core supplier strategy
            if (paretoRatio < 0.2) {
                recommendations.push(`Focus on top ${paretoAnalytics.eightyPercentSuppliers} strategic suppliers. Develop partnership programs, volume agreements, and innovation initiatives to maximize value from these key relationships.`);
            }
            
            // Tail spend management
            if (tailSuppliers > 50) {
                recommendations.push(`Implement tail spend management program for ${tailSuppliers} suppliers. Consider P-card programs, cataloging, or working with aggregators to reduce transaction costs by 20-30%.`);
            }
            
            // Supplier consolidation
            if (paretoAnalytics.totalSuppliers > 100 && paretoRatio > 0.3) {
                recommendations.push(`High fragmentation detected. Target 30-40% supplier reduction through strategic consolidation while maintaining competitive tension in key categories.`);
            }
            
            // Risk mitigation
            if (paretoAnalytics.topSupplierPercentage > 15) {
                recommendations.push(`Top supplier concentration risk: ${paretoAnalytics.topSupplierPercentage.toFixed(1)}% of spend. Develop risk mitigation strategy including dual sourcing for critical items.`);
            }
            
            // Process optimization
            recommendations.push(`Automate procurement processes for bottom 80% of suppliers to reduce administrative burden. Focus strategic resources on managing top 20% relationships.`);
            
            return recommendations;
        }
        
        // Generate recommendations based on data analysis
        function generateRecommendations() {
            const recommendations = [];
            
            if (!filteredData || filteredData.length === 0) return recommendations;
            
            // Calculate metrics for recommendations
            const totalSpend = filteredData.reduce((sum, row) => sum + (row.amount || 0), 0);
            const uniqueSuppliers = new Set(filteredData.map(row => row.supplier || row.vendor)).size;
            const uniqueCategories = new Set(filteredData.map(row => row.category)).size;
            
            // Supplier consolidation recommendation
            if (uniqueSuppliers > 50) {
                const potentialSaving = totalSpend * 0.10; // 10% potential saving
                recommendations.push({
                    title: 'Supplier Consolidation Opportunity',
                    description: `With ${uniqueSuppliers} suppliers in your portfolio, there's significant opportunity for consolidation. Consider implementing a strategic sourcing initiative to reduce supplier count by 20-30% while maintaining service quality.`,
                    impact: `Potential savings of ${formatCurrency(potentialSaving)} through volume discounts and reduced administrative costs`
                });
            }
            
            // Category optimization recommendation
            const categoryMap = {};
            filteredData.forEach(row => {
                const category = row.category || 'Unknown';
                categoryMap[category] = (categoryMap[category] || 0) + (row.amount || 0);
            });
            
            const topCategories = Object.entries(categoryMap)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3);
            
            if (topCategories.length > 0 && topCategories[0][1] / totalSpend > 0.3) {
                recommendations.push({
                    title: 'Category Spend Concentration',
                    description: `Your top category "${topCategories[0][0]}" represents ${((topCategories[0][1] / totalSpend) * 100).toFixed(1)}% of total spend. Consider developing category-specific strategies, negotiating long-term contracts, and implementing category management best practices.`,
                    impact: `5-15% cost reduction through strategic category management`
                });
            }
            
            // Tail spend recommendation
            const supplierSpendMap = {};
            filteredData.forEach(row => {
                const supplier = row.supplier || row.vendor || 'Unknown';
                supplierSpendMap[supplier] = (supplierSpendMap[supplier] || 0) + (row.amount || 0);
            });
            
            const tailSuppliers = Object.values(supplierSpendMap).filter(spend => spend < 10000).length;
            const tailSpendRatio = tailSuppliers / uniqueSuppliers;
            
            if (tailSpendRatio > 0.6) {
                recommendations.push({
                    title: 'Tail Spend Management',
                    description: `${(tailSpendRatio * 100).toFixed(0)}% of your suppliers represent tail spend (under $10K annually). Implement a tail spend management program using P-cards, catalogs, or aggregation strategies to reduce transaction costs.`,
                    impact: `15-20% reduction in processing costs for tail spend transactions`
                });
            }
            
            // Contract compliance recommendation
            if (currentInsights && currentInsights.length > 0) {
                const anomalies = currentInsights.filter(i => i.type === 'anomaly').length;
                if (anomalies > 5) {
                    recommendations.push({
                        title: 'Improve Contract Compliance',
                        description: `Multiple spending anomalies detected (${anomalies} instances). Implement automated compliance monitoring and approval workflows to ensure adherence to negotiated contracts and pricing agreements.`,
                        impact: `2-5% savings through improved contract compliance`
                    });
                }
            }
            
            // Digital transformation recommendation
            recommendations.push({
                title: 'Digital Procurement Transformation',
                description: 'Consider implementing e-procurement solutions, automated approval workflows, and supplier portals to streamline operations and improve visibility across the procurement lifecycle.',
                impact: '20-30% reduction in procurement cycle time and operational costs'
            });
            
            // Add insights from analytics if available
            if (paretoAnalytics && paretoAnalytics.totalSuppliers > 0) {
                const efficiency = paretoAnalytics.eightyPercentSuppliers / paretoAnalytics.totalSuppliers;
                if (efficiency < 0.15) {
                    recommendations.push({
                        title: 'Leverage Pareto Efficiency',
                        description: `Your procurement is highly efficient with only ${paretoAnalytics.eightyPercentSuppliers} suppliers driving 80% of spend. Focus on strategic partnerships and long-term value creation with these key suppliers.`,
                        impact: 'Additional 5-10% savings through strategic partnerships'
                    });
                }
            }
            
            // Tail spend insights
            if (typeof tailSpendAnalytics !== 'undefined' && tailSpendAnalytics && tailSpendAnalytics.percentage > 15) {
                recommendations.push({
                    title: 'Tail Spend Optimization',
                    description: `Tail spend represents ${tailSpendAnalytics.percentage.toFixed(1)}% of total spend across ${tailSpendAnalytics.totalSuppliers} suppliers. Implement automated procurement solutions for low-value, high-frequency purchases.`,
                    impact: `Potential savings of ${formatCurrency(tailSpendAnalytics.totalSpend * 0.15)} through process automation`
                });
            }
            
            // Seasonality insights
            if (typeof seasonalityAnalytics !== 'undefined' && seasonalityAnalytics && seasonalityAnalytics.categoryResults && Object.keys(seasonalityAnalytics.categoryResults).length > 0) {
                recommendations.push({
                    title: 'Seasonal Procurement Planning',
                    description: 'Leverage identified seasonal patterns to negotiate better rates during low-demand periods and ensure supply availability during peak seasons.',
                    impact: '3-7% cost reduction through strategic timing of purchases'
                });
            }
            
            return recommendations.slice(0, 8); // Return top 8 recommendations
        }
        
        // AI Insights View Management
        let insightsViewMode = 'list'; // 'list' or 'tab'
        
        function toggleInsightsView() {
            const listView = document.getElementById('insightsListView');
            const tabView = document.getElementById('insightsTabView');
            const tabs = document.getElementById('insightsTabs');
            const toggleIcon = document.getElementById('viewToggleIcon');
            const toggleText = document.getElementById('viewToggleText');
            
            if (insightsViewMode === 'list') {
                // Switch to tab view
                insightsViewMode = 'tab';
                listView.style.display = 'none';
                tabView.style.display = 'block';
                tabs.style.display = 'flex';
                toggleIcon.textContent = 'ðŸ“‹';
                toggleText.textContent = 'Switch to List View';
                
                // Update tab content
                updateInsightTabs();
            } else {
                // Switch to list view
                insightsViewMode = 'list';
                listView.style.display = 'block';
                tabView.style.display = 'none';
                tabs.style.display = 'none';
                toggleIcon.textContent = 'ðŸ“Š';
                toggleText.textContent = 'Switch to Tab View';
            }
        }
        
        function showInsightTab(tabType) {
            // Update active tab button
            document.querySelectorAll('.insight-tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Hide all tab contents
            document.querySelectorAll('.insight-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Show selected tab content
            const tabContent = document.getElementById(`${tabType}-insights`);
            if (tabContent) {
                tabContent.classList.add('active');
            }
        }
        
        function updateInsightTabs() {
            if (!currentInsights || currentInsights.length === 0) return;
            
            // Group insights by type
            const groupedInsights = {
                savings: currentInsights.filter(i => i.type === 'savings'),
                anomaly: currentInsights.filter(i => i.type === 'anomaly'),
                pattern: currentInsights.filter(i => i.type === 'pattern'),
                trend: currentInsights.filter(i => i.type === 'trend'),
                all: currentInsights
            };
            
            // Update tab counts
            document.getElementById('savingsCount').textContent = groupedInsights.savings.length;
            document.getElementById('anomalyCount').textContent = groupedInsights.anomaly.length;
            document.getElementById('patternCount').textContent = groupedInsights.pattern.length;
            document.getElementById('trendCount').textContent = groupedInsights.trend.length;
            
            // Update tab contents
            Object.entries(groupedInsights).forEach(([type, insights]) => {
                const container = document.getElementById(`${type}-insights`);
                if (!container) return;
                
                if (insights.length === 0) {
                    container.innerHTML = `
                        <div class="no-insights">
                            <p>No ${type === 'all' ? '' : type} insights found.</p>
                        </div>
                    `;
                } else {
                    // Add type-specific headers
                    let header = '';
                    if (type === 'savings') {
                        const totalSavings = insights.reduce((sum, i) => sum + (i.savingsAmount || 0), 0);
                        header = `
                            <div class="tab-header">
                                <h3>ðŸ’° Savings Opportunities</h3>
                                <p>Total potential savings: ${aiInsightsEngine.formatCurrency(totalSavings)}</p>
                            </div>
                        `;
                    } else if (type === 'anomaly') {
                        header = `
                            <div class="tab-header">
                                <h3>âš ï¸ Detected Anomalies</h3>
                                <p>Unusual patterns and outliers in your spending data</p>
                            </div>
                        `;
                    } else if (type === 'pattern') {
                        header = `
                            <div class="tab-header">
                                <h3>ðŸ” Spending Patterns</h3>
                                <p>Recurring trends and behavioral patterns</p>
                            </div>
                        `;
                    } else if (type === 'trend') {
                        header = `
                            <div class="tab-header">
                                <h3>ðŸ“ˆ Trend Analysis</h3>
                                <p>Long-term spending trends and forecasts</p>
                            </div>
                        `;
                    }
                    
                    container.innerHTML = header + insights.map(insight => `
                        <div class="insight-card ${insight.type} ${insight.severity}" data-insight-id="${insight.id}">
                            <div class="insight-header">
                                <span class="insight-icon">${getInsightIcon(insight)}</span>
                                <h3 class="insight-title">${insight.title}</h3>
                                <span class="insight-badge ${insight.severity}">${insight.severity}</span>
                            </div>
                            
                            <div class="insight-body">
                                <p class="insight-summary">${insight.summary}</p>
                                
                                ${insight.metrics ? `
                                    <div class="insight-metrics">
                                        ${Object.entries(insight.metrics).map(([key, value]) => `
                                            <div class="metric">
                                                <span class="metric-label">${formatMetricLabel(key)}:</span>
                                                <span class="metric-value">${value}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                                
                                <div class="insight-actions">
                                    <h4>Recommended Actions:</h4>
                                    <ul>
                                        ${insight.actions.map(action => `
                                            <li class="action-item">
                                                <span class="action-priority ${action.priority}">${action.priority}</span>
                                                ${action.action}
                                                <span class="action-owner">(${action.owner})</span>
                                            </li>
                                        `).join('')}
                                    </ul>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
            });
        }

    </script>

    <!-- Professional Footer -->
    <footer class="dashboard-footer">
        <div class="footer-content">
            <div class="footer-left">

                <div class="footer-tagline">Transforming Data into Strategic Advantage</div>
            </div>
            <div class="footer-center">
                <div class="footer-powered">Powered by DefoxxAnalytics</div>
            </div>
            <div class="footer-right">

            </div>
        </div>
        </div>
        <div class="footer-bottom">
            <div class="footer-copyright">
                Â© 2024 DefoxxAnalytics. All rights reserved. |
                <a href="https://defoxxanalytics.github.io/VSTX-advpro/" target="_blank">Dashboard Home</a> |
                Versatex a Division of d.e Foxx & Associates
            </div>
        </div>
    </footer>
</body>

</html>